<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>（二）Rust语义模型 - Rust中文博客</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html">序言</a></li><li class="chapter-item expanded affix "><li class="part-title">2023-06</li><li class="chapter-item expanded "><a href="../2023-06-rustbelt/00.html">RustBelt——Rust语言的形式化语义模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2023-06-rustbelt/01-background.html">（零）背景</a></li><li class="chapter-item expanded "><a href="../2023-06-rustbelt/02-logics.html">（一）形式化逻辑基础</a></li><li class="chapter-item expanded "><a href="../2023-06-rustbelt/03-rust-semantics.html" class="active">（二）Rust语义模型</a></li><li class="chapter-item expanded "><a href="../2023-06-rustbelt/04-rc.html">（三）示例Rc</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">2022-01</li><li class="chapter-item expanded "><a href="../2022-01-polonius/00.html">Polonius学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2022-01-polonius/01-21-借用检查（零）-原子式与输入.html">（零）原子式与输入</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/01-21-借用检查（一）-初始化分析.html">（一）初始化分析</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/01-23-借用检查（二）-存活性分析.html">（二）存活性分析</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/02-08-借用检查（三）-借债分析.html">（三）借债分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2022-01-polonius/02-08-借用检查（三）-借债分析-原始规则.html">(1) 原始规则</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/02-19-借用检查（三）-借债分析-位置无关规则.html">(2) 位置无关规则</a></li><li class="chapter-item expanded "><div>(3) 优化规则</div></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">2021-09</li><li class="chapter-item expanded "><a href="../2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li><li class="chapter-item expanded affix "><li class="part-title">2021-01</li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/00.html">Rust过程宏入门系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-06-过程宏（一）-过程宏简介.html">（一）过程宏简介</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html">（二）初探派生宏</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-10-过程宏（三）-实现简易派生宏.html">（三）实现简易派生宏</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html">（四）遍历结构体字段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust中文博客</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/frank-king/rustblog-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust语义模型"><a class="header" href="#rust语义模型">Rust语义模型</a></h1>
<h2 id="-lambda_textrmrust-的类型系统部分1"><a class="header" href="#-lambda_textrmrust-的类型系统部分1">\( \lambda_\textrm{Rust} \)的类型系统（部分）<sup class="footnote-reference"><a href="#types">1</a></sup></a></h2>
<p><img src="images/type-system.png" alt="Type System" /></p>
<p>\[
\begin{array}{lll}
\text{值}     &amp; \text{Val}  &amp; \ni v \mathrel{\mathop:\!\!:}= \mathbf{false} \; | \; \mathbf{true} \; | \; z \; | \; \ell \; | \cdots \\
\text{生存期} &amp; \text{Lft}  &amp; \ni \kappa \mathrel{\mathop:\!\!:}= \alpha \; | \; \mathbf{static} \\
\text{可变性} &amp; \text{Mod}  &amp; \ni \mu    \mathrel{\mathop:\!\!:}= \mathbf{mut} \; | \; \mathbf{shr} \\
\text{类型}   &amp; \text{Type} &amp; \ni \tau   \mathrel{\mathop:\!\!:}= T \; | \; \mathbf{bool} \; | \; \mathbf{int} \\
&amp;&amp; \quad | \; \mathbf{own} \, T \; | \; \&amp;_\mu^\kappa T \\
&amp;&amp; \quad | \; \prod \bar{\tau} \; | \; \sum \bar{\tau} \; | \cdots
\end{array}
\]</p>
<p>常用的Rust类型与\( \lambda_\textrm{Rust} \)类型的对照关系如下表所示：</p>
<table><thead><tr><th>\( \lambda_\textrm{Rust} \)类型</th><th>Rust类型</th></tr></thead><tbody>
<tr><td>\( \mathbf{bool} \; | \; \mathbf{int} \)</td><td><code>bool</code> | <code>BigInt</code></td></tr>
<tr><td>\( \mathbf{own} \, T \)</td><td><code>Box&lt;T&gt;</code></td></tr>
<tr><td>\( \&amp;_{\mathbf{mut}}^\alpha T \; | \; \&amp;_{\mathbf{shr}}^\alpha T \)</td><td><code>&amp;'a mut T</code> | <code>&amp;'a T</code></td></tr>
<tr><td>\( \tau_1 \times \tau_2 \; | \; \prod [] \)</td><td><code>(T1, T2)</code> | <code>()</code></td></tr>
<tr><td>\( \tau_1 + \tau_2 \; | \; \sum [] \)</td><td><code>enum Type { A(T1), B(T2) }</code> | <code>enum Type {}</code> 或 <code>!</code></td></tr>
<tr><td>\( \prod [] + \tau \)</td><td><code>Option&lt;T&gt;</code></td></tr>
</tbody></table>
<p>其中：</p>
<ul>
<li>\( \lambda_\textrm{Rust} \)的\( \mathbf{int} \)类型为忽略机器字长的任意大小的整型；</li>
<li>\( \lambda_\textrm{Rust} \)的<strong>积类型</strong>（Product Type，\( \prod \bar{\tau} \)）相当于Rust的<strong>元组</strong>（Tuple）或<strong>结构体</strong>（Struct）类型；</li>
<li>\( \lambda_\textrm{Rust} \)的<strong>和类型</strong>（Sum Type，\( \sum \bar{\tau} \)）相当于Rust的<strong>枚举</strong>（Enum）类型；</li>
<li>\( \lambda_\textrm{Rust} \)的单位积类型（\( \prod [] \)）相当于Rust的<strong>单元</strong>（Unit）类型（<code>()</code>）；</li>
<li>\( \lambda_\textrm{Rust} \)的单位和类型（\( \sum [] \)）相当于Rust的空枚举类型（<code>enum Type {}</code>）或Never类型（<code>!</code>）．</li>
</ul>
<div class="footnote-definition" id="types"><sup class="footnote-definition-label">1</sup>
<p>\( \lambda_\text{Rust} \)基于Rust中的<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR</a>，其表达式的语法与Rust不同，更接近<a href="https://en.wikipedia.org/wiki/Lambda_calculus">\(\lambda\)-calculus</a>的语法．这里简单起见直接用使用类Rust的语法．</p>
</div>
<h2 id="类型的-textown--predict"><a class="header" href="#类型的-textown--predict">类型的\( \text{own} \) Predict</a></h2>
<p><img src="images/own-predict.png" alt="own Predict" /></p>
<p>以几个简单类型为例，说明\( \text{own} \) predict的含义：</p>
<ul>
<li>\[
[\![ \mathbf{bool} ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \; \bar{v} = [\mathbf{true}] \lor \bar{v} = [\mathbf{false}]
\]
即属于布尔类型\(\mathbf{bool}\)的值\(\bar{v}\)要么为单个值\(\mathbf{false}\)，要么为单个值\(\mathbf{true}\)．</li>
<li>\[ [\![ \mathbf{int}  ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \; \exists z \in \mathbb{Z}. \bar{v} = [z] \]
即属于整型\(\mathbf{int}\)的值\(\bar{v}\)为单个整数\(z\)．</li>
<li>\[
[\![ \tau_1 \times \tau_2 ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \;
\exists \bar{v}_1, \bar{v}_2. (\bar{v} = \bar{v}_1 +\!+ \, \bar{v}_2) \ast
[\![ \tau_1 ]\!].\!\text{own}(\bar{v}_1) \ast [\![ \tau_2 ]\!].\!\text{own}(\bar{v}_2)
\]
即属于积类型\( \tau_1 \times \tau_2 \)的值\(\bar{v}\)为分别属于两个类型\(\tau_1\)与\(\tau_2\)的值
\(\bar{v}_1\)与\(\bar{v}_2\)相连．此处的\(+\!+\)为列表连接（Concentation）运算．</li>
<li>\[
\left[\!\!\left[ \sum_{i=0}^{n-1} \tau_i \right]\!\!\right].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \;
\exists i \in \mathbb{N}, \bar{w}. (i &lt; n) \ast (\bar{v} = [i] +\!+ \, \bar{w}) \ast [\![ \tau_i ]\!].\!\text{own}(\bar{w})
\]
即属于和类型\( \sum_{i=1}^n \tau_i \)的值\(\bar{v}\)为一个自然数\(i\)代表其枚举变体（Variant）序号，与一个属于类型
\(\tau_i\)的值\(\bar{w}\)相连．</li>
</ul>
<p>因此，\( [\![ \tau ]\!].\!\text{own}(\bar{v}) \)表示类型\(\tau\)对值列表\(\bar{v}\)的约束关系<sup class="footnote-reference"><a href="#conc">2</a></sup>．</p>
<p>联想到Rust中的<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code><strong>特质</strong></a>（Trait），
可以定义\( \lambda_\textrm{Rust} \)中的\( \mathsf{Copy} \)语义如下：
\[
\tau: \mathsf{Copy} \; \mathrel{\mathop:}= \; [\![ \tau ]\!].\!\text{own}(\bar{v}) \; \mathsf{Persistent}
\]
即当类型\(\tau\)不含任何资源时，它才是\(\mathsf{Copy}\)的．</p>
<div class="footnote-definition" id="conc"><sup class="footnote-definition-label">2</sup>
<p>省略了多线程的部分．</p>
</div>
<h2 id="类型的-textsize-属性"><a class="header" href="#类型的-textsize-属性">类型的\( \text{size} \)属性*</a></h2>
<p><img src="images/size.png" alt="size Property" /></p>
<p>在不考虑<a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html"><strong>动态大小类型</strong>（Dynamically Sized Types, DST）</a>
的情况下，每一个Rust类型都确定的内存大小，而在\( \lambda_\textrm{Rust} \)中也有类似的属性．</p>
<p>常见类型的\( \text{size} \)属性如下：</p>
<ul>
<li>\( [\![ \mathbf{bool} ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \mathbf{int} ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \mathbf{own} \, \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \&amp;_\mathbf{mut}^\kappa \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \&amp;_\mathbf{shr}^\kappa \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \tau_1 \times \tau_2 ]\!].\!\text{size} \mathrel{\mathop:}=
[\![ \tau_1 ]\!].\!\text{size} + [\![ \tau_2 ]\!].\!\text{size} \)</li>
<li>\(
\left[\!\left[ \sum_i \tau_i \right]\!\right].\!\text{size} \mathrel{\mathop:}= 1 + \displaystyle \max_i [\![ \tau_i ]\!].\!\text{size}
\)</li>
</ul>
<p>此外，类型的\( \text{size} \)属性还须与\( \text{own} \) predict所关联的值列表的长度保持一致，即：
\[ \forall \tau, \bar{v}. [\![ \tau ]\!].\!\text{own}(\bar{v}) \; -\!\ast \; |\bar{v}| = [\![ \tau ]\!].\!\text{size} \]</p>
<h2 id="独占所有权exclusive-ownership与可变借用"><a class="header" href="#独占所有权exclusive-ownership与可变借用">独占所有权（Exclusive Ownership）与可变借用</a></h2>
<p><img src="images/box.png" alt="Execlusive Ownership" /></p>
<h3 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h3>
<p>对于<code>Box&lt;T&gt;</code>类型，其\( \text{own} \) predict相比\(\mathbf{int}\)等简单类型更加复杂．
\[
\begin{array}{lll}
[\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, \exists \bar{w}. \ell \mapsto \bar{w} \ast [\![ \tau ]\!].\!\text{own}(\bar{w})
&amp; \ell \text{指向属于类型} \tau \text{的值} \bar{w} \\
&amp; \ast \, \mathsf{Dealloc}(\ell, [\![ \tau ]\!].\!\text{size})
&amp; \text{允许释放以} \ell \text{开始，长度为} [\![ \tau ]\!].\!\text{size} \text{的内存}
\end{array}
\]
若将\( \exists \bar{w}. \ell \mapsto \bar{w} \ast [\![ \tau ]\!].\!\text{own}(\bar{w}) \)简写为
\( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \) （即此时并不关心具体的值\(\bar{w}\)），那么上式可简化为
\[
[\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) \, \mathrel{\mathop:}= \, \exists \ell. (\bar{v} = [\ell])
\ast (\ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own})
\ast \mathsf{Dealloc}(\ell, [\![ \tau ]\!].\!\text{size})
\]</p>
<h3 id="a-mut-t"><a class="header" href="#a-mut-t"><code>&amp;'a mut T</code></a></h3>
<p><code>&amp;'a mut T</code>类型与<code>Box&lt;T&gt;</code>很相似，其\( \text{own} \) predict如下：
\[
\begin{array}{lll}
\left[\!\left[ \&amp;_\mathbf{mut}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, \&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big)
&amp; \text{在生存期} \kappa \text{的完全借用范围内，} \ell \text{指向属于类型} \tau \text{的值}
\end{array}
\]</p>
<p>比较\( [\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) \)与
\( \left[\!\left[ \&amp;_\mathbf{mut}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) \)可以发现：</p>
<ul>
<li>\( \exists \ell. \bar{v} = [\ell] \)表明二者都是单个地址值；</li>
<li>\( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \)表明二者都指向属于类型\(\tau\)的值，但
\( \&amp;_\mathbf{mut}^\kappa \tau \)类型有生存期\( \kappa \)的约束范围．</li>
</ul>
<h3 id="独占的可变借用"><a class="header" href="#独占的可变借用">独占的可变借用</a></h3>
<p>\( \&amp;_\mathsf{full}^\kappa P \) 表示对资源\(P\)的独占借用，生存期为\(\kappa\)．它可通过资源\(P\)任意创建
\[ P \, -\!\ast\; \&amp;_\mathsf{full}^\kappa P \ast \big( [\dagger \kappa] -\!\ast\, P \big) \]
可见，创建\( \&amp;_\mathsf{full}^\kappa P \)需要消耗𠩤来的资源\(P\)；且仅当生存期\(\kappa\)结束时（即获取\([\dagger\kappa]\)后），
才能再次归还资源\(P\)．</p>
<p>这与在Rust语言中</p>
<pre><code class="language-rust ignore">let mut x: Box&lt;T&gt; = /* ... */;
{
    let y: &amp;'a mut T = &amp;mut *x; // 'a &lt;-+
    // `x` is not accessible            |
    use(y); //                          |
} // `'a` ends &lt;------------------------+
access(x); // `x` is accessible again
</code></pre>
<p>可变借用<code>&amp;mut *x</code>得到<code>&amp;'a mut T</code>的语义一致，即在<code>y: &amp;'a mut T</code>存续期间，原有<code>x</code>的值不可再访问；仅当<code>'a</code>结束后，再重新归还<code>x</code>的所有权．</p>
<h2 id="生存期lifetime"><a class="header" href="#生存期lifetime">生存期（Lifetime）*</a></h2>
<p><img src="images/lifetime.png" alt="Lifetime" /></p>
<p>上文中提到生存期结束时的\( [\dagger \kappa] \) token，接下来将简单介绍一下\( \lambda_\textrm{Rust} \)中生存期的表示．</p>
<h3 id="什么是生存期"><a class="header" href="#什么是生存期">什么是生存期？</a></h3>
<p>C++或其他编程语言中，<a href="https://en.cppreference.com/w/cpp/language/lifetime">生存期</a>一般是指变量或对象从创建开始到销毁的一段时间，
是<strong>运行时</strong>（Runtime）的概念．C++中生存期偶尔也指<a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>对象所属的作用域，
因为这类对象的创建与释放与其作用域绑定在一起．</p>
<p>而Rust中的<a href="https://doc.rust-lang.org/nomicon/lifetimes.html">生存期</a>概念则有所不同，更多是指引用类型或者借用的有效期，是<strong>抽象语法树</strong>
（Abstract Syntax Tree，AST）或者<strong>控制流图</strong>（Control-Flow Graph，CFG）上的概念而非运行时的概念．</p>
<p>最简单的理解是把生存期近似看作<strong>作用域</strong>（scope）<sup class="footnote-reference"><a href="#scope">3</a></sup>，如以下代码段所示</p>
<pre><code class="language-rust ignore">let mut x = Box::new(1);
'a: {
    let y = &amp;'a mut x; // start of 'a &lt;--+
    *y += 1; //                          |
} // end of `'a` &lt;-----------------------+
</code></pre>
<p>生存期随新的作用域打开而开始，随作用域关闭而结束．</p>
<p>在\( \lambda_\textrm{Rust} \)中，生存期的开始及结束与Rust类似：
\[ 
\begin{array}{lll}
\mathsf{True} &amp; -\!\ast\, \exists \kappa. [\kappa] 
&amp; \text{生存期} \kappa \text{开始时，新建一个token } [\kappa] \text{，该token代表生存期} \kappa \text{存活}  \\
&amp; \ast\; \big([\kappa] -\!\ast\, [\dagger \kappa]\big) 
&amp; \text{生存期} \kappa \text{结束时，消耗原token } [\kappa] \text{后，得到生存期结束的token } [\dagger \kappa]
\end{array}
\]
这里生存期结束的token\([\dagger \kappa]\)是永久的，即
\[ [\dagger \kappa] \; \mathsf{Persistent} \]
这是因为生存期一旦结束，便已成定局，所以此处的token将永久存在，不被消耗．</p>
<div class="footnote-definition" id="scope"><sup class="footnote-definition-label">3</sup>
<p>后来Rust引入了<a href="https://rust-lang.github.io/rfcs/2094-nll.html"><strong>非词法作用域生存期</strong>（Non-Lexical Lifetime，NLL）</a>，使得
生存期不再与作用域绑定．</p>
</div>
<h3 id="生存期的包含关系lifetime-inclusionb-a"><a class="header" href="#生存期的包含关系lifetime-inclusionb-a">生存期的包含关系（Lifetime Inclusion，<code>'b: 'a</code>）</a></h3>
<p>在Rust中，<code>'b: 'a</code>表示生存期<code>'b</code>比<code>'a</code>更长（或等长），这是因为通常情况下带更长生存期类型是带更短生存期类型的子类型<sup class="footnote-reference"><a href="#covar">4</a></sup>，如当<code>'b: 'a</code>
时，<code>&amp;'b T</code>是<code>&amp;'a T</code>的<a href="https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance"><strong>子类型</strong></a>
（Subtype），即<code>&amp;'b T: &amp;'a T</code>．</p>
<p>生存期的包含关系是一个<a href="https://en.wikipedia.org/wiki/Partially_ordered_set"><strong>偏序关系</strong></a>
（Partial Order Relationship），即满足</p>
<ul>
<li>自反性（Reflexive），对任意的<code>'a</code>都有：<code>'a: 'a</code>；</li>
<li>传递性（Transitive），若<code>'a: 'b</code>且<code>'b: 'c</code>那么有<code>'a: 'c</code>．</li>
<li>反对称性（Anti-Symmetric），若<code>'a: 'b</code>且<code>'b: 'a</code>那么<code>'a = 'b</code>.</li>
</ul>
<p>不同于<a href="https://en.wikipedia.org/wiki/Total_order"><strong>全序关系</strong></a>
（Total Order）的是，并非任意两个生存期都存在包含关系，如以下的<code>'a</code>与<code>'b</code>既不满足<code>'a: 'b</code>也不满足<code>'b: 'a</code>．</p>
<pre><code class="language-rust ignore">'a: { } // lifetime `'a`
'b: { } // lifetime `'b`
</code></pre>
<p>当我们提到生存期<code>'b</code>比<code>'a</code>更长时，一般有两层含义．如下列代码段所示</p>
<pre><code class="language-rust ignore">'b: { // `'b` alive
    'a: { // `'a`, `'b` alive
        // ...
    } // `'a` ends
} // `'a`, `'b` end
</code></pre>
<ul>
<li>若较短的生存期<code>'a</code>存活，那么较长的生存期<code>'b</code>也一定存活；</li>
<li>若较长的生存期<code>'b</code>结束，那么较短的生存期<code>'a</code>也一定结束．</li>
</ul>
<p>在\( \lambda_\textrm{Rust} \)中，生存期的包含关系略微有点复杂，但也与上述两层含义一一对应
\[
\begin{array}{ll}
\alpha \sqsubseteq \beta \mathrel{\mathop:}= \\
\quad [\alpha] \propto [\beta]
&amp; \text{拥有较短生存期} \alpha \text{的token时，可通过Accessor模式临时获取较长生存期} \beta \text{的token} \\
\quad \ast\, ([\dagger \beta] -\!\ast\, [\dagger \alpha])
&amp; \text{当较长的生存期} \beta \text{结束时，也可得知较短的生存期} \alpha \text{也一定结束}
\end{array}
\]
注意这里较短的生存期token是「更大」的资源．因为当生存期存活时，可以推断出任何比它长的生存期都存活，也即上述定义中的第一项，可以通过
<a href="02-logics.html#accessor%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E7%BB%8F%E5%A4%A7%E5%B9%85%E7%AE%80%E5%8C%96">Accessor资源访问模式</a>来获取任意一个比它更长的生存期的token．</p>
<div class="footnote-definition" id="covar"><sup class="footnote-definition-label">4</sup>
<p>这里指<a href="https://doc.rust-lang.org/reference/subtyping.html#variance"><strong>协变</strong>（Covariant）</a>类型中的生存期参数．</p>
</div>
<h3 id="静态生存期static"><a class="header" href="#静态生存期static">静态生存期（<code>'static</code>）</a></h3>
<p>在Rust语言中，有一个特殊的生存期<code>'static</code>，它比其他任何生存期都更长，即在整个程序中任意作用域（包括静态作用域）范围内都存活．</p>
<pre><code class="language-rust ignore">static STR: &amp;'static str = &quot;Hello, world!&quot;.
</code></pre>
<p>在\( \lambda_\textrm{Rust} \)中，以\(\varepsilon\)代指静态生存期，则有
\[
\begin{array}{ll}
\mathsf{True} -\!\ast\, [\varepsilon] &amp; \text{可任意获取生存期} \varepsilon \text{存活的token} \\
[\dagger \varepsilon] -\!\ast\, \mathsf{False} &amp; \text{生存期} \varepsilon \text{永不结束}
\end{array}
\]</p>
<h3 id="生存期token的拆分"><a class="header" href="#生存期token的拆分">生存期token的拆分</a></h3>
<p>由于生存期token不属于<a href="02-logics.html#%E6%B0%B8%E4%B9%85%E8%B5%84%E6%BA%90persistent">永久资源</a>，即不可复制，但很多时候生存期的token需要在多处使用
（如共属于同一作用域的多个引用类型），因此需要一种生存期token的复用方式．</p>
<p>Iris中通常使用有理拆分的方式，将一个完整的生存期token\([\kappa]\)，拆分成多个不完整的token，从而使得同一个生存期token可以在多处使用．</p>
<p>赋予每个token一个有理份额\(q\)，即\([\kappa]_q\)，其中\(q\)为不大于\(1\)的正有理数．当\(q = 1\)时，即\([\kappa]_1\)为完整
token；当\(q &lt; 1\)时，\([\kappa]_q\)为不完整token．拆分规则如下<sup class="footnote-reference"><a href="#ast">5</a></sup>：
\[
\forall \kappa. \forall q, q' \in \mathbb{Q}_{+}. q + q' \le 1 \implies [\kappa]_{q + q'} \ast\!-\!\ast\, [k]_q \ast [k]_{q'}
\]</p>
<p>相应地，前文提到的生存期的几个规则将变为：
\[
\mathsf{True} -\!\ast\, \exists \kappa. [\kappa]_1 \ast \big([\kappa]_1 -\!\ast\, [\dagger \kappa]\big) 
\]
即生存期的开始与结束仍然需要完整的token．令\( \mathbb{Q}_1 \mathrel{\mathop:}= \mathbb{Q} \cap (0, 1] \)，
\[
\begin{array}{ll}
\alpha \sqsubseteq \beta &amp; \mathrel{\mathop:}= \,
(\forall q \in \mathbb{Q}_1. [\alpha]_q) \propto (\forall q' \in \mathbb{Q}_1. [\beta]_{q'}) \\
&amp; \ast\, ([\dagger \beta] -\!\ast\, [\dagger \alpha])
\end{array}
\]
此时可使用不完整token，并且在Accessor资源访问模式中允许任意变换token的份额．</p>
<h2 id="共享所有权shared-ownership与不可变借用"><a class="header" href="#共享所有权shared-ownership与不可变借用">共享所有权（Shared Ownership）与不可变借用*</a></h2>
<p><img src="images/shared.png" alt="Shared Ownership" /></p>
<h3 id="a-t与类型的-textshr--predict"><a class="header" href="#a-t与类型的-textshr--predict"><code>&amp;'a T</code>与类型的\( \text{shr} \) Predict</a></h3>
<p><code>&amp;'a T</code>类型与<code>&amp;'a mut T</code>差别较大，\( \lambda_\textrm{Rust} \)引入了\( \text{shr} \) predict代表值的共享关系，
\( \&amp;_\mathbf{shr}^\kappa \tau \)类型的\( \text{own} \) predict可定义如下：
\[
\begin{array}{lll}
\left[\!\left[ \&amp;_\mathbf{shr}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell)
&amp; \text{在生存期} \kappa \text{存活的范围内，} \ell \text{共享了属于类型} \tau \text{的值}
\end{array}
\]</p>
<p>由于Rust中的<code>&amp;'a T: Copy</code>，因此\( \&amp;_\mathbf{shr}^\kappa \tau \)类型的\( \text{own} \) predict须是永久的，于是任意类型\(\tau\)的
\( \text{shr} \) predict都须是永久的，即
\[ \forall \tau, \kappa, \ell. [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \; \mathsf{Persistent} \]</p>
<p>此外，\( \text{shr} \) predict还须支持生存期的包含关系，有
\[
\forall \tau, \kappa, \kappa', \ell. \kappa' \sqsubseteq \kappa
\ast [\![ \tau ]\!].\!\text{shr}(\kappa, \ell)
-\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa', \ell)
\]
表明<code>&amp;'a T</code>关于<code>'a</code>协变，即当<code>'b: 'a</code>时，有<code>&amp;'b T: &amp;'a T</code>．</p>
<p>\( [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \)的实现非常复杂，因篇幅所限，此处不再赘述，有兴趣者可参阅<a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt论文</a>中的第四章：Lifetime logic．</p>
<h3 id="a-mut-t到a-t的隐式转换"><a class="header" href="#a-mut-t到a-t的隐式转换"><code>&amp;'a mut T</code>到<code>&amp;'a T</code>的隐式转换</a></h3>
<p>为了支持Rust中<code>&amp;'a mut T</code>到<code>&amp;'a T</code>的隐式转换，\( \lambda_\textrm{Rust} \)引入了下列规则：
\[
\forall \tau, \kappa, \ell, q \in \mathbb{Q}_1.
\&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big) 
\ast [k]_q -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \ast [\kappa]_q
\]
因此只要生存期\(\kappa\)存活，那么类型\( \&amp;_\mathbf{mut}^\kappa \tau \)可以转换为类型\( \&amp;_\mathbf{shr}^\kappa \tau \)，转换后生存期\(\kappa\)仍然存活．</p>
<div class="footnote-definition" id="ast"><sup class="footnote-definition-label">5</sup>
<p>\(P \ast\!-\!\ast Q\)为\( (P -\!\ast\, Q) \ast (Q -\!\ast\, P) \)的简写．</p>
</div>
<h2 id="小结"><a class="header" href="#小结">小结*</a></h2>
<p>\( \lambda_\textrm{Rust} \)中类型的语义模型到此结束．每个类型\(\tau\)有三个属性或predict
\[
Type \mathrel{\mathop:}= \left\lbrace \begin{array}{ll}
\text{size} : \mathbb{N} &amp; \text{属于类型} \tau \text{的值列表长度} \\
\text{own} : List(Val) \to iProp &amp; \text{类型} \tau \text{对持所有权的值的资源约束} \\
\text{shr} : Lft \times Loc \to iProp &amp; \text{类型} \tau \text{对共享值的约束} \\
\end{array} \right\rbrace
\]
其中\(List\)指列表，\(Loc\)指位置值，\(iProp\)指Iris资源．</p>
<p>但除此之外，类型的语义模型还要求满足以下条件
\[
SemType \mathrel{\mathop:}= \left\lbrace 
\tau \in Type \middle|
\begin{array}{ll}
\left( \forall \bar{v}. [\![ \tau ]\!].\!\text{own}(\bar{v}) -\!\ast\, |\bar{v}| = [\![ \tau ]\!].\!\text{size} \right) \; \land 
&amp; \text{size与own的一致性} \\
\left( \forall \kappa, \ell. [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \; \mathsf{Persistent} \right) \; \land 
&amp; \text{shr的永久性} \\
\left( \begin{array}{l}
\forall \kappa, \kappa', \ell. \kappa' \sqsubseteq \kappa \ast [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \\
\quad -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa', \ell) 
\end{array} \right) \land 
&amp; \text{shr的单调性} \\
\left( \begin{array}{l}
\forall \kappa, \ell, q \in \mathbb{Q}_1.
\&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big) \ast [k]_q \\
\quad -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \ast [\kappa]_q
\end{array} \right)
&amp; \text{own可转换到shr}
\end{array} \right\rbrace
\]
以上便是\( \lambda_\textrm{Rust} \)类型语义模型的全部定义．在此基础上，若欲支持多线程，可在\(\text{own}\)与\(\text{shr}\) predicts中新增线程ID参数．
涉及多线程的借用语义将更加复杂，在此不再赘述，有兴趣者可自行参阅<a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt论文</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2023-06-rustbelt/02-logics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../2023-06-rustbelt/04-rc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2023-06-rustbelt/02-logics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../2023-06-rustbelt/04-rc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="https://utteranc.es/client.js"
                repo="frank-king/rustblog-zh"
                issue-term="title"
                theme="github-dark"
                crossorigin="anonymous"
                async>
        </script>

    </body>
</html>
