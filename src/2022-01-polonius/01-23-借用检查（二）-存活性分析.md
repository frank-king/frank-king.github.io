# 存活性分析
写于2022年1月23日。

存活性分析主要计算出在MIR的各个位置处有哪些借用源（Origin）存活，用于下一阶段的借用分析。

## 输入

#### 1. 普通变量的定义、使用、丢弃情况。

```prolog
.decl var_defined_at(Variable, Point)
.decl var_used_at   (Variable, Point)
.decl var_dropped_at(Variable, Point)

.input var_defined_at
.input var_used_at
.input var_dropped_at
```

#### 2. 对于引用变量而言，需要输入变量所关联的借用源。
如下
```rust,ignore
let a: i32 = 0;
let b: &'b i32 = &a;
```
其中`b`变量将关联到借用源`'b`。

另外还有丢弃时借用源（TODO）。

```prolog
.decl drop_of_var_derefs_origin(Variable, Origin)
.decl use_of_var_derefs_origin (Variable, Origin)

.input drop_of_var_derefs_origin
.input use_of_var_derefs_origin 
```
## 推导

#### 1. 变量存活情况

对于每一个变量，从每个 **使用** 的位置处，沿CFG **逆边** 向前追溯到变量 **定义** 处，都视为存活。

```prolog
var_live_on_entry(Variable, Point) :-
    var_used_at(Variable, Point).

var_live_on_entry(Variable, SourcePoint) :-
    var_live_on_entry(Variable, Targetpoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined(Variable, SourcePoint).
```

#### 2. 将变量的半初始化状态沿CFG传递。

```prolog
var_maybe_partly_initialized_on_entry(Variable, TargetPoint) :-
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint).
```

#### 3. 变量含丢弃的存活情况

对于每一个变量，从每个 **丢弃** 或 **半初始化** 的位置处开始，沿CFG **逆边** 向前追溯到变量 **定义** 处，都视为 **含丢弃存活**（drop-live）。

```prolog
var_drop_live_on_entry(Variable, Point) :-
    var_dropped_at(Variable, Point),
    var_maybe_partly_initialized_on_entry(Variable, Point).
```

```prolog
var_drop_live_on_entry(Variable, SourcePoint) :-
    var_drop_live_on_entry(Variable, TargetPoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined_at(Variable SourcePoint),
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint).
```

#### 4. 借用源存活状态

对每处的存活引用变量，都标记其关联的借用源为存活。

```prolog
origin_live_on_entry(Origin, Point) :-
    var_live_on_entry(Variable, Point),
    use_of_var_derefs_origin(Variable, Origin).
```

同样地，对含丢弃存活的引用变量，也标记其相关联的丢弃时借用源为存活。

```prolog
origin_live_on_entry(Origin, Point) :-
    var_drop_live_on_entry(Variable, Point),
    drop_of_var_derefs_origin(Variable, Origin).
```

## 思考

#### 1. 既然已经有基于路径的一些输入事实（如`path_assigned_at`、`path_accessed_at`、`path_moved_at`等），并且也有`path_is_var`能与变量对应起来，为什么还需要基于变量的输入事实呢（如`var_used_at`、`var_dropped_at`、`var_defined_at`等）？

(1) `path_assigned_at`与`var_defined_at`

- `path_assigned_at`与`var_defined_at`的最大区别是：
    - 在MIR的每一条赋值语句中，`var_defined_at`一定发生在当前语句中间（`Mid`）；
    - 而`path_assigned_at`可能发生在当前赋值语句中间（`Mid`），或下一条语句之前（`Start`），
        - 若当前语句不需要`unwind`，则`path_assigned_at`在当前赋值语句中间；
        - 若当前语句需要`unwind`，则`path_assigned_at`在执行成功的分支中下一条语句之前。
- `var_defined_at`还包含`StorageLive`与`StorageDead`信息，及变量被赋值的信息。
- `path_assigned_at`还包含进入函数时，对入参的初始化赋值。

(2) `path_accessed_at`与`var_used_at`

`var_userd_at`等于`path_accessed_at`加上返回值的访问信息。

(3) `path_moved_at`与`var_dropped_at`

`path_moved_at`只能追踪到其赋值与移动。而变量在超出其作用域后，还会被丢弃，无法通过路径的移动信息推导出变量的丢弃信息。

#### 2. 为什么`var_defined_at`中包含`StorageLive`和`StorageDead`？

TODO

#### 3. 为什么要区分`drop_of_var_derefs_origin`与`use_of_var_derefs_origin`？

TODO

#### 4. 为什么`var_drop_live_on_entry`要包含`var_maybe_partly_initialized_on_entry`的信息？

TODO
