<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust中文博客</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html">序言</a></li><li class="chapter-item expanded affix "><li class="part-title">2023-06</li><li class="chapter-item expanded "><a href="2023-06-rustbelt/00.html">RustBelt——Rust语言的形式化语义模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2023-06-rustbelt/01-background.html">（零）背景</a></li><li class="chapter-item expanded "><a href="2023-06-rustbelt/02-logics.html">（一）形式化逻辑基础</a></li><li class="chapter-item expanded "><a href="2023-06-rustbelt/03-rust-semantics.html">（二）Rust语义模型</a></li><li class="chapter-item expanded "><a href="2023-06-rustbelt/04-rc.html">（三）示例Rc</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">2022-01</li><li class="chapter-item expanded "><a href="2022-01-polonius/00.html">Polonius学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022-01-polonius/01-21-借用检查（零）-原子式与输入.html">（零）原子式与输入</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/01-21-借用检查（一）-初始化分析.html">（一）初始化分析</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/01-23-借用检查（二）-存活性分析.html">（二）存活性分析</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/02-08-借用检查（三）-借债分析.html">（三）借债分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022-01-polonius/02-08-借用检查（三）-借债分析-原始规则.html">(1) 原始规则</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/02-19-借用检查（三）-借债分析-位置无关规则.html">(2) 位置无关规则</a></li><li class="chapter-item expanded "><div>(3) 优化规则</div></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">2021-09</li><li class="chapter-item expanded "><a href="2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li><li class="chapter-item expanded affix "><li class="part-title">2021-01</li><li class="chapter-item expanded "><a href="2021-01-proc-macro/00.html">Rust过程宏入门系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-06-过程宏（一）-过程宏简介.html">（一）过程宏简介</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html">（二）初探派生宏</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-10-过程宏（三）-实现简易派生宏.html">（三）实现简易派生宏</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html">（四）遍历结构体字段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust中文博客</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/frank-king/rustblog-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="序言"><a class="header" href="#序言">序言</a></h1>
<p>本博客将不定期更新一些Rust相关的学习心得与开发体验，更新频率可能不会很高。文章按月组织，例序排列。</p>
<h1 id="2023-06"><a class="header" href="#2023-06">2023-06</a></h1>
<ul>
<li><a href="2023-06-rustbelt/00.html">RustBelt——Rust语言的形式化语义模型</a>
<ul>
<li><a href="2023-06-rustbelt/01-background.html">（零）背景</a></li>
<li><a href="2023-06-rustbelt/02-logics.html">（一）形式化逻辑基础</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html">（二）Rust语义模型</a></li>
<li><a href="2023-06-rustbelt/04-rc.html">（三）示例<code>Rc</code></a></li>
</ul>
</li>
</ul>
<h1 id="2022-01"><a class="header" href="#2022-01">2022-01</a></h1>
<ul>
<li><a href="2022-01-polonius/00.html">Polonius学习笔记</a>
<ul>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E9%9B%B6%EF%BC%89-%E5%8E%9F%E5%AD%90%E5%BC%8F%E4%B8%8E%E8%BE%93%E5%85%A5.html">（零）原子式与输入</a></li>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">（一）初始化分析</a></li>
<li><a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html">（二）存活性分析</a></li>
<li><a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90.html">（三）借债分析</a>
<ul>
<li><a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html">(1) 原始规则</a></li>
<li><a href="2022-01-polonius/02-19-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E8%A7%84%E5%88%99.html">(2) 位置无关规则</a></li>
<li><a href="">(3) 优化规则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2021-09"><a class="header" href="#2021-09">2021-09</a></h1>
<ul>
<li><a href="2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li>
</ul>
<h1 id="2021-01"><a class="header" href="#2021-01">2021-01</a></h1>
<ul>
<li><a href="2021-01-proc-macro/00.html">Rust过程宏入门系列</a>
<ul>
<li><a href="2021-01-proc-macro/01-06-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E8%BF%87%E7%A8%8B%E5%AE%8F%E7%AE%80%E4%BB%8B.html">（一）过程宏简介</a></li>
<li><a href="2021-01-proc-macro/01-07-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%88%9D%E6%8E%A2%E6%B4%BE%E7%94%9F%E5%AE%8F.html">（二）初探派生宏</a></li>
<li><a href="2021-01-proc-macro/01-10-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%B4%BE%E7%94%9F%E5%AE%8F.html">（三）实现简易派生宏</a></li>
<li><a href="2021-01-proc-macro/01-16-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5.html">（四）遍历结构体字段</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustbeltrust语言的形式化语义模型"><a class="header" href="#rustbeltrust语言的形式化语义模型">RustBelt——Rust语言的形式化语义模型</a></h1>
<p>本文根据Rust China Conf 2023大会上的议题《<a href="https://www.bilibili.com/video/BV17F411o7kT/">RustBelt - Rust的形式化语义模型</a>》转录而成，转录于2023年6月23日．</p>
<p>其中，带*号的部分在会中因时间关系，未提及．</p>
<p><img src="2023-06-rustbelt/images/outline.png" alt="Outline" /></p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="2023-06-rustbelt/01-background.html">背景</a>
<ul>
<li><a href="2023-06-rustbelt/01-background.html#rustbelt%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B">RustBelt项目简介</a></li>
<li><a href="2023-06-rustbelt/01-background.html#rust%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%A7%88">Rust类型一览</a></li>
</ul>
</li>
<li><a href="2023-06-rustbelt/02-logics.html">形式化逻辑基础</a>
<ul>
<li><a href="2023-06-rustbelt/02-logics.html#%E9%9C%8D%E5%B0%94%E9%80%BB%E8%BE%91hoare-logic">霍尔逻辑（Hoare Logic）</a></li>
<li><a href="2023-06-rustbelt/02-logics.html#%E5%88%86%E7%A6%BB%E9%80%BB%E8%BE%91separation-logic-iris">分离逻辑（Separation Logic (Iris)）</a></li>
</ul>
</li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html">Rust语义模型</a>
<ul>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#-lambda_textrmrust-%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86">\( \lambda_\textrm{Rust} \)的类型系统（部分）</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#%E7%B1%BB%E5%9E%8B%E7%9A%84-textown--predict">类型的\( \text{own} \) Predict</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#%E7%B1%BB%E5%9E%8B%E7%9A%84-textsize-%E5%B1%9E%E6%80%A7">类型的\( \text{size} \)属性*</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#%E7%8B%AC%E5%8D%A0%E6%89%80%E6%9C%89%E6%9D%83exclusive-ownership%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">独占所有权（Exclusive Ownership）与可变借用</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#%E7%94%9F%E5%AD%98%E6%9C%9Flifetime">生存期（Lifetime）*</a></li>
<li><a href="2023-06-rustbelt/03-rust-semantics.html#%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%83shared-ownership%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">共享所有权（Shared Ownership）与不可变借用*</a></li>
</ul>
</li>
<li><a href="2023-06-rustbelt/04-rc.html">示例<code>Rc</code></a>
<ul>
<li><a href="2023-06-rustbelt/04-rc.html#rc%E7%9A%84%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B"><code>Rc</code>的语义模型</a></li>
<li><a href="2023-06-rustbelt/04-rc.html#rc%E7%9A%84%E5%AE%9E%E7%8E%B0"><code>Rc</code>的实现</a></li>
</ul>
</li>
</ul>
<h2 id="现场问答环节"><a class="header" href="#现场问答环节">现场问答环节</a></h2>
<h3 id="问题rustbelt可否在实际工程项目中用于证明代码的正确性"><a class="header" href="#问题rustbelt可否在实际工程项目中用于证明代码的正确性">问题：RustBelt可否在实际工程项目中用于证明代码的正确性？</a></h3>
<p><strong>回答</strong>：可以但不建议．</p>
<p>RustBelt的主要目标是标准库，因为标准库中存在大量的<code>unsafe</code>代码，只有通过Iris定义的系列语法及语义规则，才能证明其健全性．</p>
<p>由于在RustBelt已经证明所有的\( \lambda_\text{Rust} \)的程序只要通过类型检查，也能满足语义上的约束，因此如果要证明某个库的实现是健全的，
需将其Rust MIR代码翻译为\( \lambda_\text{Rust} \)然后证明能通过类型检查，则该库的实现可以认为是健全的．<sup class="footnote-reference"><a href="#sound">1</a></sup></p>
<p>Rust社区中还有两个可用于工程中的形式化验证工具，<a href="https://model-checking.github.io/kani/getting-started.html">Kani</a>与
<a href="https://github.com/xldenis/creusot">Creusot</a>．与RustBelt不同的是（笔者本人的理解）：</p>
<ul>
<li>Kani与Creusot主要用于验证程序的逻辑正确性；而RustBelt主要关注内存安全性与线程安全性，三者应用场景不同．</li>
<li>Kani依赖Rust编译器及其标准库本身的正确性；而RustBelt无此假设，可用于验证包含标准库在内的所有\( \lambda_\text{Rust} \)程序的正确性；
Creusot的实现经过了<a href="https://dl.acm.org/doi/10.1145/3519939.3523704">RustHornBelt</a>的形式化验证，因此可认为不依赖Rust本身的正确性．</li>
<li>Kani支持部分<code>unsafe</code>代码的验证（仅限于能通过逻辑正确性检查出来的错误，如数组下标越界等；
Creusot目前<a href="https://github.com/xldenis/creusot/issues/36">不支持<code>unsafe</code>代码验证</a>；
RustBelt由于代码都基于MIR转写，因此支持<code>unsafe</code>代码．</li>
<li>Kani目前<a href="https://github.com/model-checking/kani/issues/313">不支持并发代码验证</a>；Creusot未知；
RustBelt由于支持线程安全检查，因而也支持并发代码验证．</li>
</ul>
<p>可根据不同的场景选用不同的形式化验证工具．</p>
<div class="footnote-definition" id="sound"><sup class="footnote-definition-label">1</sup>
<p>实际上离程序真正的正确性还有一定距离，因为从Rust MIR到\( \lambda_\text{Rust} \)会丢失一些实现细节．</p>
</div>
<h4 id="kani简介"><a class="header" href="#kani简介">Kani简介*</a></h4>
<p>Kani使用<a href="https://en.wikipedia.org/wiki/Model_checking"><strong>模型检查</strong></a>（Model Checking）方法，需要手动编写类似单元测试的验证用例，Kani求解器
会遍历状态空间树以检查验证用例是否正确．若不正确，将报告反例分支．</p>
<p>如文档中的示例代码所示</p>
<pre><code class="language-rust ignore">fn estimate_size(x: u32) -&gt; u32 {
    if x &lt; 256 {
        if x &lt; 128 {
            return 1;
        } else {
            return 3;
        }
    } else if x &lt; 1024 {
        if x &gt; 1022 {
            panic!(&quot;Oh no, a failing corner case!&quot;);
        } else {
            return 5;
        }
    } else {
        if x &lt; 2048 {
            return 7;
        } else {
            return 9;
        }
    }
}
</code></pre>
<p>验证用例的写法如下</p>
<pre><code class="language-rust ignore">#[cfg(kani)]
#[kani::proof]
fn check_estimate_size() {
    let x: u32 = kani::any();
    estimate_size(x);
}
</code></pre>
<p>Kani求解器将从<code>kani::any::&lt;u32&gt;()</code>的任意状态开始，遍历求解<code>estimate_size</code>函数并最终找到反例分支</p>
<pre><code class="language-bash">$ cargo kani
[...]
Runtime decision procedure: 0.00116886s

RESULTS:
Check 3: estimate_size.assertion.1
         - Status: FAILURE
         - Description: &quot;Oh no, a failing corner case!&quot;
[...]
VERIFICATION:- FAILED
</code></pre>
<h4 id="creusot简介"><a class="header" href="#creusot简介">Creusot简介*</a></h4>
<p>Creusot同样基于模型检查方法，但与Kani有所不同的是，可直接在程序中，为函数或特质接口，以过程宏的方式标注类似于霍尔逻辑的前置条件及后置条件．
Creusot会将带有前置条件与后置条件的代码翻译为WhyML，然后调用why3求解器验证函数实现的正确性．</p>
<p>如以下代码为求解<code>1 + 2 + ... + n</code>的值．</p>
<pre><code class="language-rust ignore">use creusot_contracts::*;

#[requires(n@ &lt; 1000)]
#[ensures(result@ == n@ * (n@ + 1) / 2)]
pub fn sum_first_n(n: u32) -&gt; u32 {
    let mut sum = 0;
    #[invariant(sum@ == produced.len() * (produced.len() + 1) / 2)]
    for i in 1..=n {
        sum += i;
    }
    sum
}
</code></pre>
<p>其中<code>#[requres(n@ &lt; 1000)</code>为函数的前置条件（<code>n@</code>表示<code>n</code>在函数运行前的值），<code>#[ensures(result@ == n@ * (n@ + 1) / 2)]</code>为函数的后置条件．</p>
<p>特别地，程序中的<code>for</code>循环需要专门指定循环不变量（Invariant），即每一轮循环结束时都需要满足的条件．</p>
<p>代码中的<code>#[invariant(sum@ == produced.len() * (produced.len() + 1) / 2)]</code>表示每一轮循环结束后，<code>sum</code>的值都为前<code>i</code>项的和．</p>
<h3 id="问题-lambda_textrust-中的-mathbfint-类型为任意长度的整型是否可以使用固定字长的类型例如i8"><a class="header" href="#问题-lambda_textrust-中的-mathbfint-类型为任意长度的整型是否可以使用固定字长的类型例如i8">问题：\( \lambda_\text{Rust} \)中的\( \mathbf{int} \)类型为任意长度的整型，是否可以使用固定字长的类型（例如<code>i8</code>）？</a></h3>
<p><strong>回答</strong>：可以．</p>
<p>仿照\( \mathbf{int} \)的定义，可以类似地定义\( \mathbf{int}8 \)如下
\[
\begin{array}{ll}
[\![ \mathbf{int}8 ]\!].\!\text{size} &amp; \mathrel{\mathop:}= 1 \\
[\![ \mathbf{int}8 ]\!].\!\text{own}(\bar{v}) &amp;
\mathrel{\mathop:}= \; \exists z \in \mathbb{Z} \cap \left[ -2^7, 2^7 \right). \bar{v} = [z]
\end{array}
\]
即为\( \mathbf{int} \)类型增加\( \left[ -2^7, 2^7 \right) \)的约束，再为\( \mathbf{int}8 \)类型实现相应的算术计算如
\[
\begin{array}{l}
\text{add_i8} : \mathbf{int}8 \times \mathbf{int}8 \to \mathbf{int}8 \mathrel{\mathop:}= 
\lambda (a, b). \; (a + b + 2^8) \!\! \mod \! 2^7 - 2^7 \\ 
\text{sub_i8} : \mathbf{int}8 \times \mathbf{int}8 \to \mathbf{int}8 \mathrel{\mathop:}=
\lambda (a, b). \; (a - b + 2^8) \!\! \mod \! 2^7 - 2^7
\end{array}
\]
即可．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="背景"><a class="header" href="#背景">背景</a></h1>
<h2 id="rustbelt项目简介"><a class="header" href="#rustbelt项目简介">RustBelt项目简介</a></h2>
<p><img src="2023-06-rustbelt/images/rustbelt-project.png" alt="RustBelt项目" /></p>
<p>众所周知，Rust是一门内存安全的语言，只要通过编译，便能避免数组下标越界、Use After
Free、数据竞争等<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">未定义行为</a>．
但同时，Rust也是一门不安全的语言，使用<code>unsafe</code>关键字时，
上述内存安全问题都需要自行保证．</p>
<p>而Rust标准库中，使用了大量的<code>unsafe</code>功能，因此Rust语言安全与否，
与标准库实现是否<strong>健全</strong>（Sound）——任意调用<code>pub</code>接口（非<code>unsafe</code>）都不能触发<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html"><strong>未定义行为</strong></a>
（Undefined Behavior）——密切相关．</p>
<p><a href="https://plv.mpi-sws.org/rustbelt/">RustBelt</a>项目正是在如此背景下提出，旨在以形式化的方式验证标准库中常用基础类型实现的正确性．</p>
<p><img src="2023-06-rustbelt/images/ralf-jung.png" alt="Ralf Jung" /></p>
<p>RustBelt项目的主要贡献者之一——<a href="https://research.ralfj.de/">Ralf Jung教授</a>
是瑞士苏黎世联邦理工大学（ETH Zürich）的助理教授．其中最主要的论文是2018年发表在POPL杂志上的
<a href="https://plv.mpi-sws.org/rustbelt/popl18/">《RustBelt: Securing the Foundations of the Rust Programming Language》</a>，
也是Ralf Jung教授博士论文<a href="https://research.ralfj.de/thesis.html">《Understanding and Evolving the Rust Programming Language》</a>
中的第二章．该博士论文荣获多个奖项．</p>
<p><img src="2023-06-rustbelt/images/iris.png" alt="Iris" /></p>
<p>RustBelt定义了\( \lambda_\textrm{Rust} \)-calculus，\( \lambda_\textrm{Rust} \)
完全经机器证明，基于<a href="https://iris-project.org/">Iris</a>高阶并发分离逻辑开发；
而Iris基于<a href="https://coq.inria.fr/">Coq Proof Assistant</a>开发．</p>
<h2 id="rust类型一览"><a class="header" href="#rust类型一览">Rust类型一览</a></h2>
<p><img src="2023-06-rustbelt/images/rust-types.png" alt="Rust Types" /></p>
<p>Rust语言的类型具有所有权语义：值类型可以被任意创建、移动、或释放，但每个值最多只能被「使用」
一次——这也是<a href="https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems"><strong>仿射类型系统</strong></a>（Affine Type Systems）
的典型特征．但若只有值类型，由于有只能使用一次的限制，那么很难编写具有实际意义的程序．</p>
<p>所幸Rust语言中也提供了<a href="https://doc.rust-lang.org/std/primitive.reference.html"><strong>引用类型</strong></a>（Reference），
分为<strong>可变引用</strong>（Mutable Refernece，<code>&amp;'a mut T</code>）与<strong>不可变引用</strong>（Immutable Reference，<code>&amp;'a T</code>，也称共享引用，Shared Reference）．
引用类型可以由值类型<code>T</code><strong>借用</strong>（Borrow）而得，<strong>可变借用</strong>（Mutable Borrow）得到可变引用，<strong>不可变借用</strong>（Immutable Borrow）得到不可变引用．
引用类型也可以<strong>再借用</strong>（Reborrow）以得到另一个<a href="2023-06-rustbelt/03-rust-semantics.html#%E7%94%9F%E5%AD%98%E6%9C%9Flifetime"><strong>生存期</strong></a>
（Lifetime）更小的引用类型．可变引用也可以<a href="https://doc.rust-lang.org/reference/type-coercions.html#coercion-types"><strong>隐式转换</strong></a>（Coercion）到不可变引用．</p>
<p>从独占/共享的维度来看，值类型<code>T</code>与可变引用<code>&amp;mut T</code>属于独占类型，即同一代码位置，对同一个值，
只能有<strong>唯一</strong>、<strong>有效</strong>的<strong>读写</strong>权限；而不可变引用<code>&amp;T</code>属于共享类型，即同一代码位置，对同一个值，
允许有<strong>多个</strong>有效的<strong>只读</strong>权限．
独占访问与共享访问是互斥的，二者只有其中一个有效．</p>
<p>从所有/借用的维度来看，值类型<code>T</code>持有值的所有权，而可变引用<code>&amp;mut T</code>与不可变引用<code>&amp;T</code>
只有借用权．持所有权者，拥有完整的<strong>读</strong>、<strong>写</strong>、<strong>移动</strong>、<strong>释放</strong>权限；而持借用权者，
只有<strong>读写</strong>（可变引用）或<strong>只读</strong>（不可变引用）权限．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="形式化逻辑基础"><a class="header" href="#形式化逻辑基础">形式化逻辑基础</a></h1>
<p>下面将介绍形式化逻辑中常用的两个基础概念．</p>
<h2 id="霍尔逻辑hoare-logic"><a class="header" href="#霍尔逻辑hoare-logic">霍尔逻辑（Hoare Logic）</a></h2>
<p><img src="2023-06-rustbelt/images/hoare.png" alt="Hoare Logic" /></p>
<p><a href="https://en.wikipedia.org/wiki/Hoare_logic">霍尔逻辑</a>中的命题\( \lbrace P \rbrace \; C \; \lbrace Q \rbrace \)是指，
对于某一段程序\( C \)，在前置条件\( P \)成立的情况下，若正常执行并停机，那么应当满足后置条件\( Q \)．</p>
<p>霍尔逻辑与程序开发过程中的单元测试的概念类似．
若以单元测试来类比，程序\( C \)相当于单元测试中的被测函数；
前置条件\( P \)相当于单元测试中的输入参数；后置条件\( Q \)相当于单元测试中的断言．</p>
<p><img src="2023-06-rustbelt/images/hoare-example.png" alt="Hoare Logic Examples" /></p>
<p>霍尔逻辑示例:</p>
<ul>
<li>\[ \lbrace \mathsf{True} \rbrace \; \mathbf{let} \, x = 10 \; \lbrace x = 10 \rbrace \]
表示程序\( \; \mathbf{let} \, x = 10 \)无需任何前置条件，在运行结束后得到后置条件\( x = 10 \)．</li>
<li>\[ \lbrace x = 3 \rbrace \; x \,+\!= 1 \; \lbrace x = 4 \rbrace \]
表示程序\( x \, + \! = 1 \) 在\( x = 3 \)的前置条件下，运行结束后会得到后置条件\( x = 4 \)．</li>
<li>\[ \lbrace \mathsf{True} \rbrace \; \mathbf{loop} \, \lbrace \! \rbrace \; \lbrace \mathsf{False} \rbrace \]
表示程序\( \mathbf{loop} \, \lbrace \! \rbrace \)无需任何前置条件，但永不停机（假设它真的停机了，那么会得到一个假命题
\( \mathsf{False} \)即为其后置条件）．</li>
</ul>
<h2 id="分离逻辑separation-logic-iris"><a class="header" href="#分离逻辑separation-logic-iris">分离逻辑（Separation Logic (Iris)）</a></h2>
<p><img src="2023-06-rustbelt/images/sep-logic.png" alt="Separation Logic" /></p>
<p><a href="https://en.wikipedia.org/wiki/Separation_logic">分离逻辑</a>可看作霍尔逻辑的扩展，用以表达内存中<strong>独占</strong>（Ownership）与
<strong>不交</strong>（Disjointness）的两个性质．</p>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>命题\( x \mapsto v \)表示内存地址\( x \)唯一地指向了值\( v \)．</p>
<h3 id="disjointness"><a class="header" href="#disjointness">Disjointness</a></h3>
<p>命题\( P \ast Q \)表达了\( P \)与\( Q \)在内存空间上不相交．例如给定\( (x \mapsto v) \ast (y \mapsto w) \)，
则知\( x \ne y \)，因为\( x \)与\( y \)不能指代同一内存地址（not alias）．</p>
<p><img src="2023-06-rustbelt/images/sep-logic-explanations.png" alt="Separation Logic Explanations" /></p>
<p>\( \ast \)与\( \land \)的区别:</p>
<ul>
<li>\[ (x \mapsto v) \land (x \mapsto w) \implies v = w \]
资源是唯一的，因此仅存在唯一的值\(v\)使得\(x \mapsto v\)．</li>
<li>\[ (x \mapsto v) \ast (x \mapsto v) \implies \mathsf{False} \]
资源是不可复制的，因此即使是同一个值\(v\)，也不能同时存在两份相同的资源\(x \mapsto v\)．</li>
<li>\[ (x = 1) \ast (y = 2) \iff (x = 1) \land (y = 2) \]
对于<strong>非资源</strong>或者<a href="2023-06-rustbelt/02-logics.html#%E6%B0%B8%E4%B9%85%E8%B5%84%E6%BA%90persistent"><strong>永久资源</strong></a>，\( \ast \)与\( \land \)是等价的．</li>
</ul>
<h3 id="magic-wand"><a class="header" href="#magic-wand">Magic Wand</a></h3>
<p>命题\( P -\!\ast\, Q \)表示若消耗掉资源\( P \)则可获得资源\( Q \)．它与逻辑命题中「蕴含（Implies，\( \Rightarrow \)）」
的概念较为相似，如\( P \ast (P -\! \ast \, Q) \vdash Q \)之于\( P \land (P \Rightarrow Q) \vdash Q \)．</p>
<p>注意此处的资源\(P\)不必包含在资源\(Q\)中．</p>
<h3 id="accessor资源访问模式经大幅简化"><a class="header" href="#accessor资源访问模式经大幅简化">Accessor资源访问模式（经大幅简化）*</a></h3>
<p><img src="2023-06-rustbelt/images/accessor.png" alt="Accessor" /></p>
<p>命题\( Q \propto P \, \mathrel{\mathop:}= \, Q -\!\ast\, \big( P \ast (P -\!\ast\, Q) \big)\)表示：在较大的资源\(Q\)中，
可以临时取出包含于\(Q\)的较小资源\(P\)，待\(P\)使用结束后，归还\(P\)则可重新获得原资源\(Q\)．</p>
<p>通常，资源\(Q\)都完全包含资源\(P\)．Accessor是一种访问资源的模式，当某一较大资源不便于直接拆分为两个较小的资源以\(\ast\)相连的形式时，
比较适合使用Accessor模式．</p>
<h3 id="永久资源persistent"><a class="header" href="#永久资源persistent">永久资源（Persistent）*</a></h3>
<p><img src="2023-06-rustbelt/images/persistent.png" alt="Persistent" /></p>
<p>命题\( P \; \mathsf{Persistent} \, \mathrel{\mathop:}= \, P -\!\ast\, P \ast P \)表示资源\(P\)永不耗尽，可任意复制．永久资源又称
<strong>知识（Knowledge)</strong> 或<strong>信息（Information)</strong>．如\(1 + 1 = 2\)，\( x = 1 \implies x + 1 = 2 \)，
\( \lbrace \mathsf{True} \rbrace \; \mathbf{let} \, x = 10 \; \lbrace x = 10 \rbrace \) 等．注意霍尔逻辑作为复合命题，也属于永久资源．</p>
<hr />
<p><img src="2023-06-rustbelt/images/sep-logic-examples.png" alt="Separation Logic Examples" /></p>
<p>分离逻辑的示例:</p>
<ul>
<li>\[ \lbrace \mathsf{True} \rbrace \; \mathbf{let} \, x = \text{Box::new}(1) \; \lbrace x \mapsto 1 \rbrace \]
表示程序\( x = \textrm{Box::new}(1) \)无需任何前置条件，在运行结束后获得资源\( x \mapsto 1 \)<sup class="footnote-reference"><a href="#dealloc">1</a></sup>．这里\( \mapsto \)的独占语义
与Rust中<code>Box</code>类型的语义一致．</li>
<li>\[ \big\lbrace (x \mapsto 1) \ast (y \mapsto 1) \big\rbrace \; {\mbox*} x \,+\!= {\mbox*} y \; 
\big\lbrace (x \mapsto 2) \ast (y \mapsto 1) \big\rbrace \]
表示程序\( {\mbox*} x \,+\!= {\mbox*} y \)在前置条件\( \big\lbrace (x \mapsto 1) \ast (y \mapsto 1) \big\rbrace \)下，
运行结束后将得到\( \big\lbrace (x \mapsto 2) \ast (y \mapsto 1) \big\rbrace \)．注意 \( (x \mapsto 1) \ast (y \mapsto 1) \) 
表明\(x\)与\(y\)的地址不可能相同，与Rust代码
<pre><code class="language-rust ignore">fn add(x: &amp;mut i32, y: &amp;i32) {
    *x += *y;
}
</code></pre>
的语义一致．</li>
<li>\[ \lbrace x \mapsto - \rbrace \; \text{drop}(x) \; \lbrace \mathsf{True} \rbrace \]
表示程序\( \text{drop}(x) \)在\( \lbrace x \mapsto - \rbrace \)的前置条件下，运行结束后将消耗掉该资源．其中\( \lbrace x \mapsto - 
\rbrace \)表示不关心地址\(x\)具体指向什么值．</li>
</ul>
<div class="footnote-definition" id="dealloc"><sup class="footnote-definition-label">1</sup>
<p>此处省略了内存释放的部分．</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust语义模型"><a class="header" href="#rust语义模型">Rust语义模型</a></h1>
<h2 id="-lambda_textrmrust-的类型系统部分1"><a class="header" href="#-lambda_textrmrust-的类型系统部分1">\( \lambda_\textrm{Rust} \)的类型系统（部分）<sup class="footnote-reference"><a href="#types">1</a></sup></a></h2>
<p><img src="2023-06-rustbelt/images/type-system.png" alt="Type System" /></p>
<p>\[
\begin{array}{lll}
\text{值}     &amp; \text{Val}  &amp; \ni v \mathrel{\mathop:\!\!:}= \mathbf{false} \; | \; \mathbf{true} \; | \; z \; | \; \ell \; | \cdots \\
\text{生存期} &amp; \text{Lft}  &amp; \ni \kappa \mathrel{\mathop:\!\!:}= \alpha \; | \; \mathbf{static} \\
\text{可变性} &amp; \text{Mod}  &amp; \ni \mu    \mathrel{\mathop:\!\!:}= \mathbf{mut} \; | \; \mathbf{shr} \\
\text{类型}   &amp; \text{Type} &amp; \ni \tau   \mathrel{\mathop:\!\!:}= T \; | \; \mathbf{bool} \; | \; \mathbf{int} \\
&amp;&amp; \quad | \; \mathbf{own} \, T \; | \; \&amp;_\mu^\kappa T \\
&amp;&amp; \quad | \; \prod \bar{\tau} \; | \; \sum \bar{\tau} \; | \cdots
\end{array}
\]</p>
<p>常用的Rust类型与\( \lambda_\textrm{Rust} \)类型的对照关系如下表所示：</p>
<table><thead><tr><th>\( \lambda_\textrm{Rust} \)类型</th><th>Rust类型</th></tr></thead><tbody>
<tr><td>\( \mathbf{bool} \; | \; \mathbf{int} \)</td><td><code>bool</code> | <code>BigInt</code></td></tr>
<tr><td>\( \mathbf{own} \, T \)</td><td><code>Box&lt;T&gt;</code></td></tr>
<tr><td>\( \&amp;_{\mathbf{mut}}^\alpha T \; | \; \&amp;_{\mathbf{shr}}^\alpha T \)</td><td><code>&amp;'a mut T</code> | <code>&amp;'a T</code></td></tr>
<tr><td>\( \tau_1 \times \tau_2 \; | \; \prod [] \)</td><td><code>(T1, T2)</code> | <code>()</code></td></tr>
<tr><td>\( \tau_1 + \tau_2 \; | \; \sum [] \)</td><td><code>enum Type { A(T1), B(T2) }</code> | <code>enum Type {}</code> 或 <code>!</code></td></tr>
<tr><td>\( \prod [] + \tau \)</td><td><code>Option&lt;T&gt;</code></td></tr>
</tbody></table>
<p>其中：</p>
<ul>
<li>\( \lambda_\textrm{Rust} \)的\( \mathbf{int} \)类型为忽略机器字长的任意大小的整型；</li>
<li>\( \lambda_\textrm{Rust} \)的<strong>积类型</strong>（Product Type，\( \prod \bar{\tau} \)）相当于Rust的<strong>元组</strong>（Tuple）或<strong>结构体</strong>（Struct）类型；</li>
<li>\( \lambda_\textrm{Rust} \)的<strong>和类型</strong>（Sum Type，\( \sum \bar{\tau} \)）相当于Rust的<strong>枚举</strong>（Enum）类型；</li>
<li>\( \lambda_\textrm{Rust} \)的单位积类型（\( \prod [] \)）相当于Rust的<strong>单元</strong>（Unit）类型（<code>()</code>）；</li>
<li>\( \lambda_\textrm{Rust} \)的单位和类型（\( \sum [] \)）相当于Rust的空枚举类型（<code>enum Type {}</code>）或Never类型（<code>!</code>）．</li>
</ul>
<div class="footnote-definition" id="types"><sup class="footnote-definition-label">1</sup>
<p>\( \lambda_\text{Rust} \)基于Rust中的<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR</a>，其表达式的语法与Rust不同，更接近<a href="https://en.wikipedia.org/wiki/Lambda_calculus">\(\lambda\)-calculus</a>的语法．这里简单起见直接用使用类Rust的语法．</p>
</div>
<h2 id="类型的-textown--predict"><a class="header" href="#类型的-textown--predict">类型的\( \text{own} \) Predict</a></h2>
<p><img src="2023-06-rustbelt/images/own-predict.png" alt="own Predict" /></p>
<p>以几个简单类型为例，说明\( \text{own} \) predict的含义：</p>
<ul>
<li>\[
[\![ \mathbf{bool} ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \; \bar{v} = [\mathbf{true}] \lor \bar{v} = [\mathbf{false}]
\]
即属于布尔类型\(\mathbf{bool}\)的值\(\bar{v}\)要么为单个值\(\mathbf{false}\)，要么为单个值\(\mathbf{true}\)．</li>
<li>\[ [\![ \mathbf{int}  ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \; \exists z \in \mathbb{Z}. \bar{v} = [z] \]
即属于整型\(\mathbf{int}\)的值\(\bar{v}\)为单个整数\(z\)．</li>
<li>\[
[\![ \tau_1 \times \tau_2 ]\!].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \;
\exists \bar{v}_1, \bar{v}_2. (\bar{v} = \bar{v}_1 +\!+ \, \bar{v}_2) \ast
[\![ \tau_1 ]\!].\!\text{own}(\bar{v}_1) \ast [\![ \tau_2 ]\!].\!\text{own}(\bar{v}_2)
\]
即属于积类型\( \tau_1 \times \tau_2 \)的值\(\bar{v}\)为分别属于两个类型\(\tau_1\)与\(\tau_2\)的值
\(\bar{v}_1\)与\(\bar{v}_2\)相连．此处的\(+\!+\)为列表连接（Concentation）运算．</li>
<li>\[
\left[\!\!\left[ \sum_{i=0}^{n-1} \tau_i \right]\!\!\right].\!\text{own}(\bar{v}) \; \mathrel{\mathop:}= \;
\exists i \in \mathbb{N}, \bar{w}. (i &lt; n) \ast (\bar{v} = [i] +\!+ \, \bar{w}) \ast [\![ \tau_i ]\!].\!\text{own}(\bar{w})
\]
即属于和类型\( \sum_{i=1}^n \tau_i \)的值\(\bar{v}\)为一个自然数\(i\)代表其枚举变体（Variant）序号，与一个属于类型
\(\tau_i\)的值\(\bar{w}\)相连．</li>
</ul>
<p>因此，\( [\![ \tau ]\!].\!\text{own}(\bar{v}) \)表示类型\(\tau\)对值列表\(\bar{v}\)的约束关系<sup class="footnote-reference"><a href="#conc">2</a></sup>．</p>
<p>联想到Rust中的<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code><strong>特质</strong></a>（Trait），
可以定义\( \lambda_\textrm{Rust} \)中的\( \mathsf{Copy} \)语义如下：
\[
\tau: \mathsf{Copy} \; \mathrel{\mathop:}= \; [\![ \tau ]\!].\!\text{own}(\bar{v}) \; \mathsf{Persistent}
\]
即当类型\(\tau\)不含任何资源时，它才是\(\mathsf{Copy}\)的．</p>
<div class="footnote-definition" id="conc"><sup class="footnote-definition-label">2</sup>
<p>省略了多线程的部分．</p>
</div>
<h2 id="类型的-textsize-属性"><a class="header" href="#类型的-textsize-属性">类型的\( \text{size} \)属性*</a></h2>
<p><img src="2023-06-rustbelt/images/size.png" alt="size Property" /></p>
<p>在不考虑<a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html"><strong>动态大小类型</strong>（Dynamically Sized Types, DST）</a>
的情况下，每一个Rust类型都确定的内存大小，而在\( \lambda_\textrm{Rust} \)中也有类似的属性．</p>
<p>常见类型的\( \text{size} \)属性如下：</p>
<ul>
<li>\( [\![ \mathbf{bool} ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \mathbf{int} ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \mathbf{own} \, \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \&amp;_\mathbf{mut}^\kappa \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \&amp;_\mathbf{shr}^\kappa \tau ]\!].\!\text{size} \mathrel{\mathop:}= 1 \)</li>
<li>\( [\![ \tau_1 \times \tau_2 ]\!].\!\text{size} \mathrel{\mathop:}=
[\![ \tau_1 ]\!].\!\text{size} + [\![ \tau_2 ]\!].\!\text{size} \)</li>
<li>\(
\left[\!\left[ \sum_i \tau_i \right]\!\right].\!\text{size} \mathrel{\mathop:}= 1 + \displaystyle \max_i [\![ \tau_i ]\!].\!\text{size}
\)</li>
</ul>
<p>此外，类型的\( \text{size} \)属性还须与\( \text{own} \) predict所关联的值列表的长度保持一致，即：
\[ \forall \tau, \bar{v}. [\![ \tau ]\!].\!\text{own}(\bar{v}) \; -\!\ast \; |\bar{v}| = [\![ \tau ]\!].\!\text{size} \]</p>
<h2 id="独占所有权exclusive-ownership与可变借用"><a class="header" href="#独占所有权exclusive-ownership与可变借用">独占所有权（Exclusive Ownership）与可变借用</a></h2>
<p><img src="2023-06-rustbelt/images/box.png" alt="Execlusive Ownership" /></p>
<h3 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h3>
<p>对于<code>Box&lt;T&gt;</code>类型，其\( \text{own} \) predict相比\(\mathbf{int}\)等简单类型更加复杂．
\[
\begin{array}{lll}
[\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, \exists \bar{w}. \ell \mapsto \bar{w} \ast [\![ \tau ]\!].\!\text{own}(\bar{w})
&amp; \ell \text{指向属于类型} \tau \text{的值} \bar{w} \\
&amp; \ast \, \mathsf{Dealloc}(\ell, [\![ \tau ]\!].\!\text{size})
&amp; \text{允许释放以} \ell \text{开始，长度为} [\![ \tau ]\!].\!\text{size} \text{的内存}
\end{array}
\]
若将\( \exists \bar{w}. \ell \mapsto \bar{w} \ast [\![ \tau ]\!].\!\text{own}(\bar{w}) \)简写为
\( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \) （即此时并不关心具体的值\(\bar{w}\)），那么上式可简化为
\[
[\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) \, \mathrel{\mathop:}= \, \exists \ell. (\bar{v} = [\ell])
\ast (\ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own})
\ast \mathsf{Dealloc}(\ell, [\![ \tau ]\!].\!\text{size})
\]</p>
<h3 id="a-mut-t"><a class="header" href="#a-mut-t"><code>&amp;'a mut T</code></a></h3>
<p><code>&amp;'a mut T</code>类型与<code>Box&lt;T&gt;</code>很相似，其\( \text{own} \) predict如下：
\[
\begin{array}{lll}
\left[\!\left[ \&amp;_\mathbf{mut}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, \&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big)
&amp; \text{在生存期} \kappa \text{的完全借用范围内，} \ell \text{指向属于类型} \tau \text{的值}
\end{array}
\]</p>
<p>比较\( [\![ \mathbf{own} \, \tau ]\!].\!\text{own}(\bar{v}) \)与
\( \left[\!\left[ \&amp;_\mathbf{mut}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) \)可以发现：</p>
<ul>
<li>\( \exists \ell. \bar{v} = [\ell] \)表明二者都是单个地址值；</li>
<li>\( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \)表明二者都指向属于类型\(\tau\)的值，但
\( \&amp;_\mathbf{mut}^\kappa \tau \)类型有生存期\( \kappa \)的约束范围．</li>
</ul>
<h3 id="独占的可变借用"><a class="header" href="#独占的可变借用">独占的可变借用</a></h3>
<p>\( \&amp;_\mathsf{full}^\kappa P \) 表示对资源\(P\)的独占借用，生存期为\(\kappa\)．它可通过资源\(P\)任意创建
\[ P \, -\!\ast\; \&amp;_\mathsf{full}^\kappa P \ast \big( [\dagger \kappa] -\!\ast\, P \big) \]
可见，创建\( \&amp;_\mathsf{full}^\kappa P \)需要消耗𠩤来的资源\(P\)；且仅当生存期\(\kappa\)结束时（即获取\([\dagger\kappa]\)后），
才能再次归还资源\(P\)．</p>
<p>这与在Rust语言中</p>
<pre><code class="language-rust ignore">let mut x: Box&lt;T&gt; = /* ... */;
{
    let y: &amp;'a mut T = &amp;mut *x; // 'a &lt;-+
    // `x` is not accessible            |
    use(y); //                          |
} // `'a` ends &lt;------------------------+
access(x); // `x` is accessible again
</code></pre>
<p>可变借用<code>&amp;mut *x</code>得到<code>&amp;'a mut T</code>的语义一致，即在<code>y: &amp;'a mut T</code>存续期间，原有<code>x</code>的值不可再访问；仅当<code>'a</code>结束后，再重新归还<code>x</code>的所有权．</p>
<h2 id="生存期lifetime"><a class="header" href="#生存期lifetime">生存期（Lifetime）*</a></h2>
<p><img src="2023-06-rustbelt/images/lifetime.png" alt="Lifetime" /></p>
<p>上文中提到生存期结束时的\( [\dagger \kappa] \) token，接下来将简单介绍一下\( \lambda_\textrm{Rust} \)中生存期的表示．</p>
<h3 id="什么是生存期"><a class="header" href="#什么是生存期">什么是生存期？</a></h3>
<p>C++或其他编程语言中，<a href="https://en.cppreference.com/w/cpp/language/lifetime">生存期</a>一般是指变量或对象从创建开始到销毁的一段时间，
是<strong>运行时</strong>（Runtime）的概念．C++中生存期偶尔也指<a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>对象所属的作用域，
因为这类对象的创建与释放与其作用域绑定在一起．</p>
<p>而Rust中的<a href="https://doc.rust-lang.org/nomicon/lifetimes.html">生存期</a>概念则有所不同，更多是指引用类型或者借用的有效期，是<strong>抽象语法树</strong>
（Abstract Syntax Tree，AST）或者<strong>控制流图</strong>（Control-Flow Graph，CFG）上的概念而非运行时的概念．</p>
<p>最简单的理解是把生存期近似看作<strong>作用域</strong>（scope）<sup class="footnote-reference"><a href="#scope">3</a></sup>，如以下代码段所示</p>
<pre><code class="language-rust ignore">let mut x = Box::new(1);
'a: {
    let y = &amp;'a mut x; // start of 'a &lt;--+
    *y += 1; //                          |
} // end of `'a` &lt;-----------------------+
</code></pre>
<p>生存期随新的作用域打开而开始，随作用域关闭而结束．</p>
<p>在\( \lambda_\textrm{Rust} \)中，生存期的开始及结束与Rust类似：
\[ 
\begin{array}{lll}
\mathsf{True} &amp; -\!\ast\, \exists \kappa. [\kappa] 
&amp; \text{生存期} \kappa \text{开始时，新建一个token } [\kappa] \text{，该token代表生存期} \kappa \text{存活}  \\
&amp; \ast\; \big([\kappa] -\!\ast\, [\dagger \kappa]\big) 
&amp; \text{生存期} \kappa \text{结束时，消耗原token } [\kappa] \text{后，得到生存期结束的token } [\dagger \kappa]
\end{array}
\]
这里生存期结束的token\([\dagger \kappa]\)是永久的，即
\[ [\dagger \kappa] \; \mathsf{Persistent} \]
这是因为生存期一旦结束，便已成定局，所以此处的token将永久存在，不被消耗．</p>
<div class="footnote-definition" id="scope"><sup class="footnote-definition-label">3</sup>
<p>后来Rust引入了<a href="https://rust-lang.github.io/rfcs/2094-nll.html"><strong>非词法作用域生存期</strong>（Non-Lexical Lifetime，NLL）</a>，使得
生存期不再与作用域绑定．</p>
</div>
<h3 id="生存期的包含关系lifetime-inclusionb-a"><a class="header" href="#生存期的包含关系lifetime-inclusionb-a">生存期的包含关系（Lifetime Inclusion，<code>'b: 'a</code>）</a></h3>
<p>在Rust中，<code>'b: 'a</code>表示生存期<code>'b</code>比<code>'a</code>更长（或等长），这是因为通常情况下带更长生存期类型是带更短生存期类型的子类型<sup class="footnote-reference"><a href="#covar">4</a></sup>，如当<code>'b: 'a</code>
时，<code>&amp;'b T</code>是<code>&amp;'a T</code>的<a href="https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance"><strong>子类型</strong></a>
（Subtype），即<code>&amp;'b T: &amp;'a T</code>．</p>
<p>生存期的包含关系是一个<a href="https://en.wikipedia.org/wiki/Partially_ordered_set"><strong>偏序关系</strong></a>
（Partial Order Relationship），即满足</p>
<ul>
<li>自反性（Reflexive），对任意的<code>'a</code>都有：<code>'a: 'a</code>；</li>
<li>传递性（Transitive），若<code>'a: 'b</code>且<code>'b: 'c</code>那么有<code>'a: 'c</code>．</li>
<li>反对称性（Anti-Symmetric），若<code>'a: 'b</code>且<code>'b: 'a</code>那么<code>'a = 'b</code>.</li>
</ul>
<p>不同于<a href="https://en.wikipedia.org/wiki/Total_order"><strong>全序关系</strong></a>
（Total Order）的是，并非任意两个生存期都存在包含关系，如以下的<code>'a</code>与<code>'b</code>既不满足<code>'a: 'b</code>也不满足<code>'b: 'a</code>．</p>
<pre><code class="language-rust ignore">'a: { } // lifetime `'a`
'b: { } // lifetime `'b`
</code></pre>
<p>当我们提到生存期<code>'b</code>比<code>'a</code>更长时，一般有两层含义．如下列代码段所示</p>
<pre><code class="language-rust ignore">'b: { // `'b` alive
    'a: { // `'a`, `'b` alive
        // ...
    } // `'a` ends
} // `'a`, `'b` end
</code></pre>
<ul>
<li>若较短的生存期<code>'a</code>存活，那么较长的生存期<code>'b</code>也一定存活；</li>
<li>若较长的生存期<code>'b</code>结束，那么较短的生存期<code>'a</code>也一定结束．</li>
</ul>
<p>在\( \lambda_\textrm{Rust} \)中，生存期的包含关系略微有点复杂，但也与上述两层含义一一对应
\[
\begin{array}{ll}
\alpha \sqsubseteq \beta \mathrel{\mathop:}= \\
\quad [\alpha] \propto [\beta]
&amp; \text{拥有较短生存期} \alpha \text{的token时，可通过Accessor模式临时获取较长生存期} \beta \text{的token} \\
\quad \ast\, ([\dagger \beta] -\!\ast\, [\dagger \alpha])
&amp; \text{当较长的生存期} \beta \text{结束时，也可得知较短的生存期} \alpha \text{也一定结束}
\end{array}
\]
注意这里较短的生存期token是「更大」的资源．因为当生存期存活时，可以推断出任何比它长的生存期都存活，也即上述定义中的第一项，可以通过
<a href="2023-06-rustbelt/02-logics.html#accessor%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E7%BB%8F%E5%A4%A7%E5%B9%85%E7%AE%80%E5%8C%96">Accessor资源访问模式</a>来获取任意一个比它更长的生存期的token．</p>
<div class="footnote-definition" id="covar"><sup class="footnote-definition-label">4</sup>
<p>这里指<a href="https://doc.rust-lang.org/reference/subtyping.html#variance"><strong>协变</strong>（Covariant）</a>类型中的生存期参数．</p>
</div>
<h3 id="静态生存期static"><a class="header" href="#静态生存期static">静态生存期（<code>'static</code>）</a></h3>
<p>在Rust语言中，有一个特殊的生存期<code>'static</code>，它比其他任何生存期都更长，即在整个程序中任意作用域（包括静态作用域）范围内都存活．</p>
<pre><code class="language-rust ignore">static STR: &amp;'static str = &quot;Hello, world!&quot;.
</code></pre>
<p>在\( \lambda_\textrm{Rust} \)中，以\(\varepsilon\)代指静态生存期，则有
\[
\begin{array}{ll}
\mathsf{True} -\!\ast\, [\varepsilon] &amp; \text{可任意获取生存期} \varepsilon \text{存活的token} \\
[\dagger \varepsilon] -\!\ast\, \mathsf{False} &amp; \text{生存期} \varepsilon \text{永不结束}
\end{array}
\]</p>
<h3 id="生存期token的拆分"><a class="header" href="#生存期token的拆分">生存期token的拆分</a></h3>
<p>由于生存期token不属于<a href="2023-06-rustbelt/02-logics.html#%E6%B0%B8%E4%B9%85%E8%B5%84%E6%BA%90persistent">永久资源</a>，即不可复制，但很多时候生存期的token需要在多处使用
（如共属于同一作用域的多个引用类型），因此需要一种生存期token的复用方式．</p>
<p>Iris中通常使用有理拆分的方式，将一个完整的生存期token\([\kappa]\)，拆分成多个不完整的token，从而使得同一个生存期token可以在多处使用．</p>
<p>赋予每个token一个有理份额\(q\)，即\([\kappa]_q\)，其中\(q\)为不大于\(1\)的正有理数．当\(q = 1\)时，即\([\kappa]_1\)为完整
token；当\(q &lt; 1\)时，\([\kappa]_q\)为不完整token．拆分规则如下<sup class="footnote-reference"><a href="#ast">5</a></sup>：
\[
\forall \kappa. \forall q, q' \in \mathbb{Q}_{+}. q + q' \le 1 \implies [\kappa]_{q + q'} \ast\!-\!\ast\, [k]_q \ast [k]_{q'}
\]</p>
<p>相应地，前文提到的生存期的几个规则将变为：
\[
\mathsf{True} -\!\ast\, \exists \kappa. [\kappa]_1 \ast \big([\kappa]_1 -\!\ast\, [\dagger \kappa]\big) 
\]
即生存期的开始与结束仍然需要完整的token．令\( \mathbb{Q}_1 \mathrel{\mathop:}= \mathbb{Q} \cap (0, 1] \)，
\[
\begin{array}{ll}
\alpha \sqsubseteq \beta &amp; \mathrel{\mathop:}= \,
(\forall q \in \mathbb{Q}_1. [\alpha]_q) \propto (\forall q' \in \mathbb{Q}_1. [\beta]_{q'}) \\
&amp; \ast\, ([\dagger \beta] -\!\ast\, [\dagger \alpha])
\end{array}
\]
此时可使用不完整token，并且在Accessor资源访问模式中允许任意变换token的份额．</p>
<h2 id="共享所有权shared-ownership与不可变借用"><a class="header" href="#共享所有权shared-ownership与不可变借用">共享所有权（Shared Ownership）与不可变借用*</a></h2>
<p><img src="2023-06-rustbelt/images/shared.png" alt="Shared Ownership" /></p>
<h3 id="a-t与类型的-textshr--predict"><a class="header" href="#a-t与类型的-textshr--predict"><code>&amp;'a T</code>与类型的\( \text{shr} \) Predict</a></h3>
<p><code>&amp;'a T</code>类型与<code>&amp;'a mut T</code>差别较大，\( \lambda_\textrm{Rust} \)引入了\( \text{shr} \) predict代表值的共享关系，
\( \&amp;_\mathbf{shr}^\kappa \tau \)类型的\( \text{own} \) predict可定义如下：
\[
\begin{array}{lll}
\left[\!\left[ \&amp;_\mathbf{shr}^\kappa \tau \right]\!\right]\!.\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell)
&amp; \text{在生存期} \kappa \text{存活的范围内，} \ell \text{共享了属于类型} \tau \text{的值}
\end{array}
\]</p>
<p>由于Rust中的<code>&amp;'a T: Copy</code>，因此\( \&amp;_\mathbf{shr}^\kappa \tau \)类型的\( \text{own} \) predict须是永久的，于是任意类型\(\tau\)的
\( \text{shr} \) predict都须是永久的，即
\[ \forall \tau, \kappa, \ell. [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \; \mathsf{Persistent} \]</p>
<p>此外，\( \text{shr} \) predict还须支持生存期的包含关系，有
\[
\forall \tau, \kappa, \kappa', \ell. \kappa' \sqsubseteq \kappa
\ast [\![ \tau ]\!].\!\text{shr}(\kappa, \ell)
-\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa', \ell)
\]
表明<code>&amp;'a T</code>关于<code>'a</code>协变，即当<code>'b: 'a</code>时，有<code>&amp;'b T: &amp;'a T</code>．</p>
<p>\( [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \)的实现非常复杂，因篇幅所限，此处不再赘述，有兴趣者可参阅<a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt论文</a>中的第四章：Lifetime logic．</p>
<h3 id="a-mut-t到a-t的隐式转换"><a class="header" href="#a-mut-t到a-t的隐式转换"><code>&amp;'a mut T</code>到<code>&amp;'a T</code>的隐式转换</a></h3>
<p>为了支持Rust中<code>&amp;'a mut T</code>到<code>&amp;'a T</code>的隐式转换，\( \lambda_\textrm{Rust} \)引入了下列规则：
\[
\forall \tau, \kappa, \ell, q \in \mathbb{Q}_1.
\&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big) 
\ast [k]_q -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \ast [\kappa]_q
\]
因此只要生存期\(\kappa\)存活，那么类型\( \&amp;_\mathbf{mut}^\kappa \tau \)可以转换为类型\( \&amp;_\mathbf{shr}^\kappa \tau \)，转换后生存期\(\kappa\)仍然存活．</p>
<div class="footnote-definition" id="ast"><sup class="footnote-definition-label">5</sup>
<p>\(P \ast\!-\!\ast Q\)为\( (P -\!\ast\, Q) \ast (Q -\!\ast\, P) \)的简写．</p>
</div>
<h2 id="小结"><a class="header" href="#小结">小结*</a></h2>
<p>\( \lambda_\textrm{Rust} \)中类型的语义模型到此结束．每个类型\(\tau\)有三个属性或predict
\[
Type \mathrel{\mathop:}= \left\lbrace \begin{array}{ll}
\text{size} : \mathbb{N} &amp; \text{属于类型} \tau \text{的值列表长度} \\
\text{own} : List(Val) \to iProp &amp; \text{类型} \tau \text{对持所有权的值的资源约束} \\
\text{shr} : Lft \times Loc \to iProp &amp; \text{类型} \tau \text{对共享值的约束} \\
\end{array} \right\rbrace
\]
其中\(List\)指列表，\(Loc\)指位置值，\(iProp\)指Iris资源．</p>
<p>但除此之外，类型的语义模型还要求满足以下条件
\[
SemType \mathrel{\mathop:}= \left\lbrace 
\tau \in Type \middle|
\begin{array}{ll}
\left( \forall \bar{v}. [\![ \tau ]\!].\!\text{own}(\bar{v}) -\!\ast\, |\bar{v}| = [\![ \tau ]\!].\!\text{size} \right) \; \land 
&amp; \text{size与own的一致性} \\
\left( \forall \kappa, \ell. [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \; \mathsf{Persistent} \right) \; \land 
&amp; \text{shr的永久性} \\
\left( \begin{array}{l}
\forall \kappa, \kappa', \ell. \kappa' \sqsubseteq \kappa \ast [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \\
\quad -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa', \ell) 
\end{array} \right) \land 
&amp; \text{shr的单调性} \\
\left( \begin{array}{l}
\forall \kappa, \ell, q \in \mathbb{Q}_1.
\&amp;_\mathsf{full}^\kappa \big( \ell \mapsto \!\! \ast \, [\![ \tau ]\!].\!\text{own} \big) \ast [k]_q \\
\quad -\!\ast\, [\![ \tau ]\!].\!\text{shr}(\kappa, \ell) \ast [\kappa]_q
\end{array} \right)
&amp; \text{own可转换到shr}
\end{array} \right\rbrace
\]
以上便是\( \lambda_\textrm{Rust} \)类型语义模型的全部定义．在此基础上，若欲支持多线程，可在\(\text{own}\)与\(\text{shr}\) predicts中新增线程ID参数．
涉及多线程的借用语义将更加复杂，在此不再赘述，有兴趣者可自行参阅<a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt论文</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例rc"><a class="header" href="#示例rc">示例<code>Rc</code></a></h1>
<p>下面以<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code>类型</a>为例，介绍其语义模型与实现．</p>
<h2 id="rc的语义模型"><a class="header" href="#rc的语义模型"><code>Rc</code>的语义模型</a></h2>
<p><img src="2023-06-rustbelt/images/rc-def.png" alt="Rc" /></p>
<p>若不考虑弱引用，<code>Rc</code>的内存布局可以看作一个指针，指向一个含引用计数与承载数据的内存地址．</p>
<p>在\( \lambda_\text{Rust} \)中，引入\( \mathbf{rc} \, \tau \)类型以代表<code>Rc&lt;T&gt;</code>类型，若按以下方式定义
\[
\begin{array}{lll}
[\![ \mathbf{rc} \, \tau ]\!].\!\text{size}
&amp; \mathrel{\mathop:}= 1 \\
[\![ \mathbf{rc} \, \tau ]\!].\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] 
&amp; \bar{v} \text{是单个地址值} \ell \\
&amp; \ast \, \exists c \in \mathbb{Z}_{+}, \bar{w}. \ell \mapsto c :: \bar{w}
&amp; \ell \text{指向引用计数} c \text{与类型} \tau \text{的值} \bar{w} \\
&amp; \ast \, ? &amp; \text{应当如何表示共享所有权的值的约束？}
\end{array}
\]
（其中\(v :: l\)表示将值\(v\)插入列表\(l\)的首部而得的新列表），但这样的问题在于：</p>
<ol>
<li>\( \ell \mapsto c :: \bar{w} \)是独占所有权的，不能满足多个\( \mathbf{rc} \, \tau \)类型共享所有权的要求；</li>
<li>考虑到引用计数的存在，并不能简单地用\( [\![ \tau ]\!].\!\text{own}(\bar{w}) \)来\( \bar{w} \)：
<ul>
<li>当\(c = 1\)时，\( \mathbf{rc} \, \tau \)表现为独占所有权，其语义与\( \mathbf{own} \, \tau \)类型一致；</li>
<li>当\(c &gt; 1\)时，\( \mathbf{rc} \, \tau \)表现为共享所有权．</li>
</ul>
</li>
</ol>
<p>对于1，可以参考<a href="2023-06-rustbelt/03-rust-semantics.html#%E7%94%9F%E5%AD%98%E6%9C%9Ftoken%E7%9A%84%E6%8B%86%E5%88%86">生存期token拆分</a>，为\( \ell \mapsto P \)赋予有理数份额\(q\)，
即\( \ell \overset{q}{\mapsto} P \)以表达部分所有权的语义．所有权拆分的方式如下
\[
\forall q, q' \in \mathbb{Q}_1, \ell, P. q + q' \le 1 \implies
\ell \overset{q + q'}{\longmapsto} P \; \ast\!-\!\ast \; (\ell \overset{q}{\mapsto} P) \ast (\ell \overset{q'}{\mapsto} P)
\]</p>
<h3 id="textshared_own-predict1"><a class="header" href="#textshared_own-predict1">\(\text{shared_own}\) Predict<sup class="footnote-reference"><a href="#shared-own">1</a></sup></a></h3>
<p><img src="2023-06-rustbelt/images/shared_own.png" alt="shared_own" /></p>
<p>将\( \ell \mapsto c :: \bar{w} \)拆分为部分份额后，还须建立部分所有权份额\(q\)与引用计数\(c\)之间的约束．简单起见，引入
\[ \text{shared_own} \mathrel{\mathop:}= SemType \times Loc \times List(Val) \times \mathbb{N}_{+} \times \mathbb{Q}_1 \to iProp \]
再重新定义\( [\![ \mathbf{rc} \, \tau ]\!]\!.\!\text{own} \)如下
\[
\begin{array}{ll}
[\![ \mathbf{rc} \, \tau ]\!]\!.\!\text{own}(\bar{v}) 
&amp; \mathrel{\mathop:}= \, \exists \ell. \bar{v} = [\ell] \\
&amp; \ast \, \exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1, \bar{w}. \ell \overset{q}{\mapsto} c :: \bar{w} \\
&amp; \ast \, \text{shared_own}(\tau, \ell, \bar{w}, c, q)
\end{array}
\]</p>
<p>考察引用计数\(c\)与部分所有权份额\(q\)的关系：</p>
<ul>
<li>当\(c = 1\)时，\(q = 1\)，且\( \mathbf{rc} \, \tau \)的语义与\( \mathbf{own} \, \tau \)一致，有
\[
\forall \tau, \ell, \bar{w}. \text{shared_own}(\tau, \ell, \bar{w}, 1, 1) \; \ast\!-\!\ast \;
[\![ \tau ]\!].\!\text{own}(\bar{w}) \ast \, \mathsf{Dealloc}(\ell, 1 + [\![ \tau ]\!].\!\text{size})
\]</li>
<li>当引用计数\(c\)加一时，同时可将份额为\(q + q'\)的部分所有权拆分为两个更小份额\(q\)与\(q'\)的部分所有权
\[
\begin{array}{l}
\forall q, q' \in \mathbb{Q}_1, c, c' \in \mathbb{Z}_{+}, \tau, \ell, \bar{w}. q + q' \le 1 \implies \\
\quad \text{shared_own}(\tau, \ell, \bar{w}, c, q + q') \ast\!-\!\ast \\
\quad \text{shared_own}(\tau, \ell, \bar{w}, c + 1, q) \\
\quad \ast\, \text{shared_own}(\tau, \ell, \bar{w}, c + 1, q')
\end{array}
\]</li>
<li>当\(c &gt; 1\)时，\( \mathbf{rc} \, \tau \)表现为共享所有权语义，该语义过于复杂，涉及Iris里面的高阶Ghost State的概念，此处暂不展开．</li>
</ul>
<div class="footnote-definition" id="shared-own"><sup class="footnote-definition-label">1</sup>
<p>因模型简化需要，该实现相比RustBelt论文，省略了大量细节．</p>
</div>
<h2 id="rc的实现"><a class="header" href="#rc的实现"><code>Rc</code>的实现</a></h2>
<p><img src="2023-06-rustbelt/images/rc-impl.png" alt="Rc Implementations" /></p>
<p>下面以<code>Rc</code>类型中最常用的两个函数<code>Rc::new</code>与<code>Rc::clone</code>为例，介绍如何使用\( \lambda_\text{Rust} \)验证其正确性．</p>
<h3 id="rcnew的实现"><a class="header" href="#rcnew的实现"><code>Rc::new</code>的实现*</a></h3>
<p><img src="2023-06-rustbelt/images/rc-new.png" alt="Rc::new" /></p>
<p><code>Rc::new</code>简化后的逻辑如下</p>
<pre><code class="language-rust ignore">fn Rc::&lt;T&gt;::new(w: T) -&gt; Rc&lt;T&gt; {
    let x = Box::new(Cons(1, w));
    x.into()
}
</code></pre>
<p>即先创建一个引用计数为<code>1</code>，值为<code>w</code>的<code>Box</code>，然后再将其转换为<code>Rc</code>（略去指针的实现细节，此处的类型转换可视为No-op）．</p>
<p>求证：
\[
\big\lbrace [\![ \tau ]\!].\!\text{own}(\bar{w}) \big\rbrace 
\; \mathbf{let} \, x = \text{Rc::new}(\bar{w}) \;
\big\lbrace [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([x]) \big\rbrace
\]</p>
<p><strong>证明</strong>（概要）：</p>
<p>展开\( \text{Rc::new} \)及\( [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([x]) \)得
\[
\begin{array}{lr}
\big\lbrace [\![ \tau ]\!].\!\text{own}(\bar{w}) \big\rbrace \\
\quad \mathbf{let} \, x = \text{Box::new}(1 :: \bar{w}) \, ; &amp; (1) \\
\quad \mathbf{let} \, x = x.\!\text{into}() &amp; (2) \\
\left\lbrace \begin{array}{l} 
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \left( x \overset{q}{\mapsto} c :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (3)
\end{array}
\]
对(1)应用\( [\![ \mathbf{own} \, \tau ]\!].\!\text{own} \)的定义，有
\[
\begin{array}{lr}
\big\lbrace [\![ \tau ]\!].\!\text{own}(\bar{w}) \big\rbrace \\
\quad \mathbf{let} \, x = \text{Box::new}(1 :: \bar{w}) \, ; \\
\left\lbrace \begin{array}{l}
(x \mapsto 1 :: \bar{w}) \ast [\![ \tau ]\!].\!\text{own}(\bar{w}) \, \ast \\
\mathsf{Dealloc}(x, 1 + [\![ \tau ]\!].\!\text{size})
\end{array} \right\rbrace &amp; (4)
\end{array}
\]
对(2), (4)式应用\( \text{shared_own} \)的第一个性质，得
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
(x \mapsto 1 :: \bar{w}) \ast [\![ \tau ]\!].\!\text{own}(\bar{w}) \, \ast \\
\mathsf{Dealloc}(x, 1 + [\![ \tau ]\!].\!\text{size})
\end{array} \right\rbrace &amp; (4) \\
\quad \mathbf{let} \, x = x.\!\text{into}() &amp; (2) \\
\left\lbrace \begin{array}{l}
\left( x \overset{1}{\mapsto} 1 :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, 1, 1)
\end{array} \right\rbrace &amp; (5)
\end{array}
\]
(5)式中令\(c = 1, q = 1\)得
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists q = 1, c = 1.
\left( x \overset{q}{\mapsto} c :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (5')
\end{array}
\]
(3)得证．\(\square\)</p>
<h3 id="rcclone的实现"><a class="header" href="#rcclone的实现"><code>Rc::clone</code>的实现</a></h3>
<p><img src="2023-06-rustbelt/images/rc-clone-1.png" alt="Rc::clone" /></p>
<p><code>Rc::clone</code>简化后的逻辑如下</p>
<pre><code class="language-rust ignore">fn Rc::&lt;T&gt;::clone(x: &amp;Rc&lt;T&gt;) -&gt; Rc&lt;T&gt; { unsafe {
    (*x).0 += 1;
    let y = ptr::read(x);
    y
} }
</code></pre>
<p>即首先将其引用计数自增<code>1</code>，然后再将<code>x</code>的指针浅复制一份得到<code>y</code>．</p>
<p>求证：
\[
\big\lbrace [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([x]) \big\rbrace 
\; \mathbf{let} \, y = x.\!\text{clone}() \;
\big\lbrace [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([x]) \ast [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([y]) \big\rbrace
\]</p>
<p><strong>证明</strong>（概要）：</p>
<p>展开\( \text{Rc::clone} \)，\( [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([x]) \)
及 \( [\![ \mathbf{rc} \, \tau ]\!].\!\text{own}([y]) \)得
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \left( x \overset{q}{\mapsto} c :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (1) \\
\quad ({\mbox*}x).0 \, +\!= 1 \, ; &amp; (2) \\
\quad \mathbf{let} \, y = \text{ptr::read}(x) &amp; (3) \\
\left\lbrace \begin{array}{l}
\exists c', c'' \in \mathbb{Z}_{+}, q', q'' \in \mathbb{Q}_1. \\
\left( x \overset{q'}{\mapsto} c' :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c', q') \; \ast \\
\left( y \overset{q''}{\mapsto} c'' :: \bar{w} \right) \ast \text{shared_own}(\tau, y, \bar{w}, c'', q'')
\end{array} \right\rbrace &amp; (4) \\
\end{array}
\]
由(1), (2)式得
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \left( x \overset{q}{\mapsto} c :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (1) \\
\quad ({\mbox*}x).0 \, +\!= 1 \, ; &amp; (2) \\
\left\lbrace \begin{array}{l}
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \left( x \overset{q}{\mapsto} (c + 1) :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (5) \\
\end{array}
\]
现须证
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \left( x \overset{q}{\mapsto} (c + 1) :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c, q)
\end{array} \right\rbrace &amp; (5) \\
\quad \mathbf{let} \, y = \text{ptr::read}(x) &amp; (3) \\
\left\lbrace \begin{array}{l}
\exists c', c'' \in \mathbb{Z}_{+}, q', q'' \in \mathbb{Q}_1. \\
\left( x \overset{q'}{\mapsto} c' :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c', q') \; \ast \\
\left( y \overset{q''}{\mapsto} c'' :: \bar{w} \right) \ast \text{shared_own}(\tau, y, \bar{w}, c'', q'')
\end{array} \right\rbrace &amp; (4) \\
\end{array}
\]</p>
<p><img src="2023-06-rustbelt/images/rc-clone-2.png" alt="Rc::clone" /></p>
<p>应用\( \text{shared_own} \)的第二个性质，将(5)式中的\( \text{shared_own}(\tau, x, \bar{w}, c, q) \)拆分为两个\( {}^q/{}_2 \)的份额
\[
\begin{array}{l}
\text{shared_own}(\tau, x, \bar{w}, c, q) \; -\!\ast \\
\quad \text{shared_own}(\tau, x, \bar{w}, c + 1, {}^q/{}_2) \; \ast \\
\quad \text{shared_own}(\tau, x, \bar{w}, c + 1, {}^q/{}_2)
\end{array}
\]
再将\( x \overset{q}{\mapsto} (c + 1) :: \bar{w} \)也拆成两个\( {}^q/{}_2 \)的份额
\[
x \overset{q}{\mapsto} (c + 1) :: \bar{w} \; -\!\ast \;
\left( x \overset{{}^q/{}_2}{\mapsto} (c + 1) :: \bar{w} \right) \ast \left( x \overset{{}^q/{}_2}{\mapsto} (c + 1) :: \bar{w} \right)
\]</p>
<p><img src="2023-06-rustbelt/images/rc-clone-3.png" alt="Rc::clone" /></p>
<p>得
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists c \in \mathbb{Z}_{+}, q \in \mathbb{Q}_1. \\
\left( x \overset{{}^q/{}_2}{\mapsto} (c + 1) :: \bar{w} \right) \ast
\left( x \overset{{}^q/{}_2}{\mapsto} (c + 1) :: \bar{w} \right) \ast \\
\text{shared_own}(\tau, x, \bar{w}, c + 1, {}^q/{}_2) \; \ast \\
\text{shared_own}(\tau, x, \bar{w}, c + 1, {}^q/{}_2)
\end{array} \right\rbrace &amp; (5')
\end{array}
\]</p>
<p><img src="2023-06-rustbelt/images/rc-clone-4.png" alt="Rc::clone" /></p>
<p>令\( q' = q'' = {}^q/{}_2 \)，\(c' = c'' = c + 1\)，则
\[
\begin{array}{lr}
\left\lbrace \begin{array}{l}
\exists c', c'' = c + 1, q', q'' = {}^q/{}_2. \\
\left( x \overset{q'}{\mapsto} c' :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c', q') \; \ast \\
\left( x \overset{q''}{\mapsto} c'' :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c'', q'')
\end{array} \right\rbrace &amp; (5'') \\
\quad \mathbf{let} \, y = \text{ptr::read}(x) &amp; (3) \\
\left\lbrace \begin{array}{l}
\exists c', c'' \in \mathbb{Z}_{+}, q', q'' \in \mathbb{Q}_1. \\
\left( x \overset{q'}{\mapsto} c' :: \bar{w} \right) \ast \text{shared_own}(\tau, x, \bar{w}, c', q') \; \ast \\
\left( y \overset{q''}{\mapsto} c'' :: \bar{w} \right) \ast \text{shared_own}(\tau, y, \bar{w}, c'', q'')
\end{array} \right\rbrace &amp; (4) \\
\end{array}
\]
(3)式中的\( \text{ptr::read} \)为浅复制，因此上式不难得证．\(\square\)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polonius学习笔记"><a class="header" href="#polonius学习笔记">Polonius学习笔记</a></h1>
<p>写于2022年1月21日。</p>
<p>Polonius是一个推理引擎，基于MIR层输入的控制流图、变量信息、借用信息、生存期约束信息，推导出程序中是否有语句违反Rust对于借用的约定规则，以便编译器报告语法错误，并尽可能向用户提供有帮助的改进建议。</p>
<h2 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h2>
<p>Polonius的输入信息，通过<a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E9%9B%B6%EF%BC%89-%E5%8E%9F%E5%AD%90%E5%BC%8F%E4%B8%8E%E8%BE%93%E5%85%A5.html">「原子式（Atom）」与「输入事实（AllFacts）」</a>两个概念来表达。原子式是输入信息的概念分类，而输入事实是一系列给定的真命题。</p>
<p>Polonius引擎则基于这些真命题，按照一系列的分析规则，推导出矛盾（即错误）信息，再返回给编译器以报告编译错误。（无矛盾信息生成时，视为借用检查通过，将不会产生编译错误。）</p>
<h2 id="分析流程"><a class="header" href="#分析流程">分析流程</a></h2>
<ol>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">初始化分析</a>：计算MIR各个位置（Point）处变量（Variable）的初始化、逆初始化（被移动）的状态，与该处发生「移动后访问」错误的路径（Path）（若有）。</li>
<li><a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html">存活性分析</a>：计算MIR各个位置（Point）处，分别有哪些借用源（Origin）存活。</li>
<li><a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90.html">借债分析</a>：计算MIR各个位置（Point）处，存在矛盾（存活且失效）的借债（Loan）；并计算在哪些位置（Point）处，产生了与外部定义的生存期约束（SubOrigin, Origin）相矛盾的约束。前者用于报告违反借用规则的错误，后者用于报告可能存在悬垂引用的错误。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原子式与输入"><a class="header" href="#原子式与输入">原子式与输入</a></h1>
<p>写于2022年1月21日。</p>
<h2 id="原子式atom"><a class="header" href="#原子式atom">原子式（Atom）</a></h2>
<p>原子式即分析过程中用到的输入信息的分类。</p>
<h3 id="variable"><a class="header" href="#variable"><code>Variable</code></a></h3>
<p>由用户定义的变量。如<code>let x, y;</code>中的<code>x</code>、<code>y</code>。</p>
<h3 id="path"><a class="header" href="#path"><code>Path</code></a></h3>
<p>结构体、元组、数组等变量的字段访问路径。如<code>a.b</code>、<code>x.y.z.0</code>、<code>s[0]</code>等（数组不区分不同下标）。</p>
<h3 id="point"><a class="header" href="#point"><code>Point</code></a></h3>
<p>控制流图（Control-flow Graph，CFG）中的某个语句。每条语句被拆成Start和Mid两个节点，</p>
<ul>
<li><code>Start</code>：执行该语句前；</li>
<li><code>Mid</code>：执行该语句时。</li>
</ul>
<h3 id="loan"><a class="header" href="#loan"><code>Loan</code></a></h3>
<p>借债，对应Rust中的借用（borrow）概念。如<code>let y = &amp;x;</code>中的<code>&amp;x</code>。</p>
<h3 id="origin"><a class="header" href="#origin"><code>Origin</code></a></h3>
<p>借用源，对应Rust中的生存期（lifetime）概念。如<code>let x: &amp;'a i32;</code>中的<code>'a</code>。</p>
<p><code>Origin</code>应理解为「所有引用到该<code>Origin</code>的<code>Loan</code>集合」。</p>
<h2 id="输入事实allfacts"><a class="header" href="#输入事实allfacts">输入事实（<code>AllFacts</code>）</a></h2>
<p>输入来源于MIR。主要包含CFG的执行到达关系图；变量的赋值、移动、访问情况；借债的发生、清除、失效信息；因借用产生、或外部定义的笁存期及其约束条件等信息。</p>
<h3 id="cfg_edge"><a class="header" href="#cfg_edge"><code>cfg_edge</code></a></h3>
<p><code>cfg_edge(SourcePoint, TargetPoint)</code>，一条控制流图的边，表示<code>SourcePoint</code>的下一条执行点为<code>TargetPoint</code>。</p>
<h3 id="loan_issued_at"><a class="header" href="#loan_issued_at"><code>loan_issued_at</code></a></h3>
<p><code>loan_issued_at(Origin, Loan, Point)</code>表示在位置<code>Point</code>处发生了借债<code>Loan</code>，其生存期为<code>Origin</code>。</p>
<h3 id="placeholder与universal_region"><a class="header" href="#placeholder与universal_region"><code>placeholder</code>（与<code>universal_region</code>）</a></h3>
<p><code>placeholder(Origin, Loan)</code>表示外部定义的生存期（如<code>fn max&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str</code>中的<code>'a</code>，及期关联的<code>Loan</code>。这些生存期也是函数签名的一部份。另外，由于它的<code>Loan</code>对借债检查而言是未知的，不能作任何假设，因此称之为「占位符」（placeholder）。</p>
<p><code>universal_region(Origin)</code>与<code>placeholder</code>类似，单指由函数签名定义的生存期，不带具体的<code>Loan</code>。</p>
<h3 id="loan_killed_at"><a class="header" href="#loan_killed_at"><code>loan_killed_at</code></a></h3>
<p><code>loan_killed_at(Loan, Point)</code>指某个借债<code>Loan</code>在位置<code>Point</code>处被清除。表明该借债<code>Loan</code>对应的路径<code>Path</code>在<code>Point</code>处被赋值或覆写。</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
let mut q = &amp;mut a;
let r = &amp;mut *q; // `Loan` L0，此处借用了`*q`
// `q` 不能再使用，只能通过`r`访问
q = &amp;mut b; // L0被清除
// 此后，`q`与`r`可以继续使用
<span class="boring">}
</span></code></pre></pre>
<p><code>q</code>再次赋值后，Loan <code>L0</code> 被清除。Rustc在进入借用检查之前会将这样的关系计算好，保存在<code>loan_killed_at</code>中。之后，在<a href="2022-01-polonius/./02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90.html">借债分析</a>时，<code>loan_killed_at</code>中的<code>Point</code>将阻止相应的<code>Loan</code>在CFG中传播。</p>
<h3 id="subset_base"><a class="header" href="#subset_base"><code>subset_base</code></a></h3>
<p><code>subset_base(SubOrigin, Origin, Point)</code>表示，在位置<code>Point</code>处，有一条<code>SubOrigin: Origin</code>的约束（即<code>SubOrigin</code>应当长存于（outlives）<code>Origin</code>。</p>
<h3 id="loan_invalidated_at"><a class="header" href="#loan_invalidated_at"><code>loan_invalidated_at</code></a></h3>
<p><code>loan_invalidated_at(Point, Loan)</code>表明在<code>Point</code>处失效。</p>
<p>借用有共享（shared）与可变（mutable）两种。共享借用只能用于读取，不能写入或修改；可变借用必须独占，保证不能有对同一Path的借用。否则，视为借用失效，失效的借债将保存在<code>loan_invalidated_at</code>关系中。</p>
<h3 id="known_placeholder_subset"><a class="header" href="#known_placeholder_subset"><code>known_placeholder_subset</code></a></h3>
<p><code>known_placeholder_subset(SubOrigin, Origin)</code>用于表示函数签名处定义的生存期约束。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化分析initialization-analysis"><a class="header" href="#初始化分析initialization-analysis">初始化分析（Initialization Analysis）</a></h1>
<p>写于2022年1月21日。</p>
<p>初始化分析主要计算出经传递后的<code>Path</code>读写、移动之处，变量的初始化、移动情况，并找出因移动而导致的错误（即试图访问被移动或部分移动的变量）。</p>
<h2 id="1-将路径的读写移动情况传递至其子路径"><a class="header" href="#1-将路径的读写移动情况传递至其子路径">1. 将路径的读写、移动情况传递至其子路径</a></h2>
<p>所有路径（除入参外）在刚进入函数体内时，均视为已移动。</p>
<h3 id="输入"><a class="header" href="#输入">输入</a></h3>
<pre><code class="language-prolog">path_moved_at   (Path, Point) :- path_moved_at_base   (Path, Point).
path_assigned_at(Path, Point) :- path_assigned_at_base(Path, Point).
path_accessed_at(Path, Point) :- path_accessed_at_base(Path, Point).

ancestor_path(ParentPath, ChildPath) :- child_path(ChildPath, ParentPath).

path_begin_with_var(Path, Variable) :- path_is_var(Path, Variable).
</code></pre>
<p>其中，<code>path_begin_with_var</code>代表某个<code>Path</code>是否属于某个变量（含递归），如<code>a.b</code>、<code>a.b.c</code>都属于变量<code>a</code>。</p>
<h3 id="推导"><a class="header" href="#推导">推导</a></h3>
<ol>
<li>传递<code>ancestor_path</code>。</li>
</ol>
<pre><code class="language-prolog">ancestor_path(GrandparentPath, ChildPath) :-
    ancestor_path(ParentPath, ChildPath),
    child_path(ParentPath, GrandparentPath).
</code></pre>
<ol start="2">
<li>移动、赋值、访问某一路径<code>ParentPath</code>时，也将移动、赋值、访问其子路径<code>ChildPath</code>。</li>
</ol>
<pre><code class="language-prolog">path_moved_at(ChildPath, Point) :-
    path_moved_at(ParentPath, Point),
    ancestor_path(ParentPath, ChildPath).

path_assigned_at(ChildPath, point) :-
    path_assigned_at(ParentPath, point),
    ancestor_path(ParentPath, ChildPath).

path_accessed_at(ChildPath, point) :-
    path_accessed_at(ParentPath, point),
    ancestor_path(ParentPath, ChildPath).
</code></pre>
<ol start="3">
<li>若某个路径<code>Path</code>属于某个变量<code>Variable</code>时，其子路径也属于该变量。</li>
</ol>
<pre><code class="language-prolog">path_begins_with_var(Child, Variable) :-
    path_begins_with_var(Parent, Variable)
    ancestor_path(Parent, Child).
</code></pre>
<h2 id="2-计算变量初始化情况并求解移动造成的错误"><a class="header" href="#2-计算变量初始化情况并求解移动造成的错误">2. 计算变量初始化情况，并求解移动造成的错误</a></h2>
<h3 id="推导-1"><a class="header" href="#推导-1">推导</a></h3>
<ol>
<li>对于每一个路径，从每个 <strong>赋值</strong> 处开始，沿CFG边向后追溯直到该路径被 <strong>移动</strong> 时，该路径都视为 <strong>已初始化</strong> 状态。</li>
</ol>
<pre><code class="language-prolog">path_maybe_initialized_on_exit(Path, Point) :-s
    path_assigned_at(Path, Point).

path_maybe_initialized_on_exit(Path, TargetPoint) :-
    path_maybe_initialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    !path_moved_at(Path, TargetPoint).
</code></pre>
<ol start="2">
<li>对于每一个路径，从每个 <strong>移动</strong> 处开始，沿CFG边向后追溯直到该路径被 <strong>赋值</strong> 时，该路径都视为 <strong>未初始化</strong> 状态。</li>
</ol>
<pre><code class="language-prolog">path_maybe_uninitialized_on_exit(Path, Point) :-
    path_moved_at(Path, Point).

path_maybe_uninitialized_on_exit(Path, TargetPoint) :-
    path_maybe_uninitialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint)
    !path_assigned_at(Path, TargetPoint).
</code></pre>
<ol start="3">
<li>已初始化的路径，其对应的变量视为（半）初始化状态。</li>
</ol>
<pre><code class="language-prolog">var_maybe_partly_initialized_on_exit(Variable, Point) :-
    path_maybe_initialized_on_exit(Path, Point),
    path_begins_with_var(Path, Variable).
</code></pre>
<ol start="4">
<li>计算 <strong>「移动后访问」错误</strong> ：路径<code>Path</code>在某处若未被始化，且在下一位置访问时，视位「移动后访问」的错误。</li>
</ol>
<pre><code class="language-prolog">move_error(Path, TargetPoint) :-
    path_maybe_uninitialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    path_accessed_at(Path, TargetPoint).
</code></pre>
<h2 id="输出"><a class="header" href="#输出">输出</a></h2>
<p>初始化分析之后，将输出两个信息用于后续分析</p>
<ul>
<li><code>var_maybe_partly_initialized_on_exit(Variable, Point)</code>：在<code>Point</code>处，变量<code>Variable</code>（或其部分子路径）已初始化。将用于后续「存活性分析」阶段。</li>
<li><code>move_error(Path, Point)</code>：在<code>Point</code>处，路径<code>Path</code>发生了移动后访问错误。</li>
</ul>
<h2 id="思考"><a class="header" href="#思考">思考</a></h2>
<h4 id="1--为什么需要path_maybe_uninitialized_on_exit与path_maybe_initialized_on_exit两个式子看似结论截然相反而非用一个式子统一表示呢"><a class="header" href="#1--为什么需要path_maybe_uninitialized_on_exit与path_maybe_initialized_on_exit两个式子看似结论截然相反而非用一个式子统一表示呢">1.  为什么需要<code>path_maybe_uninitialized_on_exit</code>与<code>path_maybe_initialized_on_exit</code>两个式子，看似结论截然相反，而非用一个式子统一表示呢？</a></h4>
<p>理论上是可行的，因为同一路径在同一位置不可能既被赋值又被移动。类似这样的例子</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = String::new();
a = a;
<span class="boring">} 
</span></code></pre></pre>
<p>其中第2行的<code>a = a</code>看似对<code>a</code>既赋值又移动，但到MIR层会被转化为</p>
<pre><code class="language-rust ignore">// ...
let mut _1: std::string::String;
let mut _2: std::string::String;
scope 1 {
    debug a =&gt; _1;
}

bb0: { /* ... */ }

bb1: {
    // ...
    // ...
    _2 = move _1;
    replace(_1 &lt;- move _2) -&gt; [return: bb2, unwind: bb5];
}

bb2: { /* ... */ }
// ...
</code></pre>
<p>可见，被赋值的<code>a</code>与被移动的<code>a</code>分别对应了<code>_1</code>与<code>_2</code>，实际上是先移动、再赋值。</p>
<p>如果我们引入<code>path_mustbe_initialized_on_exit(Path, Point)</code>代表在位置<code>Point</code>处，路径<code>Path</code>被完全初始化。</p>
<p>那么有</p>
<pre><code class="language-prolog">path_mustbe_initialized_on_exit(Path, Point) :-
    path_assigned_at(Path, Point).

!path_mustbe_initialized_on_exit(Path, Point) :-
    path_moved_at(Path, Point).

path_mustbe_initialized_on_exit(Path, TargetPoint) :-
    path_mustbe_initialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    !path_moved_at(Path, TargetPoint),
    !path_assigned_at(Path, TargetPoint).
</code></pre>
<p>但datalog的语法并不支持第二条推论的写法。因此，只能将<code>path_mustbe_initialized_on_exit</code>分裂为两个式子<code>path_maybe_initialized_on_exit</code>与<code>path_maybe_uninitialized_on_exit</code>，来实现相应的计算。</p>
<h4 id="2-如何理解var_maybe_partly_initialized_on_exit既然不允许在变量移动后对其部份字段赋值为何会存在半初始化的变量"><a class="header" href="#2-如何理解var_maybe_partly_initialized_on_exit既然不允许在变量移动后对其部份字段赋值为何会存在半初始化的变量">2. 如何理解<code>var_maybe_partly_initialized_on_exit</code>？既然不允许在变量移动后，对其部份字段赋值，为何会存在半初始化的变量？</a></h4>
<p>这是因为允许只移动变量的部份字段。当部份字段被移动后，剩余字段仍处于已初始化状态，因此整个变量此时处于「半初始化」的状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存活性分析liveness-analysis"><a class="header" href="#存活性分析liveness-analysis">存活性分析（Liveness Analysis）</a></h1>
<p>写于2022年1月23日。最后更新于2022年2月7日。</p>
<p>存活性分析主要计算出在MIR的各个位置处有哪些借用源（Origin）存活，用于下一阶段的借债分析。</p>
<h2 id="输入-1"><a class="header" href="#输入-1">输入</a></h2>
<h4 id="1-普通变量的定义使用丢弃情况"><a class="header" href="#1-普通变量的定义使用丢弃情况">1. 普通变量的定义、使用、丢弃情况。</a></h4>
<pre><code class="language-prolog">.decl var_defined_at(Variable, Point)
.decl var_used_at   (Variable, Point)
.decl var_dropped_at(Variable, Point)

.input var_defined_at
.input var_used_at
.input var_dropped_at
</code></pre>
<h4 id="2-对于引用变量而言需要输入变量所关联的借用源"><a class="header" href="#2-对于引用变量而言需要输入变量所关联的借用源">2. 对于引用变量而言，需要输入变量所关联的借用源。</a></h4>
<p>如下</p>
<pre><code class="language-rust ignore">let a: i32 = 0;
let b: &amp;'b i32 = &amp;a;
</code></pre>
<p>其中<code>b</code>变量将关联到借用源<code>'b</code>。</p>
<p>另外还有丢弃时关联借用源（详见<a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86drop_of_var_derefs_origin%E4%B8%8Euse_of_var_derefs_origin">思考3</a>）。</p>
<pre><code class="language-prolog">.decl drop_of_var_derefs_origin(Variable, Origin)
.decl use_of_var_derefs_origin (Variable, Origin)

.input drop_of_var_derefs_origin
.input use_of_var_derefs_origin 
</code></pre>
<h2 id="推导-2"><a class="header" href="#推导-2">推导</a></h2>
<h4 id="1-变量存活情况"><a class="header" href="#1-变量存活情况">1. 变量存活情况</a></h4>
<p>对于每一个变量，从每个 <strong>使用</strong> 的位置处，沿CFG <strong>逆边</strong> 向前追溯到变量 <strong>定义</strong> 处，都视为存活。</p>
<pre><code class="language-prolog">var_live_on_entry(Variable, Point) :-
    var_used_at(Variable, Point).

var_live_on_entry(Variable, SourcePoint) :-
    var_live_on_entry(Variable, Targetpoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined(Variable, SourcePoint).
</code></pre>
<h4 id="2-将变量的半初始化状态沿cfg传播"><a class="header" href="#2-将变量的半初始化状态沿cfg传播">2. 将变量的半初始化状态沿CFG传播。</a></h4>
<pre><code class="language-prolog">var_maybe_partly_initialized_on_entry(Variable, TargetPoint) :-
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint).
</code></pre>
<h4 id="3-变量的丢弃前存活情况"><a class="header" href="#3-变量的丢弃前存活情况">3. 变量的丢弃前存活情况</a></h4>
<p>对于每一个变量，在其 <strong>半初始化</strong> 的范围内，从每个 <strong>丢弃</strong> 处开始，沿CFG <strong>逆边</strong> 向前追溯到变量 <strong>定义</strong> 处，都视为 <strong>丢弃前存活</strong>（drop-live）。</p>
<pre><code class="language-prolog">var_drop_live_on_entry(Variable, Point) :-
    var_dropped_at(Variable, Point),
    var_maybe_partly_initialized_on_entry(Variable, Point).
</code></pre>
<pre><code class="language-prolog">var_drop_live_on_entry(Variable, SourcePoint) :-
    var_drop_live_on_entry(Variable, TargetPoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined_at(Variable SourcePoint),
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint).
</code></pre>
<h4 id="4-借用源存活状态"><a class="header" href="#4-借用源存活状态">4. 借用源存活状态</a></h4>
<p>对每处的存活引用变量，都标记其关联的借用源为存活。</p>
<pre><code class="language-prolog">origin_live_on_entry(Origin, Point) :-
    var_live_on_entry(Variable, Point),
    use_of_var_derefs_origin(Variable, Origin).
</code></pre>
<p>同样地，对于丢弃前存活的引用变量，也标记其相关联的丢弃时借用源为存活。</p>
<pre><code class="language-prolog">origin_live_on_entry(Origin, Point) :-
    var_drop_live_on_entry(Variable, Point),
    drop_of_var_derefs_origin(Variable, Origin).
</code></pre>
<h2 id="思考部份内容来自zulip的讨论"><a class="header" href="#思考部份内容来自zulip的讨论">思考（部份内容来自<a href="https://zulip-archive.rust-lang.org/stream/186049-t-compiler/wg-polonius/topic/Newcomer.2C.20trying.20to.20help.3F.html">Zulip的讨论</a>）</a></h2>
<h4 id="1-既然已经有基于路径的一些输入事实如path_assigned_atpath_accessed_atpath_moved_at等并且也有path_is_var能与变量对应起来为什么还需要基于变量的输入事实呢如var_used_atvar_dropped_atvar_defined_at等"><a class="header" href="#1-既然已经有基于路径的一些输入事实如path_assigned_atpath_accessed_atpath_moved_at等并且也有path_is_var能与变量对应起来为什么还需要基于变量的输入事实呢如var_used_atvar_dropped_atvar_defined_at等">1. 既然已经有基于路径的一些输入事实（如<code>path_assigned_at</code>、<code>path_accessed_at</code>、<code>path_moved_at</code>等），并且也有<code>path_is_var</code>能与变量对应起来，为什么还需要基于变量的输入事实呢（如<code>var_used_at</code>、<code>var_dropped_at</code>、<code>var_defined_at</code>等）？</a></h4>
<p>第一阶段的初始化分析，与具体的字段相关；而第二阶段的存活性分析与第三阶段的借债分析都只与变量相关。对存活性分析而言，变量相关的输入事实是必须的、而字段相关的输入信息是可选的，后续可能移除字段相关的输入，但变量相关的输入不会变。</p>
<p>具体的区别有：</p>
<p>(1) <code>path_assigned_at</code>与<code>var_defined_at</code></p>
<ul>
<li><code>path_assigned_at</code>与<code>var_defined_at</code>的最大区别是：
<ul>
<li>在MIR的每一条赋值语句中，<code>var_defined_at</code>一定发生在当前语句中间（<code>Mid</code>）；</li>
<li>而<code>path_assigned_at</code>可能发生在当前赋值语句中间（<code>Mid</code>），或下一条语句之前（<code>Start</code>），
<ul>
<li>若当前语句不需要<code>unwind</code>，则<code>path_assigned_at</code>在当前赋值语句中间；</li>
<li>若当前语句需要<code>unwind</code>，则<code>path_assigned_at</code>在执行成功的分支中下一条语句之前。</li>
</ul>
</li>
</ul>
</li>
<li><code>var_defined_at</code>还包含<code>StorageLive</code>与<code>StorageDead</code>信息，及变量被赋值的信息。</li>
<li><code>path_assigned_at</code>还包含进入函数时，对入参的初始化赋值。</li>
</ul>
<p>在<a href="2022-01-polonius/./01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">初始化分析</a>中，当某些函数调用发生了<code>panic</code>时，其返回值不会被初始化，因此<code>path_assigned_at</code>发生在执行成功后下一条语句之前。</p>
<p>但存活性分析及后续的借债分析，并不在意在发生<code>panic</code>后变量是否处于未初始化状态。</p>
<ul>
<li>对于<code>var_live_on_entry</code>而言，在某条赋值语句（如<code>_3 = may_panic() [return -&gt; bb1; unwind -&gt; bb2]</code>）发生<code>panic</code>后，其「清理」路径（从<code>bb2</code>开始，依次丢弃已初始化的变量）并不会使用到该变量（<code>_3</code>），也不会产生相应的<code>var_defined_at</code>事实，因此即使发生了<code>panic</code>，产生的<code>var_defined_at</code>在<code>unwind</code>过程中并不会产生<code>var_live_on_entry</code>事实，所以此处的<code>var_defined_at</code>不需要像<code>path_assigned_at</code>那样，必须发生在非<code>unwind</code>分支的入口处。</li>
<li>对于<code>var_drop_live_on_entry</code>而言，具体由于<code>unwind</code>过程中可能产生<code>var_dropped_at</code>事实，因此有可能影响到<code>var_drop_live_on_entry</code>，所以具体情况有待进一步实验验证。</li>
</ul>
<p>(2) <code>path_accessed_at</code>与<code>var_used_at</code></p>
<p><code>var_userd_at</code>等于<code>path_accessed_at</code>加上返回值的访问信息。</p>
<p>(3) <code>path_moved_at</code>与<code>var_dropped_at</code></p>
<p><code>path_moved_at</code>只能追踪到其赋值与移动。而变量在超出其作用域后，还会被丢弃，无法通过路径的移动信息推导出变量的丢弃信息。</p>
<h4 id="2-为什么var_defined_at中包含storagelive和storagedead"><a class="header" href="#2-为什么var_defined_at中包含storagelive和storagedead">2. 为什么<code>var_defined_at</code>中包含<code>StorageLive</code>和<code>StorageDead</code>？</a></h4>
<p><code>StorageLive</code>与<code>StorageDead</code>主要用于LLVM栈空间分配。见<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR相关文档</a>。</p>
<blockquote>
<p><code>StorageLive(_1)</code>表明变量<code>_1</code>存活，也即其可能在稍后使用——直到<code>StorageDead(_1)</code>语句出现，即<code>_1</code>将不再使用。<code>StorageLive</code>与<code>StoraageDead</code>语句用于LLVM中的栈空间分配。</p>
</blockquote>
<p>在<code>StorageLive</code>之后，变量才开始使用，此处的<code>var_defined_at</code>可以阻止存活性分析中的<code>var_live_on_entry</code>追溯到早于<code>StorageLive</code>的地方（因为这些地方变量未被使用到）。</p>
<p><code>StorageDead</code>不太必要，因为在<code>StorageDead</code>后，将不再可能出现变量被访问的情形。</p>
<h4 id="3-为什么要区分drop_of_var_derefs_origin与use_of_var_derefs_origin"><a class="header" href="#3-为什么要区分drop_of_var_derefs_origin与use_of_var_derefs_origin">3. 为什么要区分<code>drop_of_var_derefs_origin</code>与<code>use_of_var_derefs_origin</code>？</a></h4>
<p>由于<a href="https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html">rfc#1327</a>的缘故，变量在丢弃时的使用情况状态与正常使用时的使用情况有所不同。</p>
<p><code>drop_of_var_derefs_origin</code>的含义是，变量在丢弃时，由于其<code>drop</code>函数中可能访问其包含的引用，因此需要将其视作存活，除非显式指明<code>#[may_dangle]</code>。</p>
<p>例如：</p>
<pre><code class="language-rust ignore">fn main() {
    let mut v = [1, 2, 3];
    let p: Wrapped&lt;&amp; /* R4 */ usize&gt; = Wrapped { value: &amp;v[0] };
    if true {
        drop(*p.value);
    } else {
        v[0] += 1; //~ ERROR cannot assign to `v[_]` because it is borrowed
    }

    v[0] += 1; //~ ERROR cannot assign to `v[_]` because it is borrowed
}

struct Wrapped&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Drop for Wrapped&lt;T&gt; {
    fn drop(&amp;mut self) { }
}
</code></pre>
<p>由于在<code>Wrapped::drop</code>中可能访问到<code>value</code>字段（无显式访问，但在丢弃其字段时会隐式访问到），因此需要<code>drop_of_var_derefs_origin</code>输入事实，表明<code>p.value</code>借用的变量<code>&amp;v[0]</code>直到<code>p</code>被丢弃时（<code>main</code>函数结束前），一直处于存活状态。</p>
<p>若将<code>impl&lt;T&gt; Drop for Wrapped&lt;T&gt;</code>改为</p>
<pre><code class="language-rust ignore">unsafe impl&lt;#[may_dangle] T&gt; Drop for Wrapped&lt;T&gt; {
    fn drop(&amp;mut self) { }
}
</code></pre>
<p>则不产生<code>drop_of_var_derefs_origin</code>事实，因而后面<code>v[0] += 1</code>也视为合法。</p>
<h4 id="4-为什么var_drop_live_on_entry要包含var_maybe_partly_initialized_on_entry的信息"><a class="header" href="#4-为什么var_drop_live_on_entry要包含var_maybe_partly_initialized_on_entry的信息">4. 为什么<code>var_drop_live_on_entry</code>要包含<code>var_maybe_partly_initialized_on_entry</code>的信息？</a></h4>
<p>即使变量出作用域时已被移动，而原始的MIR中仍然包含相应的<code>drop</code>语句。Polonius引擎（包括此前的借用检查引擎）手动过滤了所有的「移动后丢弃」语句。但变量变量在部份移动后，开始处于「丢弃前存活」的状态，且部份丢弃的变量不会产生<code>var_dropped_at</code>事实，因此需要<code>var_maybe_partly_initialized_on_exit</code>来补上变量的部份移动信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借债分析loan-analysis"><a class="header" href="#借债分析loan-analysis">借债分析（Loan Analysis）</a></h1>
<p>写于2022年2月8日。</p>
<p>借用分析是根据前面计算出的借用源存活情况，推断出存在错误的借用、及存在矛盾的生命周期包含关系。</p>
<p>首先有未经优化的<a href="2022-01-polonius/./02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html">原始规则</a>，其思路较清晰，但计算量也较大。</p>
<p>然后，在<a href="2022-01-polonius/./02-19-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E8%A7%84%E5%88%99.html">位置无关规则</a>中，忽略了出错的位置信息，可以快速判断出是否有语法错误，在无误时可以提升编译速度。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借债分析原始规则naive"><a class="header" href="#借债分析原始规则naive">借债分析——原始规则（Naive）</a></h1>
<p>写于2022年2月8日。最后更新于2022年2月10日。</p>
<h2 id="推导-3"><a class="header" href="#推导-3">推导</a></h2>
<h3 id="输入传递传播借用源origin的包含关系"><a class="header" href="#输入传递传播借用源origin的包含关系">输入、传递、传播借用源（Origin）的包含关系</a></h3>
<h4 id="1-从mir输入借用源的包含关系"><a class="header" href="#1-从mir输入借用源的包含关系">1. 从MIR输入借用源的包含关系</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, Origin, Point) :-
    subset_base(SubOrigin, Origin, Point).
</code></pre>
<h4 id="2-按其传递性传递包含关系"><a class="header" href="#2-按其传递性传递包含关系">2. 按其传递性传递包含关系</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, SuperOrigin, Point) :-
    subset(SubOrigin, Origin, Point),
    subset(Origin, SuperOrigin, Point).
</code></pre>
<h4 id="3-在借用源存活的情况下沿cfg传播其包含关系"><a class="header" href="#3-在借用源存活的情况下沿cfg传播其包含关系">3. 在借用源存活的情况下，沿CFG传播其包含关系。</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, Origin, TargetPoint) :-
    subset(SubOrigin, Origin, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    origin_live_on_entry(SubOrigin, TargetPoint),
    origin_live_on_entry(Origin, TargetPoint).
</code></pre>
<h3 id="计算借债loan的存活情况"><a class="header" href="#计算借债loan的存活情况">计算借债（Loan）的存活情况</a></h3>
<p>对每一个借债，先找出其关联的借用源（即包含该借债的借用源）。</p>
<ul>
<li>从借债发生处开始，先关联借债发生处的借用源，对应规则4；</li>
<li>然后凡借债关联了某借用源，也必将关联其父借用源（即更「短命」的借用源），对应规则5；</li>
<li>再沿CFG边，传播该借债关联的所有借用源，直到借债清除时，不应关联清除的借用源，对应规则6；</li>
</ul>
<p>最后，只要借债在某处关联了任意一个存活的借用源，则视为借债在该处存活。</p>
<h4 id="4-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入"><a class="header" href="#4-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入">4. 从MIR中输入借债发生的信息，作为借债关联借用源存活信息的输入</a></h4>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, Point) :-
    loan_issued_at(Origin, Loan, Point).
</code></pre>
<h4 id="5-将借债关联借用源的信息按借用源的包含关系传播"><a class="header" href="#5-将借债关联借用源的信息按借用源的包含关系传播">5. 将借债关联借用源的信息，按借用源的包含关系传播</a></h4>
<p><strong>注意</strong>：当借债关联了子借用源（<code>SubOrigin</code>，即更「长命」的借用源）时，子借用源的所有父借用源（<code>Origin</code>，即更「短命」的借用源）也都被关联；反之不成立。</p>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, Point) :-
    origin_contains_loan_on_entry(SubOrigin, Loan, Point),
    subset(SubOrigin, Origin, Point).
</code></pre>
<h4 id="6-将借债关联借用源的信息按cfg传播"><a class="header" href="#6-将借债关联借用源的信息按cfg传播">6. 将借债关联借用源的信息按CFG传播</a></h4>
<p>传播条件为：借债关联的借用源不能在当前点被清除，且须在下一位置处存活（外部声明的生命周期始终视为存活）。</p>
<pre><code class="language-prolog">placeholder_origin(Origin) :-
    placeholder(Origin, _Loan).
</code></pre>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, TargetPoint) :-
    origin_contains_loan_on_entry(Origin, Loan, SourcePoint),
    !loan_killed_at(Loan, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    (origin_live_on_entry(Origin, TargetPoint); placeholder_origin(Origin)).
</code></pre>
<h4 id="7-借债关联的任一借用源存活时都视为借债存活"><a class="header" href="#7-借债关联的任一借用源存活时都视为借债存活">7. 借债关联的任一借用源存活时，都视为借债存活</a></h4>
<pre><code class="language-prolog">loan_live_at(Loan, Point) :-
    origin_contains_loan_on_entry(Origin, Loan, Point),
    (origin_live_on_entry(Origin, Point); placeholder_origin(Origin)).
</code></pre>
<h3 id="找出借债借用源包含关系中存在的矛盾用以报告语法错误"><a class="header" href="#找出借债借用源包含关系中存在的矛盾用以报告语法错误">找出借债、借用源包含关系中存在的矛盾，用以报告语法错误</a></h3>
<h4 id="8-当借债在某处既存活又失效时视为错误"><a class="header" href="#8-当借债在某处既存活又失效时视为错误">8. 当借债在某处既存活又失效时，视为错误</a></h4>
<pre><code class="language-prolog">errors(Loan, Point) :-
    loan_invalidated_at(Loan, Point),
    loan_live_at(Loan, Point).
</code></pre>
<h4 id="9-当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时视为错误"><a class="header" href="#9-当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时视为错误">9. 当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时，视为错误</a></h4>
<pre><code class="language-prolog">subset_error(SubOrigin, Origin, Point) :-
    subset(SubOrigin, Origin, Point),
    placeholder_origin(SubOrigin),
    placeholder_origin(Origin),
    !known_placeholder_subset(SubOrigin, Origin).
</code></pre>
<h2 id="思考-1"><a class="header" href="#思考-1">思考</a></h2>
<h4 id="1-为什么借债关联了某借用源也必将关联其父借用源更短命而不是子借用源更长命"><a class="header" href="#1-为什么借债关联了某借用源也必将关联其父借用源更短命而不是子借用源更长命">1. 为什么借债关联了某借用源，也必将关联其父借用源（更「短命」），而不是子借用源（更「长命」）？</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a: u32 = 1;
let b: &amp;u32 = &amp;a; // loan_issued_at(L0, 'a, P0)
//     ^      ^--- 'a
//     |--- subset_base('a, 'b)，即'a: 'b
<span class="boring">}
</span></code></pre></pre>
<p>如上述代码所示，由<code>load_issued_at(L0, 'a, P0)</code>可得<code>origin_contains_loan_on_entry(L0, 'a, P0)</code>。联系<a href="2022-01-polonius/./01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E9%9B%B6%EF%BC%89-%E5%8E%9F%E5%AD%90%E5%BC%8F%E4%B8%8E%E8%BE%93%E5%85%A5.html#origin">借用源Origin的定义</a>——所有引用到该Origin的Loan集合，可得<code>'a</code>为集合<code>{L0}</code>。那么根据<a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html#5-%E5%B0%86%E5%80%9F%E5%80%BA%E5%85%B3%E8%81%94%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8C%89%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%E4%BC%A0%E6%92%AD">规则5</a>，应当推导出<code>'b</code>也包含集合<code>{L0}</code>。而<code>'b</code>包含<code>L0</code>也即意味着只要<code>'b</code>存活，<code>L0</code>就存活。</p>
<p>反过来，若<code>'b</code>不包含集合<code>{L0}</code>，将意味着当<code>L0</code>不存活时，<code>'b</code>仍然有可能存活。回到代码中，要使<code>L0</code>不存活，只须修改<code>a</code>的值即可；而此时，由于<code>'b</code>仍然可能存活，即不可变引用的引用对象在其存活期间被修改，这必然不符合Rust的借用规则。</p>
<p>因此，<code>'b</code>必须包含<code>L0</code>，其他任意短命于<code>'a</code>的借用源亦如此。所以有<a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html#5-%E5%B0%86%E5%80%9F%E5%80%BA%E5%85%B3%E8%81%94%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8C%89%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%E4%BC%A0%E6%92%AD">规则5</a>的：当借债关联了某借用源时，也必将关联更短命的父借用源。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借债分析位置无关规则location-insensitive"><a class="header" href="#借债分析位置无关规则location-insensitive">借债分析——位置无关规则（Location Insensitive）</a></h1>
<p>写于2022年2月19日。</p>
<p>位置无关规则在原始规则的基础上，忽略推导过程中的位置信息及具体的借用源信息，可快速检测函数中是否有潜在错误。仅当有潜在错误时，再详细地作位置相关分析得出具体的错误信息。在源程序本身正确的情况下，牺牲位置精度以提升借用检查速度，将有益于改善编译时间。</p>
<h2 id="推导-4"><a class="header" href="#推导-4">推导</a></h2>
<h3 id="输入借用源origin的包含关系"><a class="header" href="#输入借用源origin的包含关系">输入借用源（Origin）的包含关系</a></h3>
<h4 id="1-从mir输入借用源的包含关系-1"><a class="header" href="#1-从mir输入借用源的包含关系-1">1. 从MIR输入借用源的包含关系</a></h4>
<p>相比原始规则，去掉了位置信息，因此也无需在CFG上传播。</p>
<pre><code class="language-prolog">subset(SubOrigin, Origin) :-
    subset_base(SubOrigin, Origin, _Point).
</code></pre>
<h3 id="计算借债的存活情况"><a class="header" href="#计算借债的存活情况">计算借债的存活情况</a></h3>
<h4 id="2-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入"><a class="header" href="#2-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入">2. 从MIR中输入借债发生的信息，作为借债关联借用源存活信息的输入</a></h4>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan) :-
    loan_issued_at(Origin, Loan, _Point).
</code></pre>
<h4 id="3-和原始规则一样外部借用源视为存活"><a class="header" href="#3-和原始规则一样外部借用源视为存活">3. 和原始规则一样，外部借用源视为存活</a></h4>
<pre><code class="language-prolog">placeholder_loan(Origin, Loan) :-
    placeholder(Origin, Loan).
</code></pre>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan) :-
    placeholder_loan(Origin, Loan).
</code></pre>
<h4 id="4-类似于原始规则将借债关联借用源的信息按借用源的包含关系传播"><a class="header" href="#4-类似于原始规则将借债关联借用源的信息按借用源的包含关系传播">4. 类似于原始规则，将借债关联借用源的信息，按借用源的包含关系传播</a></h4>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan) :-
    origin_contains_loan_on_entry(SubOrigin, Loan),
    subset(SubOrigin, Origin).
</code></pre>
<p>由于忽略了位置关系，因此无需再在CFG中传播。但相应地，由于缺乏借用清除（<code>loan_killed_at</code>）信息，因此借债的存活范围将被扩大。</p>
<h3 id="计算潜在错误"><a class="header" href="#计算潜在错误">计算潜在错误</a></h3>
<h4 id="5-近似的借债存活情况"><a class="header" href="#5-近似的借债存活情况">5. 近似的借债存活情况</a></h4>
<p>对于某个借债而言，若其关联到任何一个在此处存活的借用源，那么该借债视为存活。与原始规则不同，借债与借用源的关联是位置无关的，因此可能放大关联关系。</p>
<pre><code class="language-prolog">loan_live_at(Loan, Point) :-
    origin_contains_loan_on_entry(Origin, Loan),
    (origin_live_on_entry(Origin, Point); placeholder_origin(Origin)).
</code></pre>
<p>与原始规则一样，当借债在某处既存活又失效时，视为错误。由于放大了借债与借用源的关联关系，所以只能是「潜在错误」，须经过详细的位置相关分析才能得出准确的错误信息。</p>
<pre><code class="language-prolog">potential_errors(Loan, Point) :-
    loan_invalidated_at(Loan, Point),
    loan_live_at(Loan, Point).
</code></pre>
<h4 id="6-计算潜在的借用源包含错误"><a class="header" href="#6-计算潜在的借用源包含错误">6. 计算潜在的借用源包含错误</a></h4>
<p>与原始规则不同，由于借用源包含关系是位置无关的，因此不能用其精确判定包含关系是否有误。于是反其道而行之，首先推断借债关联了哪些外部借用源，这个关联关系是精确的（因为外部借用源是位置无关的）。</p>
<pre><code class="language-prolog">known_contains(Origin, Loan) :-
    placeholder(Origin, Loan).
known_contains(Origin, Loan) :-
    known_contains(SubOrigin, Loan),
    known_placeholder_subset(SubOrigin, Origin).
</code></pre>
<p>相应地，若从外部推导出的借债关联借用源的信息，与事先推得的信息比较，矛盾者视为错误。同样，由于推导出的内部借债关联借用源的信息是不精确的，所以也只能是「潜在错误」，须经过详细的位置相关分析才能得出准确的错误信息。</p>
<pre><code class="language-prolog">potential_subset_errors(SubOrigin, Origin) :-
    placeholder(SubOrigin, Loan),
    placeholder_origin(Origin),
    origin_contains_loan_on_entry(Origin, Loan),
    !known_contains(Origin, Loan).
</code></pre>
<h2 id="思考-2"><a class="header" href="#思考-2">思考</a></h2>
<h4 id="1-为什么无需按subset的传递性传递其包含关系"><a class="header" href="#1-为什么无需按subset的传递性传递其包含关系">1. 为什么无需按<code>subset</code>的传递性传递其包含关系？</a></h4>
<p>此处的<code>subset</code>是位置无关的，若按其传递性传递（即相当于无条件按CFG传播），将可能出现完全错误的包含关系（联系原始规则中<code>subset</code>按CFG传播的前提是借用源在该位置处存活）。</p>
<p>另一方面，在<a href="2022-01-polonius/02-19-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E8%A7%84%E5%88%99.html#4-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99%E5%B0%86%E5%80%9F%E5%80%BA%E5%85%B3%E8%81%94%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8C%89%E5%80%9F%E7%94%A8%E6%BA%90%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB%E4%BC%A0%E6%92%AD">规则4</a>中，借债关联借用源的信息也已按<code>subset</code>传播，实际上对<code>origin_contains_loan_on_entry</code>而言，也相当于按<code>subset</code>的传递性传递的效果。</p>
<p>况且，此处按<code>subset</code>的传递性传播，是与具体借债相关的（只有关联到同一借债的借用源，才会被按<code>subset</code>的传递性传递）。所以同样是放大了潜在错误，相比无条件按CFG传播，按借债相关的传播的放大范围无疑更小一些。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ghost-cell与staticrc的试用体验"><a class="header" href="#ghost-cell与staticrc的试用体验">Ghost Cell与StaticRC的试用体验</a></h1>
<p>写于2021年9月3日。最早发表于<a href="https://www.zhihu.com/question/482473609/answer/2101373347">知乎</a>。</p>
<hr />
<p>试用了下GhostCell<sup class="footnote-reference"><a href="#1">1</a></sup><sup class="footnote-reference"><a href="#2">2</a></sup> + StaticRc<sup class="footnote-reference"><a href="#3">3</a></sup>，用来写链表。总体感觉非常不错，很创新的一个概念，但如果能内置到编译器层面，可能使用上会更加方便。</p>
<h2 id="ghostcell-安全零开销的内部可变性机制"><a class="header" href="#ghostcell-安全零开销的内部可变性机制"><code>GhostCell</code> ——安全、零开销的内部可变性机制</a></h2>
<p><code>GhostCell</code>的思想大致是：通过一个<code>GhostToken</code>来控制一系列与之生命周期相等的<code>GhostCell</code>数据的读写行为，从而实现安全、零开销的内部可变性。</p>
<p><code>GhostCell</code>文档首页给出的一个样例可以说明其使用方法。 </p>
<pre><code class="language-rust ignore">use ghost_cell::{GhostToken, GhostCell};

let n = 42;

let value = GhostToken::new(|mut token| {
    let cell = GhostCell::new(42);

    let vec: Vec&lt;_&gt; = (0..n).map(|_| &amp;cell).collect();

    *vec[n / 2].borrow_mut(&amp;mut token) = 33;

    *cell.borrow(&amp;token)
});

assert_eq!(33, value);
</code></pre>
<p>首先通过<code>GhostToken::new</code>方法创建一个<code>token</code>，但这个<code>token</code>并非直接创建出来，而是绑定在一个局部作用域（即传入的闭包）内。</p>
<p>所有装入<code>GhostCell</code>内的值，均可通过<code>GhostCell::borrow</code>与<code>GhostCell::borrow_mut</code>两个方法来读写。这两个方法的签名分别是：</p>
<pre><code class="language-rust ignore">pub fn borrow&lt;'a&gt;(&amp;'a self, _: &amp;'a GhostToken&lt;'brand&gt;) -&gt; &amp;'a T;
pub fn borrow_mut&lt;'a&gt;(&amp;'a self, _: &amp;'a mut GhostToken&lt;'brand&gt;) -&gt; &amp;'a mut T;
</code></pre>
<p>可见，不论读写，都只需要<code>GhostCell</code>的 <strong>不可变借用</strong> ，不同的是数据读取需要<code>&amp;token</code>，而数据写入需要<code>&amp;mut token</code>。 两种借用方式借得的<code>&amp;T</code>或<code>&amp;mut T</code>生命周期与<code>cell</code>和<code>token</code>同时绑定（即函数签名中的<code>'a</code>）。 </p>
<p>由于<code>token</code>的生命周期与作用域内创建的所有<code>GhostCell</code>的生命周期都与<code>token</code>相等（<code>GhostCell&lt;'id, T&gt;</code>与<code>GhostToken&lt;'id&gt;</code>内的生命周期标识<code>'id</code>都是 <strong>不变 (invariant) ）</strong> 的，因此可以确保在<code>token</code>被借用时，或者允许多个<code>cell</code>的读取（通过<code>&amp;token</code>），或者允许单独某个<code>cell</code>写入（通过<code>&amp;mut token</code>）。 </p>
<p>回到文档中的样例：</p>
<pre><code class="language-rust ignore">    let cell = GhostCell::new(42);
    let vec: Vec&lt;_&gt; = (0..n).map(|_| &amp;cell).collect();
</code></pre>
<p>这里将同一个<code>cell</code>的只读引用复制了<code>n</code>遍放到一个数组中。如果数组未放到<code>GhostCell</code>内，就不可能在Safe Rust范围内改写数组内的元素。原本修改<code>cell</code>内的值需要可变借用<code>&amp;mut cell</code>，而引入<code>GhostCell</code>后，即使只能拿到<code>&amp;cell</code>，只需独占借用<code>&amp;mut token</code>，即可实现安全的内部可变性，类似一种「可变借用转移」的效果。</p>
<p>不同于<code>RefCell</code>的是，<code>GhostCell</code>是零开销的。<code>RefCell</code>虽然也可以通过<code>RefCell::borrow_mut(&amp;cell)</code>来实现内部可变，但其内部会记录当前值的借用状态，并在运行时检查。<code>GhostCell</code>的检查是在编译期完成的，因为<code>token</code>的读写是互斥的，所以在当前<code>token</code>的生命周期内，所有的<code>GhostCell</code>的读写都是安全的，并且是<code>Send + Sync</code>的。 </p>
<p>[<sup class="footnote-reference"><a href="#1">1</a></sup>] 中给出了GhostCell安全性的证明。 </p>
<h2 id="staticrc零开销的共享所有权机制"><a class="header" href="#staticrc零开销的共享所有权机制"><code>StaticRc</code>——零开销的共享所有权机制</a></h2>
<p><code>ghost_cell</code>库中提到了<code>static_rc</code> <sup class="footnote-reference"><a href="#3">3</a></sup> 库，实现了一种编译期检查的零开销共享所有权机制。其思想是：将<code>Box</code>的所有权分开，引入有理数（大于0，不大于1）范围意义的所有权。<code>StaticRc&lt;T, const NUM: usize, const DEN: usize&gt;</code>的所有权值为有理数<code>NUM/DEN</code>（<code>NUM &lt;= DEN</code>）。当<code>NUM/DEN</code> = 1时，代表该指针拥有完全的所有权，即等价于<code>Box</code>；当<code>NUM/DEN</code> &lt; 1时，代表与其他指针共享所有权；指同一对象的所有指针，其所有权值之和不大于<code>1</code>。</p>
<p>引入<code>split</code>与<code>join</code>两个操作。其中<code>split</code>操作将一个指针一分为二，分为两个所有权值更小的指针（二者所有权值之和等于分裂前的所有权值）；<code>join</code>操作将两个指针合二为一，合成一个新指针，其所有权值之和等于合成后指针的所有权值（不大于一）。</p>
<p>在<code>StaticRc</code>中，仅独占所有权的指针（即所有权值为1）具有完全操作所指对象的权限（读(<code>&amp;ptr</code>)、写(<code>&amp;mut ptr</code>)、消耗(<code>ptr</code>)），等同于<code>Box</code>；共享指针（即所有权值小于1）仅具有只读权限(<code>&amp;ptr</code>)。</p>
<p>该库的安全性还有待证明。我不太熟悉生命周期证明的那套理论，仅从直觉上看没有什么大问题。不过看了一下该库的实现，共享所有权指针的<code>Drop</code>是静默的，仅独占所有权的指针会被释放，这可能很容易引起内存泄露，所以我认为将<code>StaticRc</code>设计成线性类型可能更好（即至少且至多被使用一次），对共享指针而言，必须将其合倂为独占指针再释放，否则报编译错误。 </p>
<h2 id="安全零开销的链表实现尝试"><a class="header" href="#安全零开销的链表实现尝试">安全、零开销的链表实现尝试</a></h2>
<p>[<sup class="footnote-reference"><a href="#1">1</a></sup>] 中已经提出了一种基于arena的双向链表实现方式，[<sup class="footnote-reference"><a href="#4">4</a></sup>] 中还给出了一种基于<code>GhostCell</code> + <code>Arc</code>的链表实现。我认为前者更优，因为后者需要<code>Arc</code>额外开销，所以基本上不会考虑这种实现。而前者虽然无额外开销，但arena的实现可能在节点删除后不能及时的释放，所以我就尝试了如下的第三种方式。</p>
<p>考虑到（双向）链表中每个节点恰好由两个指针共享持有，因此想到可以用<code>StaticRc</code>来实现共享所有权，用<code>GhostCell</code>实现内部可变性，若<code>StaticRc</code>保持安全，便可实现安全、零开销的双向链表。</p>
<p>定义链表的数据结构如下：</p>
<pre><code class="language-rust ignore">pub struct List&lt;'id, T&gt; {
    head: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    tail: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    len: usize,
}

struct Node&lt;'id, T&gt; {
    next: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    prev: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    elem: T,
}

type NodePtr&lt;'id, T&gt; = Half&lt;GhostCell&lt;'id, Node&lt;'id, T&gt;&gt;&gt;;

type Half&lt;T&gt; = StaticRc&lt;T, 1, 2&gt;;
type Full&lt;T&gt; = StaticRc&lt;T, 2, 2&gt;;
</code></pre>
<p>其中，<code>head</code>,<code>tail</code>,<code>next</code>,<code>prev</code>都是共享所有权（1/2）的指针（<code>Half</code>），套上<code>GhostCell</code>。每个节点由一前一后两个指向其的指针共享所有权；链表首/尾节点则由<code>head</code>/<code>tail</code>指针共享另一半所有权。 <code>Half</code>指针只能拿到不可变引用，但可借助<code>GhostCell</code>实现内部可变性，看起来十分完美，于是我就写了一个简单的<code>push</code> / <code>pop</code>操作：</p>
<pre><code class="language-rust ignore">    pub fn push_back(&amp;mut self, side: usize, elem: T, token: &amp;mut GhostToken&lt;'id&gt;) {
        // 创建新节点后即一分为二。
        let (left, right) = Full::split(Full::new(GhostCell::new(Node::new(elem))));
        match self.tail.take() {
            Some(tail) =&gt; {
                // 链接其左半边指针。若当前链表为空，则链接`self.head`。
                tail.deref().borrow_mut(token).next = Some(left);
                // 将插入前的`self.tail`所有权转移至新插入节点。
                right.deref().borrow_mut(token).prev = Some(tail);
            }
            None =&gt; self.head = Some(left),
        }
        // 链接其右半边指针到新的`self.tail`。
        self.tail = Some(right);
    }
    pub fn pop_back(&amp;mut self, side: usize, token: &amp;mut GhostToken&lt;'id&gt;) -&gt; Option&lt;T&gt; {
        // 从`self.tail`取其右半边指针（若为空则返回`None`）。
        let right = self.tail.take()?;
        let left = match right.deref().borrow_mut(token).prev.take() {
            Some(tail) =&gt; {
                // 若`self.tail`的前一节点不为空，则从其`next`中取出左半边指针，
                // 否则从`self.head`取出左半边指针。
                let left = tail.deref().borrow_mut(token).next.take().unwrap();
                // 重新链接`self.tail`
                self.tail = Some(tail);
                left
            }
            None =&gt; self.head.take().unwrap(),
        };
        // 将左右指针合二为一，并返回弹出的节点元素。弹出的元素在包含`Box`内，
        // 用完后会随`Box`一起回收。
        Some(Full::into_box(Full::join(left, right)).into_inner().elem)
    }
</code></pre>
<p>至此都一切顺利，直到我想实现一个可变的迭代器。一开始按照标准的迭代器写法：</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'id, 'iter, T&gt; {
    head: Option&lt;&amp;'iter NodePtr&lt;'id, T&gt;&gt;,
    tail: Option&lt;&amp;'iter NodePtr&lt;'id, T&gt;&gt;,
    len: usize,
    token: &amp;'iter mut GhostToken&lt;'id&gt;,
}

impl&lt;'id, 'iter, T&gt; Iterator for IterMut&lt;'id, 'iter, T&gt; {
    type Item = &amp;'iter mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let current = self.head?;
        self.head = current.deref().borrow(self.token).next;
        self.len -= 1;
        // 编译错误：token先被不可变借用，后被可变借用，且借用周期都等于`'iter`。
        Some(&amp;current.deref().borrow_mut(self.token).elem)
    }
}
</code></pre>
<p>结果未能通过借用检查规则。原因很简单，遍历时获取每个节点的<code>next</code>指针需要不可变借用<code>token</code>，而返回节点中元素的可变引用，则需要可变借用<code>token</code>，且借出的<code>token</code>周期均为<code>'iter</code>（即整个迭代器的生命周期），自然不可能通过借用检查。</p>
<p>后来又另辟溪径，参考[<sup class="footnote-reference"><a href="#4">4</a></sup>]中的一个迭代器实现，他的可变迭代并不像一般的设计模式那样返回一个迭代器结构，而是直接采用类似<code>Iterator::for_each</code>的方式，在闭包内完成可变借用，从而把可变借出的生命周期缩短。</p>
<p>于是我也实现了一个<code>for_each_mut</code>的接口：</p>
<pre><code class="language-rust ignore">    pub fn for_each_mut(&amp;self, token: &amp;mut GhostToken&lt;'id&gt;, mut f: impl FnMut(&amp;mut T)) {
        let mut current = self.head.as_ref();
        while let Some(node) = current {
            let node = node.deref().borrow_mut(token);
            f(&amp;mut node.elem);
            current = node.deref().next.as_ref();
        }
    }
</code></pre>
<p>不幸地是，虽然看起来这个函数中只有一次<code>borrow_mut</code>，且只在循环体内，应该会在单次循环后归还。但由于每次获得<code>next</code>指针时依赖于上一次的借用，该借用的生命周期硬生生地被从循环体内拉长到了循环体外。 因此出现了如下的编译错误</p>
<pre><code class="language-plaintext">error[E0499]: cannot borrow `*token` as mutable more than once at a time
   --&gt; src/experiments.rs:182:48
    |
182 |             let node = node.deref().borrow_mut(token);
    |                                                ^^^^^ `*token` was mutably borrowed here in the previous iteration of the loop
</code></pre>
<p>基于arena或<code>Arc</code>的实现则不存在这一问题。基于<code>arena</code>的实现中，所有的<code>next</code>或<code>prev</code>都是引用，且有单独的生命周期，因此在迭代时不存在需要借用才能拿到<code>next</code>的情况； 基于<code>Arc</code>的实现中，共享指针<code>Arc</code>可以在运行时复制一份指针，因此也不需要通过借用来获取<code>next</code>指针。而<code>StaticRc</code>并不支持在运行时临时新增一份引用，只能通过<code>split</code>的方式将其原有的半份所有权分裂开来。这种方式不仅涉及<code>next</code>字段的修改（需要用<code>Option::take</code>将整个<code>Half</code>指针按值的方式取出来，才能调用<code>split</code>），且在所有权一分为二后，又存在合井困难的问题（因为<code>next</code>指针的值仍然借用于分裂后的指针，会阻止分裂指针合井）。</p>
<p>结论：该方案（<code>StaticRc</code> + <code>GhostCell</code>）在描述定义链表，或操作链表中的单个节点时虽能胜任安全零开销的实现。但对链表作遍历或其他更复杂的操作时，需要将链表的结构可变性与数据可变性作进一步分离，才能实现全功能的安全零开销链表。</p>
<hr />
<p>总之，我比较看好<code>GhostCell</code>的思想，将大有可能改进下一个Rust Edition中的借用检查的体验（就像2015的Lexical Lifetime到Non-Lexical Lifetime的改进一样）， 进一步平衡安全、性能、易用的三角。</p>
<p><code>GhostCell</code>的不足之处：写起来比较繁琐，会需要多写不少的<code>GhostToken::new</code>、<code>GhostCell::new</code>、<code>borrow(token)</code>、<code>borrow_mut(token)</code>之类的代码。如果能集成到编译器内，通过更简洁的语法书写，使用体验会好很多。</p>
<p>拭目以待。</p>
<hr />
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf">http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://docs.rs/ghost-cell/0.2.2/ghost_cell/">https://docs.rs/ghost-cell/0.2.2/ghost_cell/</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://docs.rs/static-rc/0.4.1/static_rc/">https://docs.rs/static-rc/0.4.1/static_rc/</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://gitlab.mpi-sws.org/FP/ghostcell/-/blob/master/ghostcell/examples/dlist_arc.rs">https://gitlab.mpi-sws.org/FP/ghostcell/-/blob/master/ghostcell/examples/dlist_arc.rs</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门系列"><a class="header" href="#rust过程宏入门系列">Rust过程宏入门系列</a></h1>
<p>写于2022年1月15日。</p>
<hr />
<p>本系列文章写于2021年1月，最早于知乎发表。当时正初学Rust，选取了看起来比较有意思的过程宏入手。与之前学过的C++宏的预处理文本替换机制不同，Rust的过程宏提供了在AST（抽象语法树）层次上操作源代码的方式，自由度较高。但局限是也仅限于AST层次，无法获得类型信息。因此过程宏也仅仅只是一种生成代码的方式，但不能成为元编程的手段。</p>
<p>由于过程宏在后来的编程实践中很少用到，因此本系列很可能再也不会更新了。但无论如何，本文用到的<a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>仓库都可以作为很好的过程宏入门资料。</p>
<p>附知乎原文链接：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/342408254">Rust过程宏入门（一）——过程宏简介</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/342664529">Rust过程宏入门（二）——初探派生宏</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/343170504">Rust过程宏入门（三）——实现简易派生宏</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/344701514">Rust过程宏入门（四）——遍历结构体字段</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门一过程宏简介"><a class="header" href="#rust过程宏入门一过程宏简介">Rust过程宏入门（一）——过程宏简介</a></h1>
<p>写于2021年1月6日。最早发表于<a href="https://zhuanlan.zhihu.com/p/342408254">知乎</a>。</p>
<h2 id="什么是宏"><a class="header" href="#什么是宏">什么是宏？</a></h2>
<p>熟悉C/C++的朋友应该很熟悉 <strong>宏（Macro）</strong> 的概念，而Rust初学者也必定会接触到Rust中的宏，其Hello world程序中就会用到<code>println!</code>宏。</p>
<p>可以简单地理解为： <strong>宏即编译时将执行的一系列指令</strong>。其重点在于「编译时」，尽管宏与函数（或方法）形似，函数是在运行时发生调用的，而宏是在编译时执行的。</p>
<p>不同于C/C++中的宏，Rust的宏并非简单的文本替换，而是在词法层面甚至语法树层面作替换，其功能更加强大，也更加安全。</p>
<p>如下所示的一个C++的宏SQR的定义</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#define SQR(x) (x * x)
int main() {
    std::cout &lt;&lt; SQR(1 + 1) &lt;&lt; std::endl;
    return 0;
} 
</code></pre>
<p>我们希望它输出<code>4</code>，但很遗憾它将输出<code>3</code>，因为<code>SQR(1 + 1)</code>在预编译阶段通过文本替换展开将得到<code>(1 + 1 * 1 + 1)</code>，并非我们所期望的语义。</p>
<p>而在Rust中，按如下方式定义的宏：</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! sqr {
    ($x:expr) =&gt; {$x * $x}
}

fn main() {
    println!(&quot;{}&quot;, sqr!(1 + 1));
}
</code></pre></pre>
<p>将得到正确的答案<code>4</code>。这是因为Rust的宏展开发生在语法分析阶段，此时编译器知道<code>sqr!</code>宏中的<code>$x</code>变量是一个表达式（用<code>$x:expr</code>标记），所以在展开后它知道如何正确处理，会将其展开为<code>((1 + 1) * (1 + 1))</code>。</p>
<p>由于本文介绍的重点是过程宏，因此涉及普通宏的内容便不多赘述，有兴趣者可参考<a href="https://doc.rust-lang.org/rust-by-example/macros.html">官方文档</a>上的介绍。</p>
<h2 id="什么是过程宏"><a class="header" href="#什么是过程宏">什么是过程宏？</a></h2>
<p><strong>过程宏（Procedure Macro）</strong> 是Rust中的一种特殊形式的宏，它将提供比普通宏更强大的功能。方便起见，本文将Rust中由<code>macro_rules!</code>定义的宏称为 <strong>声明宏</strong> 以示区分。</p>
<p>过程宏分为三种：</p>
<ul>
<li>派生宏（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。</li>
<li>属性宏（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。如标准库中的<code>#[inline]</code>、<code>#[derive(...)]</code>等都是属性宏。</li>
<li>函数式宏（Function-like macro）：用法与普通的声明宏类似，但功能更加强大，可实现任意语法树层面的转换功能。</li>
</ul>
<h2 id="过程宏的定义与使用方法"><a class="header" href="#过程宏的定义与使用方法">过程宏的定义与使用方法</a></h2>
<h3 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h3>
<p>派生宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>其使用方法如下：</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Command {
    // ...
}
</code></pre>
<h3 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h3>
<p>属性宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
fn sorted(args: TokenStream, input: TokenStream) -&gt; TokenStream {
    let _ = args;
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>使用方法如下：</p>
<pre><code class="language-rust ignore">#[sorted]
enum Letter {
    A,
    B,
    C,
    // ...
}
</code></pre>
<h3 id="函数式宏"><a class="header" href="#函数式宏">函数式宏</a></h3>
<p>函数式宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn seq(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>使用方法如下：</p>
<pre><code class="language-rust ignore">seq! { n in 0..10 {
    /* ... */
}}
</code></pre>
<h2 id="过程宏的原理"><a class="header" href="#过程宏的原理">过程宏的原理</a></h2>
<p>以上三种过程宏的定义方法已全部介绍。可以发现，它的定义方式与普通函数无异，只不过其函数调用发生在编译阶段而已。下面以较为常见的派生宏为例，介绍过程宏的原理。</p>
<p>回顾刚才的定义：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>首先，<code>#[proc_macro_derive(Builder)]</code>表明<code>derive_builder</code>是一个派生宏，<code>Builder</code>表示它将作用的地方。比如定义如下结构体</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Command {
    // ...
}
</code></pre>
<p>就会触发以上派生宏执行。至于其中的<code>Builder</code>具体代表什么含义，本期暂不展开，后面再详细介绍。</p>
<p><code>fn derive_builder(input: TokenStream) -&gt; TokenStream</code>函数头部表明该函数将接受一个<code>TokenStream</code>对象作为输入，并返回一个<code>TokenStream</code>对象。</p>
<p>要理解<code>TokenStream</code>，需要一些简单的编译原理知识。编译器在编译一段程序时，会首先将输入的文本转换成一系列的Token（标识符、关键字、符号、字面量等），同时忽略注释（文档注释除外）与空白字符等。</p>
<p>例如<code>println!(&quot;Hello world&quot;);</code>这句代码将被转换成标识符<code>println</code> 、叹号<code>!</code> 、圆括号<code>(</code> 、字面量<code>&quot;Hello world&quot;</code> 、圆括号<code>)</code> 、分号<code>;</code>几个Token。</p>
<p><code>TokenStream</code>顾名思义，是Rust中对一系列连续的Token的抽象。在宏展开的过程中，遇到派生宏时，会将整个结构体（或<code>enum</code>、<code>union</code>）展开成<code>TokenStream</code>作为派生宏函数的输入，然后将其输出的<code>TokenStream</code>附加到结构体后面，再继续作语法分析。</p>
<hr />
<p>本期的介绍到此结束，主要介绍了过程宏的基本概念、定义及使用方法、实现原理。接下来将通过几个具体实例详细介绍Rust过程宏的编程方法。</p>
<p>实例来源自GitHub上的仓库： <a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门二初探派生宏"><a class="header" href="#rust过程宏入门二初探派生宏">Rust过程宏入门（二）——初探派生宏</a></h1>
<p>写于2021年1月7日。最早发表于<a href="https://zhuanlan.zhihu.com/p/342664529">知乎</a>。</p>
<h2 id="认识派生宏手动实现生成代码"><a class="header" href="#认识派生宏手动实现生成代码">认识派生宏，手动实现生成代码</a></h2>
<p>我们将从一个<a href="https://link.zhihu.com/?target=https%3A//github.com/whjpji/proc-macro-workshop%23derive-macro-derivebuilder">简单的案例</a>开始，设计一个Builder模式的派生宏。</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .arg(&quot;build&quot;.to_owned())
        .arg(&quot;--release&quot;.to_owned())
        .build()
        .unwrap();

    assert_eq!(command.executable, &quot;cargo&quot;);
}
</code></pre>
<p>上述代码展示了我们希望呈现给用户的使用方式，即用户只需定义一个结构体（若结构体实现了成员函数或trait，下文中也称之为「类」），则派生宏将为其自动生成Builder类。</p>
<h2 id="command类实现"><a class="header" href="#command类实现">Command类实现</a></h2>
<p>首先从Builder类的使用方式入手，若欲手动实现Builder类，那么它大概会像这样：</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder {
            executable: None,
            args: Vec::new(),
            current_dir: None
        }
    }
}

pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
</code></pre>
<p>其中，<code>impl Command</code>为<code>Command</code>结构体添加了<code>builder</code>成员函数，将返回一个<code>CommandBuilder</code>结构体， 并设置其成员变量的初始量。注意这里的<code>builder</code>不带任何参数（在C++、Java等语言中又称为静态函数或静态方法）。 </p>
<p>而<code>CommandBuilder</code>结构体中的成员变量与<code>Command</code>基本一致，只是<code>executable</code>字段的类型由<code>String</code>变成了<code>Option&lt;String&gt;</code>，这是因为在刚创建<code>CommandBuilder</code>类时，<code>executable</code>的值未知，所以只好利用Rust自带的可选类型<code>Option&lt;T&gt;</code>，其定义很简单：</p>
<pre><code class="language-rust ignore">pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>虽然在不少语言中（如C/C++、Java等）都有枚举类型的概念，但对不熟悉Rust的朋友或Rust初学者而言，这里有必要指出：Rust的枚举类型与其他语言稍有不同，除了包含枚举标签以外，它还可以额外附带任意值。例如<code>Option&lt;T&gt;</code>类型中，有「有值（<code>Some</code>）」与「无值（<code>None</code>）」两种状态，而处于「有值」的状态时，还附带一个T类型（即泛型参数）的值，这便很好地表示了可选类型。</p>
<h2 id="commandbuilder类及实现"><a class="header" href="#commandbuilder类及实现">CommandBuilder类及实现</a></h2>
<p>接下来，为<code>CommandBuilder</code>结构体实现相应的函数： </p>
<pre><code class="language-rust ignore">impl CommandBuilder {
    pub fn executable(mut self, executable: String) -&gt; Self {
        self.executable = Some(executable);
        self
    }
    pub fn arg(mut self, arg: String) -&gt; Self {
        self.args.push(arg);
        self
    }
    pub fn current_dir(mut self, current_dir: String) -&gt; Self {
        self.current_dir = Some(current_dir);
        self
    }
    pub fn build(self) -&gt; Result&lt;Command, String&gt; {
        let executable = self.executable.ok_or(
            &quot;executable required, but not set&quot;.to_owned())?;
        let args = self.args;
        let current_dir = self.current_dir;
        Ok(Command { executable, args, current_dir })
    }
}
</code></pre>
<p>其中，<code>executable</code>、<code>arg</code>、<code>current_dir</code>函数分别对应三个字段的设置函数。其第一个参数<code>mut self</code>代表结构体自身（由于rust中的变量默认是不可变的，所以要修改<code>self</code>，需要加上<code>mut</code>。第二个参数是相应字段的值，最后返回结构体自身（这里用到了自身类型别名<code>Self</code>，须注意它与自身变量别名<code>self</code>是不同的）。</p>
<p>最后的<code>build</code>函数则是返回所希望构建的<code>Command</code>类。由于最终构建<code>Command</code>类时，可能有必填字段未设置（如<code>executable</code>是必须设置的），此时不能构造一个有效的<code>Command</code>类，且需将此错误信息告知调用者。</p>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>说到这里，不得不提及Rust独特的错误处理机制。C语言中常通过返回非零值代表错误；C++、Java、Python语言中通常会中断当前函数执行并抛出异常信息交予调用者处理。而Rust得益于其特有的枚举类型，将错误信息直接返回调用者，且通常调用者无法直接忽略错误。Rust标准库中定义了<code>Result&lt;T, E&gt;</code>类型如下：</p>
<pre><code class="language-rust ignore">pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>该类型有「正常（<code>Ok</code>）」与「错误（<code>Err</code>）」两种状态，因此调用者要么立即处理错误信息，要么将其向上传播。 不过<code>Result&lt;T, E&gt;</code>类中也提供了一个<code>unwarp</code>方法，可以直接取其正常状态的值。但若返回的是错误状态，调用<code>unwarp</code>会触发<code>panic!</code>并打印该错误信息。</p>
<p>若忘记设置<code>executable</code>的值，运行时将输出如下错误信息。 </p>
<pre><code class="language-plaintext">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;executable required, but not set&quot;' 
</code></pre>
<hr />
<p>本期的介绍到此结束，主要以较为常见的Builder模式为例，介绍了如何手动实现其主要功能，接下将逐步介绍如何通过Rust过程宏自动实现上述代码。</p>
<p>实例来源自GitHub上的仓库： <a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门三实现简易派生宏"><a class="header" href="#rust过程宏入门三实现简易派生宏">Rust过程宏入门（三）——实现简易派生宏</a></h1>
<p>写于2021年1月10日。最早发表于<a href="https://zhuanlan.zhihu.com/p/343170504">知乎</a>。</p>
<h2 id="再谈派生宏的原理"><a class="header" href="#再谈派生宏的原理">再谈派生宏的原理</a></h2>
<p>简单起见，我们先假定<code>Command</code>结构体中只有必填单选项，无选填或多选项，简化后的<code>Command</code>类如下：</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
</code></pre>
<p>首先实现<code>Command</code>类中的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}

pub struct CommandBuilder;
</code></pre>
<p>为此派生宏创建一个crate，注意需要在<code>Cargo.toml</code>中加上</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>以表示该crate将编译为一个过程宏库。
回顾一下派生宏的定义方式，我们需要根据输入的<code>TokenStream</code>生成目标<code>TokenStream</code>。 </p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>编译器会将派生宏作用的结构体（或<code>enum</code>、<code>union</code>）展开成<code>TokenStream</code>作为函数参数传入。不出意料的话，展开后的<code>TokenStream</code>会由如下几项构成：</p>
<blockquote>
<p>关键字<code>pub</code> 关键字<code>struct</code> 标识符<code>Command</code> 花括号<code>{</code></p>
<p>标识符<code>executable</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>标识符<code>args</code> 冒号<code>:</code> 标识符<code>Vec</code> 小于号<code>&lt;</code> 标识符<code>String</code> 大于号<code>&gt;</code> 逗号<code>,</code> </p>
<p>标识符<code>current_dir</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>花括号<code>}</code></p>
</blockquote>
<p>我们需要用到的Token有：结构体名标识符<code>Command</code>，每个字段的名字标识符与类型的Token串。其他信息只起结构标记的作用，无需用到。</p>
<p>应当如何提取这些信息呢？</p>
<p>一种方法是利用<code>TokenStream</code>类的<code>to_string</code>函数，将这些Token转换为字符串，然后再用字符串处理的手段提取其中的信息。但这就有一个问题：编译器好不容易将源代码文件中的文本信息（也即字符串），转换成了语法树，在此处展开成<code>TokenStream</code>以调用过程宏处理，但我们反而再次将<code>TokenStream</code>转换为原始的字符串，岂不多此一举？</p>
<p>另一种方法是使用<a href="https://docs.rs/syn/1.0.58/syn/index.html">syn库</a>。syn库提供了表示语法解析结果（一般为语法树上的某一节点）的一系列类。</p>
<p>若要使用syn库，需要在项目的<code>Cargo.toml</code>文件中指定：</p>
<pre><code class="language-toml">[dependencies]
syn = &quot;1.0&quot; 
</code></pre>
<h2 id="认识deriveinput"><a class="header" href="#认识deriveinput">认识DeriveInput</a></h2>
<p>由于派生宏的使用场景相对固定（目前只能作用于<code>struct</code>、<code>enum</code>、<code>union</code>），syn库中已提供了派生宏输入项的封装——<code>DeriveInput</code>。其结构如下：</p>
<pre><code class="language-rust ignore">pub struct DeriveInput {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
} 
</code></pre>
<p>其中<code>ident</code>字段正是我们所需的结构体名的标识符。结合<code>parse_macro_input!</code>宏，容易将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    unimplemented!()
}
</code></pre>
<p>若以<code>#ident</code>指代结构体名<code>Command</code>，那么我们已经可以实现一个简易版的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl #ident {
    pub fn builder() -&gt; #identBuilder {
<span class="boring">        identBuilder
</span>    }
}

pub struct #identBuilder;
</code></pre>
<p>当然上述代码中的<code>#identBuilder</code>是有问题的，这里暂时跳过。</p>
<h2 id="用quote宏生成tokenstream"><a class="header" href="#用quote宏生成tokenstream">用<code>quote!</code>宏生成<code>TokenStream</code></a></h2>
<p>如何生成这段代码呢？不难想到，可以直接用字符串拼接的方法再转换成<code>TokenStream</code>输出，但这会让编译器再多一层词法分析的步骤，且不易阅读与扩展。（字符串格式化的占位符是<code>{}</code>，当输入代码篇幅较大时，占位符与实际传入参数相隔很远，且不便于一一对应。）</p>
<p>另一种方法是用<a href="https://docs.rs/quote/1.0.8/quote/index.html">quote库</a>，同样需在<code>Cargo.toml</code>后面加上<code>quote = &quot;1.0&quot;</code>的依赖。</p>
<p>quote库中的<code>quote!</code>宏提供了将Rust语法项展开为<code>TokenStream</code>的功能， 包含在<code>quote!</code>宏中的任何Rust代码都将展开为<code>TokenStream</code>，而以<code>#</code>开头的标识符将引用前文中已定义的标识符，而非像字符串格式化那样使用<code>{}</code>并在末尾传入参数的方式。这便是笔者在上文中用<code>#ident</code>指代<code>Command</code>类名的原因。</p>
<p>需要注意的是，与syn库搭配的<code>TokenStream</code>来自<a href="https://docs.rs/proc-macro2/1.0.24/proc_macro2/struct.TokenStream.html">proc_macro2库</a>， 其别名为<code>TokenStream2</code>，需要用<code>.into()</code>方法转换为<code>TokenStream</code>才能作为过程宏函数的返回值。</p>
<p>用<code>quote!</code>宏包含<code>Command::builder</code>函数的实现部分，得：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = /* 暂时跳过 */;
    quote!(
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder::default()
</span>            }
        }
        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<h2 id="拼接标识符"><a class="header" href="#拼接标识符">拼接标识符</a></h2>
<p>最后回到<code>CommandBuilder</code>标识符的问题。刚才提到，<code>Command</code>标识符可由<code>DeriveInput</code>直接获取，但<code>CommandBuilder</code>的标识符却需要手动拼接生成。</p>
<p>笔者联想到C++中的宏定义中有<code>##</code>运算符可用于拼接标识符，譬如<code>#define CONCAT(a, b) a##b</code>，<code>CONCAT(foo, bar)</code>就会得到一个<code>foobar</code>的标识符，想必Rust应当也有类似的宏，于是搜索Rust标准库发现果然有一个名为<code>concat_idents!</code>的宏，然后这样写：</p>
<pre><code class="language-rust ignore">pub struct concat_idents!(#ident, Builder);
</code></pre>
<p>但尝试未果，总是会报出类似<code>error: expected `where`, `{`, `(`, or `;` after struct name, found `!` </code>的错误。后来才发现Rust中并不支持在标识符位置的宏调用（详见<a href="https://github.com/rust-lang/rust/issues/4365">rust-lang/rust#4365 · Macros don't get expanded when used in item name token position</a>）。编译器会将<code>concat_idents</code>当作<code>struct</code>的名字标识符 ，然后并不知道如何处理这个叹号<code>!</code>Token， 故而只能报编译错误。</p>
<p>几经周折，最终还是选择了手动拼接构造标识符，因为标识符位置不可用宏，所以一切基于宏的办法都失效了，总不至于退回到原始的字符串拼接的方式吧？</p>
<p>所幸syn库中的<code>Ident</code>类有由字符串新建实例的构造函数<code>new</code>，但观察其构造函数</p>
<pre><code class="language-rust ignore">pub fn new(string: &amp;str, span: Span) -&gt; Ident
</code></pre>
<p>发现，除了传入一个字符串以外，还需要一个<code>Span</code>对象。<code>Ident</code>类中的<a href="https://docs.rs/syn/1.0.58/syn/struct.Ident.html">文档示例代码</a>是传入了一个<code>Span::call_cite()</code>，如：</p>
<pre><code class="language-rust ignore">let ident = Ident::new(&quot;demo&quot;, Span::call_site());
let temp_ident = Ident::new(&amp;format!(&quot;new_{}&quot;, ident), Span::call_site());     
</code></pre>
<p>文档中对Span::call_cite()的解释是：</p>
<blockquote>
<p>identifiers created with this span will be resolved as if they were written directly at the location of the macro call, and other code at the macro call site will be able to refer to them as well. </p>
</blockquote>
<p>大致意思是，标识符的<code>span</code>会解析为宏调用的地方。如何理解「<code>span</code>」的含义呢？在<code>Span</code>的文档中有定义：</p>
<blockquote>
<p>A region of source code, along with macro expansion information.</p>
</blockquote>
<p>即<code>Span</code>代表了源代码的某一区间，并携带了宏展开的信息。也就是说，<code>Ident::new()</code>中传入的<code>Span</code>是用来定位标识符的位置的。而<code>CommandBuilder</code>标识符是与<code>Command</code>相关联的，不妨将其<code>span</code>设置为<code>Command</code>标识符的区间就好。 因此有：</p>
<pre><code class="language-rust ignore">let ident = input.ident;
let ident_builder = Ident::new(&amp;format!(&quot;{}Buidler&quot;, ident), ident.span());
</code></pre>
<h2 id="利用cargo-expand命令检验代码生成结果"><a class="header" href="#利用cargo-expand命令检验代码生成结果">利用<code>cargo expand</code>命令检验代码生成结果</a></h2>
<p>将前面的代码全部综合到一起，得：</p>
<pre><code class="language-rust ignore">use proc_macro::TokenStream;

use quote::quote;
use syn::{parse_macro_input, DeriveInput, Ident};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = Ident::new(&amp;format!(&quot;{}Builder&quot;, ident), ident.span());
    quote! (
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder
</span>            }
        }

        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<p>最后我们用<code>cargo expand</code>命令来检验生成的代码。这里要指出的是，使用过程宏须与定义过程中处在不同的crate中。</p>
<pre><code class="language-rust ignore">use derive_builder::Builder;

#[allow(dead_code)] // 忽略警告
#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}

fn main() {}
</code></pre>
<p>展开后将得到：</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use derive_builder::Builder;
#[allow(dead_code)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}
pub struct CommandBuilder;
fn main() {}
</code></pre>
<p>正是所期望的结果。</p>
<hr />
<p>本期的介绍到此为止，主要介绍了如何将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>，提取其中的名字信息，使用<code>Ident</code>类提供的构造函数拼接成新的标识符，最后用<code>quote!</code>宏生成目标代码的<code>TokenStream</code>。 接下来将继续介绍用派生宏实现<code>CommandBuilder</code>类的字段生成、函数实现等功能。 </p>
<p>本文中的代码实现详见 <a href="https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder">https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder</a>。</p>
<p>其中，测试用的<code>main.rs</code>代码见<a href="https://github.com/frank-king/proc-macro-workshop/blob/example/builder/01-parse.rs/main.rs"><code>example/builder/01-parse.rs</code>中的<code>main.rs</code>文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门四遍历结构体字段"><a class="header" href="#rust过程宏入门四遍历结构体字段">Rust过程宏入门（四）——遍历结构体字段</a></h1>
<p>写于2021年1月16日。最早发表于<a href="https://zhuanlan.zhihu.com/p/344701514">知乎</a>。</p>
<h2 id="简单回顾"><a class="header" href="#简单回顾">简单回顾</a></h2>
<p>在上一章中的简单案例中，</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
</code></pre>
<p>我们已经为<code>Command</code>结构体生成了如下代码</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}

pub struct CommandBuilder; 
</code></pre>
<p>接下来，自然是补齐<code>CommandBuilder</code>结构体的字段和成员函数，使其成为一个真正可用的类。</p>
<p>首先是<code>CommandBuilder</code>类的字段，相对比较简单，只需要引用原结构体的字段名，并在其字段类型外面套上<code>Option&lt;&gt;</code>即可。</p>
<h2 id="获取结构体中的字段信息"><a class="header" href="#获取结构体中的字段信息">获取结构体中的字段信息</a></h2>
<p>如何获取原结构体的字段信息呢？这就需要用到上一章介绍的<code>DeriveInput</code>了：</p>
<pre><code class="language-rust ignore">pub struct DeriveInput {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
} 
</code></pre>
<p>其中的<code>data: Data</code>就是具体的结构体（或<code>enum</code>、<code>union</code>）信息。我们看<a href="https://docs.rs/syn/1.0.58/syn/enum.Data.html"><code>Data</code>的定义</a>，它也是一个<code>enum</code>：</p>
<pre><code class="language-rust ignore">pub enum Data {
    Struct(DataStruct),
    Enum(DataEnum),
    Union(DataUnion),
}
</code></pre>
<p>可见，这里的Data确实是支持<code>struct</code>、<code>enum</code>、<code>union</code>三种结构的，但我们的<code>Builder</code>宏只支持<code>struct</code>，所以先忽略另外两个。 我们看<a href="https://docs.rs/syn/1.0.58/syn/struct.DataStruct.html"><code>DataStruct</code>的定义</a>： </p>
<pre><code class="language-rust ignore">pub struct DataStruct {
    pub struct_token: Struct,
    pub fields: Fields,
    pub semi_token: Option&lt;Semi&gt;,
}
</code></pre>
<p>它包含了一个<code>struct</code>的Token，一些字段<code>Fields</code>，以及一个可选的分号<code>;</code>Token。继续看<a href="https://docs.rs/syn/1.0.58/syn/enum.Fields.html"><code>Fields</code>的定义</a>：</p>
<pre><code class="language-rust ignore">pub enum Fields {
    Named(FieldsNamed),
    Unnamed(FieldsUnnamed),
    Unit,
}
</code></pre>
<p>也是一个<code>enum</code>。这是由于结构体中的字段有具名和匿名（类似元组Tuple）两种写法，还有一种不含任何字段的空结构体<code>Fields::Unit</code>。<code>Fields</code>类有一个<code>iter</code>函数</p>
<pre><code class="language-rust ignore">impl Fields {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, Field&gt; { /*...*/ }
}
</code></pre>
<p>可以生成其字段的迭代器，我们再看Field的定义：</p>
<pre><code class="language-rust ignore">pub struct Field {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Option&lt;Ident&gt;,
    pub colon_token: Option&lt;Colon&gt;,
    pub ty: Type,
} 
</code></pre>
<p>终于找到了我们所需要的信息！其中的<code>ident: Option&lt;Ident&gt;</code>即是可选的字段名（但由于我们的<code>Builder</code>类只支持具名结构体，所以字段名是必须的），<code>ty: Type</code>即为类型信息。</p>
<h2 id="遍历结构体字段"><a class="header" href="#遍历结构体字段">遍历结构体字段</a></h2>
<p>要遍历结构体的字段，首先需要将字段提取出来。前面已经介绍了<code>DeriveInput</code>相关的结构，那么我们需要做的就是用<code>match</code>或<code>if let</code>的方式过滤出需要的信息。</p>
<p>设计只考虑具名的<code>struct</code>类型，因此用<code>if let</code>匹配单个分支即可：</p>
<pre><code class="language-rust ignore">if let Data::Struct(r#struct) = input.data {
    let fields = r#struct.fields;
    if matches!(&amp;fields, Fields::Named(_)) {
        todo!()
    }
} 
</code></pre>
<p>在<code>todo!()</code>处则已经拿到了<code>fields: Fields</code>，且它是具名的。至于不用<code>if let</code>取出<code>Fields::Named(_)</code>实体的原因是：即使用<code>Named(FieldsNamed)</code>提取出的<code>Field</code>结构体中的<code>ident: Option&lt;Ident&gt;</code>也需要<code>.unwrap()</code>之后才能取出<code>Ident</code>，所以此处用原来的<code>fields: Fields</code>即可。</p>
<p>现在用我们将<code>Fields</code>映射为<code>TokenStream2</code>，以便嵌入最终生成的代码中。 </p>
<pre><code class="language-rust ignore">let builder_fields = TokenStream2::from_iter(
    fields
        .iter() // 1
        .map(|field: &amp;Field| (field.ident.as_ref().unwrap(), &amp;field.ty)) // 2
        .map(|(ident: &amp;Ident, ty: &amp;Type)| quote!(#ident: Option&lt;#ty&gt;, )), // 3
);
</code></pre>
<ul>
<li><code>// 1</code>处的<code>fields.iter()</code>产生了<code>&amp;Field</code>的迭代器，由于<code>fields</code>可能被多次使用，所以用只读迭代器，而非按值传递将其消耗；</li>
<li><code>// 2</code>处的<code>.map(...)</code>提取出<code>Field</code>中的标识符<code>&amp;Ident</code>与类型<code>&amp;Type</code>（由于前面保证了结构体字段是具名的，此处直接调用<code>Option::unwrap</code>即可）；</li>
<li><code>// 3</code>处的<code>.map(...)</code>根据提取出的<code>ident</code>和<code>ty</code>生成<code>#ident: Option&lt;#ty&gt;,</code>的<code>TokenStream</code>，注意不要漏掉末尾的Token。</li>
</ul>
<p>最后，<code>TokenStream2::from_iter</code>函数将以上的多个<code>TokenStream2</code>串联在一起。对<code>Command</code>类而言，将生成</p>
<pre><code class="language-rust ignore">executable: Option&lt;String&gt;,
args: Option&lt;Vec&lt;String&gt;,
current_dir: Option&lt;String&gt;, 
</code></pre>
<p>只需要将上述生成的字段嵌入<code>CommandBuilder</code>结构体中，一个带字段的<code>CommandBuilder</code>结构体便生成好了：</p>
<pre><code class="language-rust ignore">quote! {
    pub struct CommandBuilder {
<span class="boring">        builder_fields
</span>    }
}
</code></pre>
<p>在为<code>CommandBuilder</code>类添加字段后，<code>Command::builder</code>函数中生成<code>CommandBuilder</code>的默认实例还未添加字段初始值，这里简单起见，我们用<code>#[derive(Default)]</code>派生宏自动为<code>CommandBuilder</code>类实现<code>Default</code> Trait，从而可以调用该Trait的<code>default()</code>函数生成其默认实例。</p>
<pre><code class="language-rust ignore">quote! {
    impl Command {
        pub fn builder() -&gt; CommandBuilder {
            CommandBuilder::default()
        }
    }

    #[derive(Default)]
    pub struct CommandBuilder {
<span class="boring">        builder_fields
</span>    }
}
</code></pre>
<h2 id="成员函数的生成"><a class="header" href="#成员函数的生成">成员函数的生成</a></h2>
<p>接下来，将为<code>CommandBuilder</code>添加字段的设置函数。以<code>executable</code>参数为例，期望通过以下函数设置其值：</p>
<pre><code class="language-rust ignore">impl CommandBuilder {
    pub fn executable(mut self, value: String) -&gt; Self {
        self.executable = Some(executable);
        self
    }
}  
</code></pre>
<p>这里的<code>self</code>选择传值是因为希望<code>CommandBuilder</code>类用完即毁，将其中所存的值直接转移到最终创建的<code>Command</code>实例中，避免复制开销。返回一个<code>Self</code>对象是为了实现链式调用。
显然，生成成员函数时也涉及原结构体字段的遍历，因此我们重用<code>builder_fields</code>的生成函数，将其写成一个通用函数：</p>
<pre><code class="language-rust ignore">fn map_fields&lt;F&gt;(fields: &amp;Fields, mapper: F) -&gt; TokenStream2
where
    F: FnMut((&amp;Ident, &amp;Type)) -&gt; TokenStream2,
{
    TokenStream2::from_iter(
        fields
            .iter()
            .map(|field| (field.ident.as_ref().unwrap(), &amp;field.ty))
            .map(mapper),
    )
}
</code></pre>
<p>因此即可用不同的映射函数或闭包以生成不同的<code>TokenStream</code>了。</p>
<p>首先是设置字段的成员函数，相对较简单：</p>
<pre><code class="language-rust ignore">let builder_set_fields = map_fields(&amp;fields, |(ident: &amp;Field, ty: &amp;Type)| {
    quote!(pub fn #ident(mut self, value: #ty) -&gt; Self {
        self.#ident = Some(value);
        self
    })
});
</code></pre>
<p>基本上就是将前面手写的<code>executable</code>函数中的字段名和类型替换成统一的<code>#ident</code>和<code>#ty</code>即可，非常方便。</p>
<p>最后是<code>CommandBuilder::build</code>函数，它将消耗自身，并生成一个Result&lt;Command, String&gt;实例。当所有字段都已设置时，返回正常的<code>Command</code>对象，否则返回错误信息（这里简单起见，暂时用<code>String</code>）。</p>
<p><code>build</code>函数可以分为两部分：第一部分是依次取出由<code>Option&lt;&gt;</code>包装过的<code>CommandBuilder</code>类中的各个字段的值，第二部分是生成目标<code>Command</code>实例。</p>
<p>先看第一部分，直接遍历原结构体中的字段即可：</p>
<pre><code class="language-rust ignore">let build_lets = map_fields(&amp;fields, |(ident, _)| { // 忽略用不到的ty
    quote!(
        let #ident = self.#ident.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(#ident),
        ))?;
    )
});
</code></pre>
<p>这里用到了<code>Option::ok_or</code>方法，当其为<code>None</code>时，返回一个错误值，然后用?运算符取出其中正确的值（若出现错误值，则直接将错误值返回上层）。</p>
<p>取出了构造结构体所需要的各字段值后，第二部分就变得相对简单了，直接返回一个<code>Ok(Command{ executable, args, current_dir, })</code>即可。外层的字段名再用一次结构体字段遍历可得：</p>
<pre><code class="language-rust ignore">let build_values = map_fields(&amp;fields, |(ident, _)| quote!(#ident,));      
</code></pre>
<p>注意不要漏掉逗号<code>,</code>。</p>
<p>最后将代码全部合到一起：</p>
<pre><code class="language-rust ignore">fn map_fields&lt;F&gt;(fields: &amp;Fields, mapper: F) -&gt; TokenStream2
where
    F: FnMut((&amp;Ident, &amp;Type)) -&gt; TokenStream2,
{
    TokenStream2::from_iter(
        fields
            .iter()
            .map(|field| (field.ident.as_ref().unwrap(), &amp;field.ty))
            .map(mapper),
    )
}

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = Ident::new(&amp;format!(&quot;{}Builder&quot;, ident), ident.span());
    if let Data::Struct(r#struct) = input.data {
        let fields = r#struct.fields;
        if matches!(&amp;fields, Fields::Named(_)) {
            let builder_fields = map_fields(&amp;fields, |(ident, ty)| quote!(#ident: Option&lt;#ty&gt;, ));
            let builder_set_fields = map_fields(&amp;fields, |(ident, ty)| {
                quote!(pub fn #ident(mut self, value: #ty) -&gt; Self {
                    self.#ident = Some(value);
                    self
                })
            });
            let build_lets = map_fields(&amp;fields, |(ident, _)| {
                quote!(
                    let #ident = self.#ident.ok_or(format!(
                        &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
                        stringify!(#ident),
                    ))?;
                )
            });
            let build_values = map_fields(&amp;fields, |(ident, _)| quote!(#ident,));
            quote!(
                impl #ident {
                    pub fn builder() -&gt; #ident_builder {
<span class="boring">                        ident_builder::default()
</span>                    }
                }

                #[derive(Default)]
                pub struct #ident_builder {
<span class="boring">                    builder_fields
</span>                }

                impl #ident_builder {
<span class="boring">                    builder_set_fields
</span>
                    pub fn build(self) -&gt; Result&lt;#ident, String&gt; {
<span class="boring">                        build_lets
</span>                        Ok(#ident { #build_values })
                    }
                }
            )
            .into()
        }
    }
    quote!().into()
}
</code></pre>
<h2 id="输出tokenstream2以检验生成结果"><a class="header" href="#输出tokenstream2以检验生成结果">输出<code>TokenStream2</code>以检验生成结果</a></h2>
<p>上一章中讲到可以用<code>cargo expand</code>命令来检验代码生成结果。但由于本文中用到了<code>#[defive(Default)</code>派生宏以及<code>format!</code>规则宏等，若用<code>cargo expand</code>命令展开，会有一些不相干的信息，代码会很繁琐。但实际上除了<code>cargo expand</code>之后，还可以直接输出<code>TokenStream2</code>来检验生成结果。</p>
<p>方法很简单，直接将<code>quote!</code>宏生成出的<code>TokenStream2</code>用<code>eprintln!</code>宏输出即可（<code>eprintln!</code>的用法与<code>println!</code>相似，只不过是输出到标准错误<code>stderr</code>中）：</p>
<pre><code class="language-rust ignore">let tokens = quote!( /* ... */ );
eprintln!(&quot;{}&quot;, tokens); 
</code></pre>
<p>输出后的代码未经格式化，我们可以手动复制到一个空白文件然后使用<code>rustfmt</code>程序格式化，得</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder::default()
    }
}
#[derive(Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}
impl CommandBuilder {
    pub fn executable(mut self, value: String) -&gt; Self {
        self.executable = Some(value);
        self
    }
    pub fn args(mut self, value: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(value);
        self
    }
    pub fn current_dir(mut self, value: String) -&gt; Self {
        self.current_dir = Some(value);
        self
    }
    pub fn build(self) -&gt; Result&lt;Command, String&gt; {
        let executable = self.executable.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(executable),
        ))?;
        let args = self.args.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(args),
        ))?;
        let current_dir = self.current_dir.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(current_dir),
        ))?;
        Ok(Command {
            executable,
            args,
            current_dir,
        })
    }
}
</code></pre>
<p>这种方法在调用派生宏中出现编译错误时尤其有用，不仅可以用来检验整体代码片段，也可以随时查看某一小片段，便于调试。</p>
<h2 id="功能验证"><a class="header" href="#功能验证">功能验证</a></h2>
<p>最后，为了验证派生宏的功能正确，将编译运行以下程序：</p>
<pre><code class="language-rust ignore">use derive_builder::Builder;

#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();

    assert_eq!(command.executable, &quot;cargo&quot;);
    assert_eq!(command.args, &amp;[&quot;build&quot;, &quot;--release&quot;]);
    assert_eq!(command.current_dir, &quot;..&quot;);
}
</code></pre>
<p>程序将正常执行结束，无任何输出。</p>
<hr />
<p>本期的介绍到此为止，主要介绍了如何遍历<code>Command</code>结构体中的字段信息，并生成<code>CommandBuilder</code>类的字段与成员函数，实现了一个最简单可用的<code>Builder</code>类。接下来将继续如何处理原结构体中的可选、多选字段等功能。 </p>
<p>本文中的代码实现详见 <a href="https://github.com/frank-king/proc-macro-workshop/tree/example/builder/05-method-chaining.rs/builder%E2%80%8B">https://github.com/frank-king/proc-macro-workshop/tree/example/builder/05-method-chaining.rs/builder​</a>。</p>
<p>其中，测试用的<code>main.rs</code>代码见<a href="https://github.com/frank-king/proc-macro-workshop/blob/example/builder/05-method-chaining.rs/main.rs"><code>example/builder/05-method-chaining.rs</code>中的<code>main.rs</code>文件</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        <script src="https://utteranc.es/client.js"
                repo="frank-king/rustblog-zh"
                issue-term="title"
                theme="github-dark"
                crossorigin="anonymous"
                async>
        </script>

    </body>
</html>
