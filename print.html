<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust中文博客</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html">序言</a></li><li class="chapter-item expanded affix "><li class="part-title">2022-01</li><li class="chapter-item expanded "><a href="2022-01-polonius/00.html">Polonius学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022-01-polonius/01-21-借用检查（零）-原子式与输入.html">（零）原子式与输入</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/01-21-借用检查（一）-初始化分析.html">（一）初始化分析</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/01-23-借用检查（二）-存活性分析.html">（二）存活性分析</a></li><li class="chapter-item expanded "><a href="2022-01-polonius/02-08-借用检查（三）-借债分析.html">（三）借债分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022-01-polonius/02-08-借用检查（三）-借债分析-原始规则.html">(1) 原始规则</a></li><li class="chapter-item expanded "><div>(2) 位置无关规则</div></li><li class="chapter-item expanded "><div>(3) 优化规则</div></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">2021-09</li><li class="chapter-item expanded "><a href="2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li><li class="chapter-item expanded affix "><li class="part-title">2021-01</li><li class="chapter-item expanded "><a href="2021-01-proc-macro/00.html">Rust过程宏入门系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-06-过程宏（一）-过程宏简介.html">（一）过程宏简介</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html">（二）初探派生宏</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-10-过程宏（三）-实现简易派生宏.html">（三）实现简易派生宏</a></li><li class="chapter-item expanded "><a href="2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html">（四）遍历结构体字段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust中文博客</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/frank-king/rustblog-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="序言"><a class="header" href="#序言">序言</a></h1>
<p>本博客将不定期更新一些Rust相关的学习心得与开发体验，更新频率可能不会很高。文章按月组织，例序排列。</p>
<h1 id="2022-01"><a class="header" href="#2022-01">2022-01</a></h1>
<ul>
<li><a href="2022-01-polonius/00.html">Polonius学习笔记</a>
<ul>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E9%9B%B6%EF%BC%89-%E5%8E%9F%E5%AD%90%E5%BC%8F%E4%B8%8E%E8%BE%93%E5%85%A5.html">（零）原子式与输入</a></li>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">（一）初始化分析</a></li>
<li><a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html">（二）存活性分析</a></li>
<li><a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90.html">（三）借债分析</a>
<ul>
<li><a href="2022-01-polonius/02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html">(1) 原始规则</a></li>
<li><a href="">(2) 位置无关规则</a></li>
<li><a href="">(3) 优化规则</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2021-09"><a class="header" href="#2021-09">2021-09</a></h1>
<ul>
<li><a href="2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li>
</ul>
<h1 id="2021-01"><a class="header" href="#2021-01">2021-01</a></h1>
<ul>
<li><a href="2021-01-proc-macro/00.html">Rust过程宏入门系列</a>
<ul>
<li><a href="2021-01-proc-macro/01-06-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E8%BF%87%E7%A8%8B%E5%AE%8F%E7%AE%80%E4%BB%8B.html">（一）过程宏简介</a></li>
<li><a href="2021-01-proc-macro/01-07-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%88%9D%E6%8E%A2%E6%B4%BE%E7%94%9F%E5%AE%8F.html">（二）初探派生宏</a></li>
<li><a href="2021-01-proc-macro/01-10-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%B4%BE%E7%94%9F%E5%AE%8F.html">（三）实现简易派生宏</a></li>
<li><a href="2021-01-proc-macro/01-16-%E8%BF%87%E7%A8%8B%E5%AE%8F%EF%BC%88%E5%9B%9B%EF%BC%89-%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5.html">（四）遍历结构体字段</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polonius学习笔记"><a class="header" href="#polonius学习笔记">Polonius学习笔记</a></h1>
<p>写于2022年1月21日。</p>
<p>Polonius是一个推理引擎，基于MIR层输入的控制流图、变量信息、借用信息、生存期约束信息，推导出程序中是否有语句违反Rust对于借用的约定规则，以便编译器报告语法错误，并尽可能向用户提供有帮助的改进建议。</p>
<h2 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h2>
<p>Polonius的输入信息，通过<a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E9%9B%B6%EF%BC%89-%E5%8E%9F%E5%AD%90%E5%BC%8F%E4%B8%8E%E8%BE%93%E5%85%A5.html">「原子式（Atom）」与「输入事实（AllFacts）」</a>两个概念来表达。原子式是输入信息的概念分类，而输入事实是一系列给定的真命题。</p>
<p>Polonius引擎则基于这些真命题，按照一系列的分析规则，推导出矛盾（即错误）信息，再返回给编译器以报告编译错误。（无矛盾信息生成时，视为借用检查通过，将不会产生编译错误。）</p>
<h2 id="分析流程"><a class="header" href="#分析流程">分析流程</a></h2>
<ol>
<li><a href="2022-01-polonius/01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">初始化分析</a>：计算MIR各个位置（Point）处变量（Variable）的初始化、逆初始化（被移动）的状态，与该处发生「移动后访问」错误的路径（Path）（若有）。</li>
<li><a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html">存活性分析</a>：计算MIR各个位置（Point）处，分别有哪些借用源（Origin）存活。</li>
<li>借用检查分析：计算MIR各个位置（Point）处，存在矛盾（存活且失效）的借用（Loan）；并计算在哪些位置（Point）处，产生了与外部定义的生存期约束（SubOrigin, Origin）相矛盾的约束。前者用于报告违反借用规则的错误，后者用于报告可能存在悬垂引用的错误。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原子式与输入"><a class="header" href="#原子式与输入">原子式与输入</a></h1>
<p>写于2022年1月21日。</p>
<h2 id="原子式atom"><a class="header" href="#原子式atom">原子式（Atom）</a></h2>
<p>原子式即分析过程中用到的输入信息的分类。</p>
<h3 id="variable"><a class="header" href="#variable"><code>Variable</code></a></h3>
<p>由用户定义的变量。如<code>let x, y;</code>中的<code>x</code>、<code>y</code>。</p>
<h3 id="path"><a class="header" href="#path"><code>Path</code></a></h3>
<p>结构体、元组、数组等变量的字段访问路径。如<code>a.b</code>、<code>x.y.z.0</code>、<code>s[0]</code>等（数组不区分不同下标）。</p>
<h3 id="point"><a class="header" href="#point"><code>Point</code></a></h3>
<p>控制流图（Control-flow Graph，CFG）中的某个语句。每条语句被拆成Start和Mid两个节点，</p>
<ul>
<li><code>Start</code>：执行该语句前；</li>
<li><code>Mid</code>：执行该语句时。</li>
</ul>
<h3 id="loan"><a class="header" href="#loan"><code>Loan</code></a></h3>
<p>借债，对应Rust中的借用（borrow）概念。如<code>let y = &amp;x;</code>中的<code>&amp;x</code>。</p>
<h3 id="origin"><a class="header" href="#origin"><code>Origin</code></a></h3>
<p>借用源，对应Rust中的生存期（lifetime）概念。如<code>let x: &amp;'a i32;</code>中的<code>'a</code>。</p>
<p><code>Origin</code>应理解为「所有引用到该<code>Origin</code>的<code>Loan</code>集合」。</p>
<h2 id="输入事实allfacts"><a class="header" href="#输入事实allfacts">输入事实（<code>AllFacts</code>）</a></h2>
<p>输入来源于MIR。主要包含CFG的执行到达关系图；变量的赋值、移动、访问情况；借债的发生、清除、失效信息；因借用产生、或外部定义的笁存期及其约束条件等信息。</p>
<h3 id="cfg_edge"><a class="header" href="#cfg_edge"><code>cfg_edge</code></a></h3>
<p><code>cfg_edge(SourcePoint, TargetPoint)</code>，一条控制流图的边，表示<code>SourcePoint</code>的下一条执行点为<code>TargetPoint</code>。</p>
<h3 id="loan_issued_at"><a class="header" href="#loan_issued_at"><code>loan_issued_at</code></a></h3>
<p><code>loan_issued_at(Origin, Loan, Point)</code>表示在位置<code>Point</code>处发生了借债<code>Loan</code>，其生存期为<code>Origin</code>。</p>
<h3 id="placeholder与universal_region"><a class="header" href="#placeholder与universal_region"><code>placeholder</code>（与<code>universal_region</code>）</a></h3>
<p><code>placeholder(Origin, Loan)</code>表示外部定义的生存期（如<code>fn max&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str</code>中的<code>'a</code>，及期关联的<code>Loan</code>。这些生存期也是函数签名的一部份。另外，由于它的<code>Loan</code>对借债检查而言是未知的，不能作任何假设，因此称之为「占位符」（placeholder）。</p>
<p><code>universal_region(Origin)</code>与<code>placeholder</code>类似，单指由函数签名定义的生存期，不带具体的<code>Loan</code>。</p>
<h3 id="loan_killed_at"><a class="header" href="#loan_killed_at"><code>loan_killed_at</code></a></h3>
<p><code>loan_killed_at(Loan, Point)</code>指某个借债<code>Loan</code>在位置<code>Point</code>处被清除。表明该借债<code>Loan</code>对应的路径<code>Path</code>在<code>Point</code>处被赋值或覆写。</p>
<p>例如</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
let mut q = &amp;mut a;
let r = &amp;mut *q; // `Loan` L0，此处借用了`*q`
// `q` 不能再使用，只能通过`r`访问
q = &amp;mut b; // L0被清除
// 此后，`q`与`r`可以继续使用
<span class="boring">}
</span></code></pre></pre>
<p><code>q</code>再次赋值后，Loan <code>L0</code> 被清除。Rustc在进入借用检查之前会将这样的关系计算好，保存在<code>loan_killed_at</code>中。之后，在<a href="2022-01-polonius/./02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90.html">借债分析</a>时，<code>loan_killed_at</code>中的<code>Point</code>将阻止相应的<code>Loan</code>在CFG中传播。</p>
<h3 id="subset_base"><a class="header" href="#subset_base"><code>subset_base</code></a></h3>
<p><code>subset_base(SubOrigin, Origin, Point)</code>表示，在位置<code>Point</code>处，有一条<code>SubOrigin: Origin</code>的约束（即<code>SubOrigin</code>应当长存于（outlives）<code>Origin</code>。</p>
<h3 id="loan_invalidated_at"><a class="header" href="#loan_invalidated_at"><code>loan_invalidated_at</code></a></h3>
<p><code>loan_invalidated_at(Point, Loan)</code>表明在<code>Point</code>处失效。</p>
<p>借用有共享（shared）与可变（mutable）两种。共享借用只能用于读取，不能写入或修改；可变借用必须独占，保证不能有对同一Path的借用。否则，视为借用失效，失效的借债将保存在<code>loan_invalidated_at</code>关系中。</p>
<h3 id="known_placeholder_subset"><a class="header" href="#known_placeholder_subset"><code>known_placeholder_subset</code></a></h3>
<p><code>known_placeholder_subset(SubOrigin, Origin)</code>用于表示函数签名处定义的生存期约束。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化分析"><a class="header" href="#初始化分析">初始化分析</a></h1>
<p>写于2022年1月21日。</p>
<p>初始化分析主要计算出经传递后的<code>Path</code>读写、移动之处，变量的初始化、移动情况，并找出因移动而导致的错误（即试图访问被移动或部分移动的变量）。</p>
<h2 id="1-将路径的读写移动情况传递至其子路径"><a class="header" href="#1-将路径的读写移动情况传递至其子路径">1. 将路径的读写、移动情况传递至其子路径</a></h2>
<p>所有路径（除入参外）在刚进入函数体内时，均视为已移动。</p>
<h3 id="输入"><a class="header" href="#输入">输入</a></h3>
<pre><code class="language-prolog">path_moved_at   (Path, Point) :- path_moved_at_base   (Path, Point).
path_assigned_at(Path, Point) :- path_assigned_at_base(Path, Point).
path_accessed_at(Path, Point) :- path_accessed_at_base(Path, Point).

ancestor_path(ParentPath, ChildPath) :- child_path(ChildPath, ParentPath).

path_begin_with_var(Path, Variable) :- path_is_var(Path, Variable).
</code></pre>
<p>其中，<code>path_begin_with_var</code>代表某个<code>Path</code>是否属于某个变量（含递归），如<code>a.b</code>、<code>a.b.c</code>都属于变量<code>a</code>。</p>
<h3 id="推导"><a class="header" href="#推导">推导</a></h3>
<ol>
<li>传递<code>ancestor_path</code>。</li>
</ol>
<pre><code class="language-prolog">ancestor_path(GrandparentPath, ChildPath) :-
    ancestor_path(ParentPath, ChildPath),
    child_path(ParentPath, GrandparentPath).
</code></pre>
<ol start="2">
<li>移动、赋值、访问某一路径<code>ParentPath</code>时，也将移动、赋值、访问其子路径<code>ChildPath</code>。</li>
</ol>
<pre><code class="language-prolog">path_moved_at(ChildPath, Point) :-
    path_moved_at(ParentPath, Point),
    ancestor_path(ParentPath, ChildPath).

path_assigned_at(ChildPath, point) :-
    path_assigned_at(ParentPath, point),
    ancestor_path(ParentPath, ChildPath).

path_accessed_at(ChildPath, point) :-
    path_accessed_at(ParentPath, point),
    ancestor_path(ParentPath, ChildPath).
</code></pre>
<ol start="3">
<li>若某个路径<code>Path</code>属于某个变量<code>Variable</code>时，其子路径也属于该变量。</li>
</ol>
<pre><code class="language-prolog">path_begins_with_var(Child, Variable) :-
    path_begins_with_var(Parent, Variable)
    ancestor_path(Parent, Child).
</code></pre>
<h2 id="2-计算变量初始化情况并求解移动造成的错误"><a class="header" href="#2-计算变量初始化情况并求解移动造成的错误">2. 计算变量初始化情况，并求解移动造成的错误</a></h2>
<h3 id="推导-1"><a class="header" href="#推导-1">推导</a></h3>
<ol>
<li>对于每一个路径，从每个 <strong>赋值</strong> 处开始，沿CFG边向后追溯直到该路径被 <strong>移动</strong> 时，该路径都视为 <strong>已初始化</strong> 状态。</li>
</ol>
<pre><code class="language-prolog">path_maybe_initialized_on_exit(Path, Point) :-s
    path_assigned_at(Path, Point).

path_maybe_initialized_on_exit(Path, TargetPoint) :-
    path_maybe_initialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    !path_moved_at(Path, TargetPoint).
</code></pre>
<ol start="2">
<li>对于每一个路径，从每个 <strong>移动</strong> 处开始，沿CFG边向后追溯直到该路径被 <strong>赋值</strong> 时，该路径都视为 <strong>未初始化</strong> 状态。</li>
</ol>
<pre><code class="language-prolog">path_maybe_uninitialized_on_exit(Path, Point) :-
    path_moved_at(Path, Point).

path_maybe_uninitialized_on_exit(Path, TargetPoint) :-
    path_maybe_uninitialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint)
    !path_assigned_at(Path, TargetPoint).
</code></pre>
<ol start="3">
<li>已初始化的路径，其对应的变量视为（半）初始化状态。</li>
</ol>
<pre><code class="language-prolog">var_maybe_partly_initialized_on_exit(Variable, Point) :-
    path_maybe_initialized_on_exit(Path, Point),
    path_begins_with_var(Path, Variable).
</code></pre>
<ol start="4">
<li>计算 <strong>「移动后访问」错误</strong> ：路径<code>Path</code>在某处若未被始化，且在下一位置访问时，视位「移动后访问」的错误。</li>
</ol>
<pre><code class="language-prolog">move_error(Path, TargetPoint) :-
    path_maybe_uninitialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    path_accessed_at(Path, TargetPoint).
</code></pre>
<h2 id="输出"><a class="header" href="#输出">输出</a></h2>
<p>初始化分析之后，将输出两个信息用于后续分析</p>
<ul>
<li><code>var_maybe_partly_initialized_on_exit(Variable, Point)</code>：在<code>Point</code>处，变量<code>Variable</code>（或其部分子路径）已初始化。将用于后续「存活性分析」阶段。</li>
<li><code>move_error(Path, Point)</code>：在<code>Point</code>处，路径<code>Path</code>发生了移动后访问错误。</li>
</ul>
<h2 id="思考"><a class="header" href="#思考">思考</a></h2>
<h4 id="1--为什么需要path_maybe_uninitialized_on_exit与path_maybe_initialized_on_exit两个式子看似结论截然相反而非用一个式子统一表示呢"><a class="header" href="#1--为什么需要path_maybe_uninitialized_on_exit与path_maybe_initialized_on_exit两个式子看似结论截然相反而非用一个式子统一表示呢">1.  为什么需要<code>path_maybe_uninitialized_on_exit</code>与<code>path_maybe_initialized_on_exit</code>两个式子，看似结论截然相反，而非用一个式子统一表示呢？</a></h4>
<p>理论上是可行的，因为同一路径在同一位置不可能既被赋值又被移动。类似这样的例子</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = String::new();
a = a;
<span class="boring">} 
</span></code></pre></pre>
<p>其中第2行的<code>a = a</code>看似对<code>a</code>既赋值又移动，但到MIR层会被转化为</p>
<pre><code class="language-rust ignore">// ...
let mut _1: std::string::String;
let mut _2: std::string::String;
scope 1 {
    debug a =&gt; _1;
}

bb0: { /* ... */ }

bb1: {
    // ...
    // ...
    _2 = move _1;
    replace(_1 &lt;- move _2) -&gt; [return: bb2, unwind: bb5];
}

bb2: { /* ... */ }
// ...
</code></pre>
<p>可见，被赋值的<code>a</code>与被移动的<code>a</code>分别对应了<code>_1</code>与<code>_2</code>，实际上是先移动、再赋值。</p>
<p>如果我们引入<code>path_mustbe_initialized_on_exit(Path, Point)</code>代表在位置<code>Point</code>处，路径<code>Path</code>被完全初始化。</p>
<p>那么有</p>
<pre><code class="language-prolog">path_mustbe_initialized_on_exit(Path, Point) :-
    path_assigned_at(Path, Point).

!path_mustbe_initialized_on_exit(Path, Point) :-
    path_moved_at(Path, Point).

path_mustbe_initialized_on_exit(Path, TargetPoint) :-
    path_mustbe_initialized_on_exit(Path, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    !path_moved_at(Path, TargetPoint),
    !path_assigned_at(Path, TargetPoint).
</code></pre>
<p>但datalog的语法并不支持第二条推论的写法。因此，只能将<code>path_mustbe_initialized_on_exit</code>分裂为两个式子<code>path_maybe_initialized_on_exit</code>与<code>path_maybe_uninitialized_on_exit</code>，来实现相应的计算。</p>
<h4 id="2-如何理解var_maybe_partly_initialized_on_exit既然不允许在变量移动后对其部份字段赋值为何会存在半初始化的变量"><a class="header" href="#2-如何理解var_maybe_partly_initialized_on_exit既然不允许在变量移动后对其部份字段赋值为何会存在半初始化的变量">2. 如何理解<code>var_maybe_partly_initialized_on_exit</code>？既然不允许在变量移动后，对其部份字段赋值，为何会存在半初始化的变量？</a></h4>
<p>这是因为允许只移动变量的部份字段。当部份字段被移动后，剩余字段仍处于已初始化状态，因此整个变量此时处于「半初始化」的状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存活性分析"><a class="header" href="#存活性分析">存活性分析</a></h1>
<p>写于2022年1月23日。最后更新于2022年2月7日。</p>
<p>存活性分析主要计算出在MIR的各个位置处有哪些借用源（Origin）存活，用于下一阶段的借债分析。</p>
<h2 id="输入-1"><a class="header" href="#输入-1">输入</a></h2>
<h4 id="1-普通变量的定义使用丢弃情况"><a class="header" href="#1-普通变量的定义使用丢弃情况">1. 普通变量的定义、使用、丢弃情况。</a></h4>
<pre><code class="language-prolog">.decl var_defined_at(Variable, Point)
.decl var_used_at   (Variable, Point)
.decl var_dropped_at(Variable, Point)

.input var_defined_at
.input var_used_at
.input var_dropped_at
</code></pre>
<h4 id="2-对于引用变量而言需要输入变量所关联的借用源"><a class="header" href="#2-对于引用变量而言需要输入变量所关联的借用源">2. 对于引用变量而言，需要输入变量所关联的借用源。</a></h4>
<p>如下</p>
<pre><code class="language-rust ignore">let a: i32 = 0;
let b: &amp;'b i32 = &amp;a;
</code></pre>
<p>其中<code>b</code>变量将关联到借用源<code>'b</code>。</p>
<p>另外还有丢弃时关联借用源（详见<a href="2022-01-polonius/01-23-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AD%98%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90.html#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86drop_of_var_derefs_origin%E4%B8%8Euse_of_var_derefs_origin">思考3</a>）。</p>
<pre><code class="language-prolog">.decl drop_of_var_derefs_origin(Variable, Origin)
.decl use_of_var_derefs_origin (Variable, Origin)

.input drop_of_var_derefs_origin
.input use_of_var_derefs_origin 
</code></pre>
<h2 id="推导-2"><a class="header" href="#推导-2">推导</a></h2>
<h4 id="1-变量存活情况"><a class="header" href="#1-变量存活情况">1. 变量存活情况</a></h4>
<p>对于每一个变量，从每个 <strong>使用</strong> 的位置处，沿CFG <strong>逆边</strong> 向前追溯到变量 <strong>定义</strong> 处，都视为存活。</p>
<pre><code class="language-prolog">var_live_on_entry(Variable, Point) :-
    var_used_at(Variable, Point).

var_live_on_entry(Variable, SourcePoint) :-
    var_live_on_entry(Variable, Targetpoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined(Variable, SourcePoint).
</code></pre>
<h4 id="2-将变量的半初始化状态沿cfg传播"><a class="header" href="#2-将变量的半初始化状态沿cfg传播">2. 将变量的半初始化状态沿CFG传播。</a></h4>
<pre><code class="language-prolog">var_maybe_partly_initialized_on_entry(Variable, TargetPoint) :-
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint).
</code></pre>
<h4 id="3-变量的丢弃前存活情况"><a class="header" href="#3-变量的丢弃前存活情况">3. 变量的丢弃前存活情况</a></h4>
<p>对于每一个变量，在其 <strong>半初始化</strong> 的范围内，从每个 <strong>丢弃</strong> 处开始，沿CFG <strong>逆边</strong> 向前追溯到变量 <strong>定义</strong> 处，都视为 <strong>丢弃前存活</strong>（drop-live）。</p>
<pre><code class="language-prolog">var_drop_live_on_entry(Variable, Point) :-
    var_dropped_at(Variable, Point),
    var_maybe_partly_initialized_on_entry(Variable, Point).
</code></pre>
<pre><code class="language-prolog">var_drop_live_on_entry(Variable, SourcePoint) :-
    var_drop_live_on_entry(Variable, TargetPoint),
    cfg_edge(SourcePoint, TargetPoint),
    !var_defined_at(Variable SourcePoint),
    var_maybe_partly_initialized_on_exit(Variable, SourcePoint).
</code></pre>
<h4 id="4-借用源存活状态"><a class="header" href="#4-借用源存活状态">4. 借用源存活状态</a></h4>
<p>对每处的存活引用变量，都标记其关联的借用源为存活。</p>
<pre><code class="language-prolog">origin_live_on_entry(Origin, Point) :-
    var_live_on_entry(Variable, Point),
    use_of_var_derefs_origin(Variable, Origin).
</code></pre>
<p>同样地，对于丢弃前存活的引用变量，也标记其相关联的丢弃时借用源为存活。</p>
<pre><code class="language-prolog">origin_live_on_entry(Origin, Point) :-
    var_drop_live_on_entry(Variable, Point),
    drop_of_var_derefs_origin(Variable, Origin).
</code></pre>
<h2 id="思考部份内容来自zulip的讨论"><a class="header" href="#思考部份内容来自zulip的讨论">思考（部份内容来自<a href="https://zulip-archive.rust-lang.org/stream/186049-t-compiler/wg-polonius/topic/Newcomer.2C.20trying.20to.20help.3F.html">Zulip的讨论</a>）</a></h2>
<h4 id="1-既然已经有基于路径的一些输入事实如path_assigned_atpath_accessed_atpath_moved_at等并且也有path_is_var能与变量对应起来为什么还需要基于变量的输入事实呢如var_used_atvar_dropped_atvar_defined_at等"><a class="header" href="#1-既然已经有基于路径的一些输入事实如path_assigned_atpath_accessed_atpath_moved_at等并且也有path_is_var能与变量对应起来为什么还需要基于变量的输入事实呢如var_used_atvar_dropped_atvar_defined_at等">1. 既然已经有基于路径的一些输入事实（如<code>path_assigned_at</code>、<code>path_accessed_at</code>、<code>path_moved_at</code>等），并且也有<code>path_is_var</code>能与变量对应起来，为什么还需要基于变量的输入事实呢（如<code>var_used_at</code>、<code>var_dropped_at</code>、<code>var_defined_at</code>等）？</a></h4>
<p>第一阶段的初始化分析，与具体的字段相关；而第二阶段的存活性分析与第三阶段的借债分析都只与变量相关。对存活性分析而言，变量相关的输入事实是必须的、而字段相关的输入信息是可选的，后续可能移除字段相关的输入，但变量相关的输入不会变。</p>
<p>具体的区别有：</p>
<p>(1) <code>path_assigned_at</code>与<code>var_defined_at</code></p>
<ul>
<li><code>path_assigned_at</code>与<code>var_defined_at</code>的最大区别是：
<ul>
<li>在MIR的每一条赋值语句中，<code>var_defined_at</code>一定发生在当前语句中间（<code>Mid</code>）；</li>
<li>而<code>path_assigned_at</code>可能发生在当前赋值语句中间（<code>Mid</code>），或下一条语句之前（<code>Start</code>），
<ul>
<li>若当前语句不需要<code>unwind</code>，则<code>path_assigned_at</code>在当前赋值语句中间；</li>
<li>若当前语句需要<code>unwind</code>，则<code>path_assigned_at</code>在执行成功的分支中下一条语句之前。</li>
</ul>
</li>
</ul>
</li>
<li><code>var_defined_at</code>还包含<code>StorageLive</code>与<code>StorageDead</code>信息，及变量被赋值的信息。</li>
<li><code>path_assigned_at</code>还包含进入函数时，对入参的初始化赋值。</li>
</ul>
<p>在<a href="2022-01-polonius/./01-21-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90.html">初始化分析</a>中，当某些函数调用发生了<code>panic</code>时，其返回值不会被初始化，因此<code>path_assigned_at</code>发生在执行成功后下一条语句之前。</p>
<p>但存活性分析及后续的借债分析，并不在意在发生<code>panic</code>后变量是否处于未初始化状态。</p>
<ul>
<li>对于<code>var_live_on_entry</code>而言，在某条赋值语句（如<code>_3 = may_panic() [return -&gt; bb1; unwind -&gt; bb2]</code>）发生<code>panic</code>后，其「清理」路径（从<code>bb2</code>开始，依次丢弃已初始化的变量）并不会使用到该变量（<code>_3</code>），也不会产生相应的<code>var_defined_at</code>事实，因此即使发生了<code>panic</code>，产生的<code>var_defined_at</code>在<code>unwind</code>过程中并不会产生<code>var_live_on_entry</code>事实，所以此处的<code>var_defined_at</code>不需要像<code>path_assigned_at</code>那样，必须发生在非<code>unwind</code>分支的入口处。</li>
<li>对于<code>var_drop_live_on_entry</code>而言，具体由于<code>unwind</code>过程中可能产生<code>var_dropped_at</code>事实，因此有可能影响到<code>var_drop_live_on_entry</code>，所以具体情况有待进一步实验验证。</li>
</ul>
<p>(2) <code>path_accessed_at</code>与<code>var_used_at</code></p>
<p><code>var_userd_at</code>等于<code>path_accessed_at</code>加上返回值的访问信息。</p>
<p>(3) <code>path_moved_at</code>与<code>var_dropped_at</code></p>
<p><code>path_moved_at</code>只能追踪到其赋值与移动。而变量在超出其作用域后，还会被丢弃，无法通过路径的移动信息推导出变量的丢弃信息。</p>
<h4 id="2-为什么var_defined_at中包含storagelive和storagedead"><a class="header" href="#2-为什么var_defined_at中包含storagelive和storagedead">2. 为什么<code>var_defined_at</code>中包含<code>StorageLive</code>和<code>StorageDead</code>？</a></h4>
<p><code>StorageLive</code>与<code>StorageDead</code>主要用于LLVM栈空间分配。见<a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">MIR相关文档</a>。</p>
<blockquote>
<p><code>StorageLive(_1)</code>表明变量<code>_1</code>存活，也即其可能在稍后使用——直到<code>StorageDead(_1)</code>语句出现，即<code>_1</code>将不再使用。<code>StorageLive</code>与<code>StoraageDead</code>语句用于LLVM中的栈空间分配。</p>
</blockquote>
<p>在<code>StorageLive</code>之后，变量才开始使用，此处的<code>var_defined_at</code>可以阻止存活性分析中的<code>var_live_on_entry</code>追溯到早于<code>StorageLive</code>的地方（因为这些地方变量未被使用到）。</p>
<p><code>StorageDead</code>不太必要，因为在<code>StorageDead</code>后，将不再可能出现变量被访问的情形。</p>
<h4 id="3-为什么要区分drop_of_var_derefs_origin与use_of_var_derefs_origin"><a class="header" href="#3-为什么要区分drop_of_var_derefs_origin与use_of_var_derefs_origin">3. 为什么要区分<code>drop_of_var_derefs_origin</code>与<code>use_of_var_derefs_origin</code>？</a></h4>
<p>由于<a href="https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html">rfc#1327</a>的缘故，变量在丢弃时的使用情况状态与正常使用时的使用情况有所不同。</p>
<p><code>drop_of_var_derefs_origin</code>的含义是，变量在丢弃时，由于其<code>drop</code>函数中可能访问其包含的引用，因此需要将其视作存活，除非显式指明<code>#[may_dangle]</code>。</p>
<p>例如：</p>
<pre><code class="language-rust ignore">fn main() {
    let mut v = [1, 2, 3];
    let p: Wrapped&lt;&amp; /* R4 */ usize&gt; = Wrapped { value: &amp;v[0] };
    if true {
        drop(*p.value);
    } else {
        v[0] += 1; //~ ERROR cannot assign to `v[_]` because it is borrowed
    }

    v[0] += 1; //~ ERROR cannot assign to `v[_]` because it is borrowed
}

struct Wrapped&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Drop for Wrapped&lt;T&gt; {
    fn drop(&amp;mut self) { }
}
</code></pre>
<p>由于在<code>Wrapped::drop</code>中可能访问到<code>value</code>字段（无显式访问，但在丢弃其字段时会隐式访问到），因此需要<code>drop_of_var_derefs_origin</code>输入事实，表明<code>p.value</code>借用的变量<code>&amp;v[0]</code>直到<code>p</code>被丢弃时（<code>main</code>函数结束前），一直处于存活状态。</p>
<p>若将<code>impl&lt;T&gt; Drop for Wrapped&lt;T&gt;</code>改为</p>
<pre><code class="language-rust ignore">unsafe impl&lt;#[may_dangle] T&gt; Drop for Wrapped&lt;T&gt; {
    fn drop(&amp;mut self) { }
}
</code></pre>
<p>则不产生<code>drop_of_var_derefs_origin</code>事实，因而后面<code>v[0] += 1</code>也视为合法。</p>
<h4 id="4-为什么var_drop_live_on_entry要包含var_maybe_partly_initialized_on_entry的信息"><a class="header" href="#4-为什么var_drop_live_on_entry要包含var_maybe_partly_initialized_on_entry的信息">4. 为什么<code>var_drop_live_on_entry</code>要包含<code>var_maybe_partly_initialized_on_entry</code>的信息？</a></h4>
<p>即使变量出作用域时已被移动，而原始的MIR中仍然包含相应的<code>drop</code>语句。Polonius引擎（包括此前的借用检查引擎）手动过滤了所有的「移动后丢弃」语句。但变量变量在部份移动后，开始处于「丢弃前存活」的状态，且部份丢弃的变量不会产生<code>var_dropped_at</code>事实，因此需要<code>var_maybe_partly_initialized_on_exit</code>来补上变量的部份移动信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借债分析"><a class="header" href="#借债分析">借债分析</a></h1>
<p>写于2022年2月8日。</p>
<p>借用分析是根据前面计算出的借用源存活情况，推断出存在错误的借用、及存在矛盾的生命周期包含关系。</p>
<p>首先有未经优化的<a href="2022-01-polonius/./02-08-%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%89%EF%BC%89-%E5%80%9F%E5%80%BA%E5%88%86%E6%9E%90-%E5%8E%9F%E5%A7%8B%E8%A7%84%E5%88%99.html">原始规则</a>，其思路较清晰，但计算量也较大。</p>
<p>然后，在<a href="2022-01-polonius/">位置无关规则</a>中，忽略了出错的位置信息，可以快速判断出是否有语法错误，在无误时可以提升编译速度。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="借债分析原始规则"><a class="header" href="#借债分析原始规则">借债分析——原始规则</a></h1>
<p>写于2022年2月8日。</p>
<h2 id="推导-3"><a class="header" href="#推导-3">推导</a></h2>
<h3 id="输入传递传播借用源origin的包含关系"><a class="header" href="#输入传递传播借用源origin的包含关系">输入、传递、传播借用源（Origin）的包含关系</a></h3>
<h4 id="1-从mir输入借用源的包含关系"><a class="header" href="#1-从mir输入借用源的包含关系">1. 从MIR输入借用源的包含关系</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, Origin, Point) :-
    subset_base(SubOrigin, Origin, Point).
</code></pre>
<h4 id="2-按其传递性传递包含关系"><a class="header" href="#2-按其传递性传递包含关系">2. 按其传递性传递包含关系</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, SuperOrigin, Point) :-
    subset(SubOrigin, Origin, Point),
    subset(Origin, SuperOrigin, Point).
</code></pre>
<h4 id="3-在借用源存活的情况下沿cfg传播其包含关系"><a class="header" href="#3-在借用源存活的情况下沿cfg传播其包含关系">3. 在借用源存活的情况下，沿CFG传播其包含关系。</a></h4>
<pre><code class="language-prolog">subset(SubOrigin, Origin, TargetPoint) :-
    subset(SubOrigin, Origin, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    origin_live_on_entry(SubOrigin, TargetPoint),
    origin_live_on_entry(Origin, TargetPoint).
</code></pre>
<h3 id="计算借债loan的存活情况"><a class="header" href="#计算借债loan的存活情况">计算借债（Loan）的存活情况</a></h3>
<p>对每一个借债，先找出其关联的借用源。</p>
<ul>
<li>从借债发生处开始，先关联借债发生处的借用源，对应规则4；</li>
<li>然后凡借债关联了某借用源，也必将关联其父借用源（即更「短命」的借用源），对应规则5；</li>
<li>再沿CFG边，传播该借债关联的所有借用源，直到借债清除时，不应关联清除的借用源，对应规则6；</li>
</ul>
<p>最后，只要借债在某处关联了任意一个存活的借用源，则视为借债在该处存活。</p>
<h4 id="4-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入"><a class="header" href="#4-从mir中输入借债发生的信息作为借债关联借用源存活信息的输入">4. 从MIR中输入借债发生的信息，作为借债关联借用源存活信息的输入</a></h4>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, Point) :-
    loan_issued_at(Origin, Loan, Point).
</code></pre>
<h4 id="5-将借债关联借用源的信息按借用源的包含关系传播"><a class="header" href="#5-将借债关联借用源的信息按借用源的包含关系传播">5. 将借债关联借用源的信息，按借用源的包含关系传播</a></h4>
<p><strong>注意</strong>：当借债关联了子借用源（<code>SubOrigin</code>，即更「长命」的借用源）时，子借用源的所有父借用源（<code>Origin</code>，即更「短命」的借用源）也都被关联；反之不成立。</p>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, Point) :-
    origin_contains_loan_on_entry(SubOrigin, Loan, Point),
    subset(SubOrigin, Origin, Point).
</code></pre>
<h4 id="6-将借债关联借用源的信息按cfg传播"><a class="header" href="#6-将借债关联借用源的信息按cfg传播">6. 将借债关联借用源的信息按CFG传播</a></h4>
<p>传播条件为：借债关联的借用源不能在当前点被清除，且须在下一位置处存活（外部声明的生命周期始终视为存活）。</p>
<pre><code class="language-prolog">placeholder_origin(Origin) :-
    placeholder(Origin, _Loan).
</code></pre>
<pre><code class="language-prolog">origin_contains_loan_on_entry(Origin, Loan, TargetPoint) :-
    origin_contains_loan_on_entry(Origin, Loan, SourcePoint),
    !loan_killed_at(Loan, SourcePoint),
    cfg_edge(SourcePoint, TargetPoint),
    (origin_live_on_entry(Origin, TargetPoint); placeholder_origin(Origin)).
</code></pre>
<h4 id="7-借债关联的任一借用源存活时都视为借债存活"><a class="header" href="#7-借债关联的任一借用源存活时都视为借债存活">7. 借债关联的任一借用源存活时，都视为借债存活</a></h4>
<pre><code class="language-prolog">loan_live_at(Loan, Point) :-
    origin_contains_loan_on_entry(Origin, Loan, Point),
    (origin_live_on_entry(Origin, Point); placeholder_origin(Origin)).
</code></pre>
<h3 id="找出借债借用源包含关系中存在的矛盾用以报告语法错误"><a class="header" href="#找出借债借用源包含关系中存在的矛盾用以报告语法错误">找出借债、借用源包含关系中存在的矛盾，用以报告语法错误</a></h3>
<h4 id="8-当借债在某处既存活又失效时视为错误"><a class="header" href="#8-当借债在某处既存活又失效时视为错误">8. 当借债在某处既存活又失效时，视为错误</a></h4>
<pre><code class="language-prolog">errors(Loan, Point) :-
    loan_invalidated_at(Loan, Point),
    loan_live_at(Loan, Point).
</code></pre>
<h4 id="9-当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时视为错误"><a class="header" href="#9-当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时视为错误">9. 当借用源在任意位置处存在与外部生命周期约束不一致的包含关系时，视为错误</a></h4>
<pre><code class="language-prolog">subset_error(SubOrigin, Origin, Point) :-
    subset(SubOrigin, Origin, Point),
    placeholder_origin(SubOrigin),
    placeholder_origin(Origin),
    !known_placeholder_subset(SubOrigin, Origin).
</code></pre>
<h2 id="思考-1"><a class="header" href="#思考-1">思考</a></h2>
<h4 id="1-为什么借债关联了某借用源也必将关联其父借用源更短命而不是子借用源更长命"><a class="header" href="#1-为什么借债关联了某借用源也必将关联其父借用源更短命而不是子借用源更长命">1. 为什么借债关联了某借用源，也必将关联其父借用源（更「短命」），而不是子借用源（更「长命」）？</a></h4>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ghost-cell与staticrc的试用体验"><a class="header" href="#ghost-cell与staticrc的试用体验">Ghost Cell与StaticRC的试用体验</a></h1>
<p>写于2021年9月3日。最早发表于<a href="https://www.zhihu.com/question/482473609/answer/2101373347">知乎</a>。</p>
<hr />
<p>试用了下GhostCell<sup class="footnote-reference"><a href="#1">1</a></sup><sup class="footnote-reference"><a href="#2">2</a></sup> + StaticRc<sup class="footnote-reference"><a href="#3">3</a></sup>，用来写链表。总体感觉非常不错，很创新的一个概念，但如果能内置到编译器层面，可能使用上会更加方便。</p>
<h2 id="ghostcell-安全零开销的内部可变性机制"><a class="header" href="#ghostcell-安全零开销的内部可变性机制"><code>GhostCell</code> ——安全、零开销的内部可变性机制</a></h2>
<p><code>GhostCell</code>的思想大致是：通过一个<code>GhostToken</code>来控制一系列与之生命周期相等的<code>GhostCell</code>数据的读写行为，从而实现安全、零开销的内部可变性。</p>
<p><code>GhostCell</code>文档首页给出的一个样例可以说明其使用方法。 </p>
<pre><code class="language-rust ignore">use ghost_cell::{GhostToken, GhostCell};

let n = 42;

let value = GhostToken::new(|mut token| {
    let cell = GhostCell::new(42);

    let vec: Vec&lt;_&gt; = (0..n).map(|_| &amp;cell).collect();

    *vec[n / 2].borrow_mut(&amp;mut token) = 33;

    *cell.borrow(&amp;token)
});

assert_eq!(33, value);
</code></pre>
<p>首先通过<code>GhostToken::new</code>方法创建一个<code>token</code>，但这个<code>token</code>并非直接创建出来，而是绑定在一个局部作用域（即传入的闭包）内。</p>
<p>所有装入<code>GhostCell</code>内的值，均可通过<code>GhostCell::borrow</code>与<code>GhostCell::borrow_mut</code>两个方法来读写。这两个方法的签名分别是：</p>
<pre><code class="language-rust ignore">pub fn borrow&lt;'a&gt;(&amp;'a self, _: &amp;'a GhostToken&lt;'brand&gt;) -&gt; &amp;'a T;
pub fn borrow_mut&lt;'a&gt;(&amp;'a self, _: &amp;'a mut GhostToken&lt;'brand&gt;) -&gt; &amp;'a mut T;
</code></pre>
<p>可见，不论读写，都只需要<code>GhostCell</code>的 <strong>不可变借用</strong> ，不同的是数据读取需要<code>&amp;token</code>，而数据写入需要<code>&amp;mut token</code>。 两种借用方式借得的<code>&amp;T</code>或<code>&amp;mut T</code>生命周期与<code>cell</code>和<code>token</code>同时绑定（即函数签名中的<code>'a</code>）。 </p>
<p>由于<code>token</code>的生命周期与作用域内创建的所有<code>GhostCell</code>的生命周期都与<code>token</code>相等（<code>GhostCell&lt;'id, T&gt;</code>与<code>GhostToken&lt;'id&gt;</code>内的生命周期标识<code>'id</code>都是 <strong>不变 (invariant) ）</strong> 的，因此可以确保在<code>token</code>被借用时，或者允许多个<code>cell</code>的读取（通过<code>&amp;token</code>），或者允许单独某个<code>cell</code>写入（通过<code>&amp;mut token</code>）。 </p>
<p>回到文档中的样例：</p>
<pre><code class="language-rust ignore">    let cell = GhostCell::new(42);
    let vec: Vec&lt;_&gt; = (0..n).map(|_| &amp;cell).collect();
</code></pre>
<p>这里将同一个<code>cell</code>的只读引用复制了<code>n</code>遍放到一个数组中。如果数组未放到<code>GhostCell</code>内，就不可能在Safe Rust范围内改写数组内的元素。原本修改<code>cell</code>内的值需要可变借用<code>&amp;mut cell</code>，而引入<code>GhostCell</code>后，即使只能拿到<code>&amp;cell</code>，只需独占借用<code>&amp;mut token</code>，即可实现安全的内部可变性，类似一种「可变借用转移」的效果。</p>
<p>不同于<code>RefCell</code>的是，<code>GhostCell</code>是零开销的。<code>RefCell</code>虽然也可以通过<code>RefCell::borrow_mut(&amp;cell)</code>来实现内部可变，但其内部会记录当前值的借用状态，并在运行时检查。<code>GhostCell</code>的检查是在编译期完成的，因为<code>token</code>的读写是互斥的，所以在当前<code>token</code>的生命周期内，所有的<code>GhostCell</code>的读写都是安全的，并且是<code>Send + Sync</code>的。 </p>
<p>[<sup class="footnote-reference"><a href="#1">1</a></sup>] 中给出了GhostCell安全性的证明。 </p>
<h2 id="staticrc零开销的共享所有权机制"><a class="header" href="#staticrc零开销的共享所有权机制"><code>StaticRc</code>——零开销的共享所有权机制</a></h2>
<p><code>ghost_cell</code>库中提到了<code>static_rc</code> <sup class="footnote-reference"><a href="#3">3</a></sup> 库，实现了一种编译期检查的零开销共享所有权机制。其思想是：将<code>Box</code>的所有权分开，引入有理数（大于0，不大于1）范围意义的所有权。<code>StaticRc&lt;T, const NUM: usize, const DEN: usize&gt;</code>的所有权值为有理数<code>NUM/DEN</code>（<code>NUM &lt;= DEN</code>）。当<code>NUM/DEN</code> = 1时，代表该指针拥有完全的所有权，即等价于<code>Box</code>；当<code>NUM/DEN</code> &lt; 1时，代表与其他指针共享所有权；指同一对象的所有指针，其所有权值之和不大于<code>1</code>。</p>
<p>引入<code>split</code>与<code>join</code>两个操作。其中<code>split</code>操作将一个指针一分为二，分为两个所有权值更小的指针（二者所有权值之和等于分裂前的所有权值）；<code>join</code>操作将两个指针合二为一，合成一个新指针，其所有权值之和等于合成后指针的所有权值（不大于一）。</p>
<p>在<code>StaticRc</code>中，仅独占所有权的指针（即所有权值为1）具有完全操作所指对象的权限（读(<code>&amp;ptr</code>)、写(<code>&amp;mut ptr</code>)、消耗(<code>ptr</code>)），等同于<code>Box</code>；共享指针（即所有权值小于1）仅具有只读权限(<code>&amp;ptr</code>)。</p>
<p>该库的安全性还有待证明。我不太熟悉生命周期证明的那套理论，仅从直觉上看没有什么大问题。不过看了一下该库的实现，共享所有权指针的<code>Drop</code>是静默的，仅独占所有权的指针会被释放，这可能很容易引起内存泄露，所以我认为将<code>StaticRc</code>设计成线性类型可能更好（即至少且至多被使用一次），对共享指针而言，必须将其合倂为独占指针再释放，否则报编译错误。 </p>
<h2 id="安全零开销的链表实现尝试"><a class="header" href="#安全零开销的链表实现尝试">安全、零开销的链表实现尝试</a></h2>
<p>[<sup class="footnote-reference"><a href="#1">1</a></sup>] 中已经提出了一种基于arena的双向链表实现方式，[<sup class="footnote-reference"><a href="#4">4</a></sup>] 中还给出了一种基于<code>GhostCell</code> + <code>Arc</code>的链表实现。我认为前者更优，因为后者需要<code>Arc</code>额外开销，所以基本上不会考虑这种实现。而前者虽然无额外开销，但arena的实现可能在节点删除后不能及时的释放，所以我就尝试了如下的第三种方式。</p>
<p>考虑到（双向）链表中每个节点恰好由两个指针共享持有，因此想到可以用<code>StaticRc</code>来实现共享所有权，用<code>GhostCell</code>实现内部可变性，若<code>StaticRc</code>保持安全，便可实现安全、零开销的双向链表。</p>
<p>定义链表的数据结构如下：</p>
<pre><code class="language-rust ignore">pub struct List&lt;'id, T&gt; {
    head: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    tail: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    len: usize,
}

struct Node&lt;'id, T&gt; {
    next: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    prev: Option&lt;NodePtr&lt;'id, T&gt;&gt;,
    elem: T,
}

type NodePtr&lt;'id, T&gt; = Half&lt;GhostCell&lt;'id, Node&lt;'id, T&gt;&gt;&gt;;

type Half&lt;T&gt; = StaticRc&lt;T, 1, 2&gt;;
type Full&lt;T&gt; = StaticRc&lt;T, 2, 2&gt;;
</code></pre>
<p>其中，<code>head</code>,<code>tail</code>,<code>next</code>,<code>prev</code>都是共享所有权（1/2）的指针（<code>Half</code>），套上<code>GhostCell</code>。每个节点由一前一后两个指向其的指针共享所有权；链表首/尾节点则由<code>head</code>/<code>tail</code>指针共享另一半所有权。 <code>Half</code>指针只能拿到不可变引用，但可借助<code>GhostCell</code>实现内部可变性，看起来十分完美，于是我就写了一个简单的<code>push</code> / <code>pop</code>操作：</p>
<pre><code class="language-rust ignore">    pub fn push_back(&amp;mut self, side: usize, elem: T, token: &amp;mut GhostToken&lt;'id&gt;) {
        // 创建新节点后即一分为二。
        let (left, right) = Full::split(Full::new(GhostCell::new(Node::new(elem))));
        match self.tail.take() {
            Some(tail) =&gt; {
                // 链接其左半边指针。若当前链表为空，则链接`self.head`。
                tail.deref().borrow_mut(token).next = Some(left);
                // 将插入前的`self.tail`所有权转移至新插入节点。
                right.deref().borrow_mut(token).prev = Some(tail);
            }
            None =&gt; self.head = Some(left),
        }
        // 链接其右半边指针到新的`self.tail`。
        self.tail = Some(right);
    }
    pub fn pop_back(&amp;mut self, side: usize, token: &amp;mut GhostToken&lt;'id&gt;) -&gt; Option&lt;T&gt; {
        // 从`self.tail`取其右半边指针（若为空则返回`None`）。
        let right = self.tail.take()?;
        let left = match right.deref().borrow_mut(token).prev.take() {
            Some(tail) =&gt; {
                // 若`self.tail`的前一节点不为空，则从其`next`中取出左半边指针，
                // 否则从`self.head`取出左半边指针。
                let left = tail.deref().borrow_mut(token).next.take().unwrap();
                // 重新链接`self.tail`
                self.tail = Some(tail);
                left
            }
            None =&gt; self.head.take().unwrap(),
        };
        // 将左右指针合二为一，并返回弹出的节点元素。弹出的元素在包含`Box`内，
        // 用完后会随`Box`一起回收。
        Some(Full::into_box(Full::join(left, right)).into_inner().elem)
    }
</code></pre>
<p>至此都一切顺利，直到我想实现一个可变的迭代器。一开始按照标准的迭代器写法：</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'id, 'iter, T&gt; {
    head: Option&lt;&amp;'iter NodePtr&lt;'id, T&gt;&gt;,
    tail: Option&lt;&amp;'iter NodePtr&lt;'id, T&gt;&gt;,
    len: usize,
    token: &amp;'iter mut GhostToken&lt;'id&gt;,
}

impl&lt;'id, 'iter, T&gt; Iterator for IterMut&lt;'id, 'iter, T&gt; {
    type Item = &amp;'iter mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let current = self.head?;
        self.head = current.deref().borrow(self.token).next;
        self.len -= 1;
        // 编译错误：token先被不可变借用，后被可变借用，且借用周期都等于`'iter`。
        Some(&amp;current.deref().borrow_mut(self.token).elem)
    }
}
</code></pre>
<p>结果未能通过借用检查规则。原因很简单，遍历时获取每个节点的<code>next</code>指针需要不可变借用<code>token</code>，而返回节点中元素的可变引用，则需要可变借用<code>token</code>，且借出的<code>token</code>周期均为<code>'iter</code>（即整个迭代器的生命周期），自然不可能通过借用检查。</p>
<p>后来又另辟溪径，参考[<sup class="footnote-reference"><a href="#4">4</a></sup>]中的一个迭代器实现，他的可变迭代并不像一般的设计模式那样返回一个迭代器结构，而是直接采用类似<code>Iterator::for_each</code>的方式，在闭包内完成可变借用，从而把可变借出的生命周期缩短。</p>
<p>于是我也实现了一个<code>for_each_mut</code>的接口：</p>
<pre><code class="language-rust ignore">    pub fn for_each_mut(&amp;self, token: &amp;mut GhostToken&lt;'id&gt;, mut f: impl FnMut(&amp;mut T)) {
        let mut current = self.head.as_ref();
        while let Some(node) = current {
            let node = node.deref().borrow_mut(token);
            f(&amp;mut node.elem);
            current = node.deref().next.as_ref();
        }
    }
</code></pre>
<p>不幸地是，虽然看起来这个函数中只有一次<code>borrow_mut</code>，且只在循环体内，应该会在单次循环后归还。但由于每次获得<code>next</code>指针时依赖于上一次的借用，该借用的生命周期硬生生地被从循环体内拉长到了循环体外。 因此出现了如下的编译错误</p>
<pre><code class="language-plaintext">error[E0499]: cannot borrow `*token` as mutable more than once at a time
   --&gt; src/experiments.rs:182:48
    |
182 |             let node = node.deref().borrow_mut(token);
    |                                                ^^^^^ `*token` was mutably borrowed here in the previous iteration of the loop
</code></pre>
<p>基于arena或<code>Arc</code>的实现则不存在这一问题。基于<code>arena</code>的实现中，所有的<code>next</code>或<code>prev</code>都是引用，且有单独的生命周期，因此在迭代时不存在需要借用才能拿到<code>next</code>的情况； 基于<code>Arc</code>的实现中，共享指针<code>Arc</code>可以在运行时复制一份指针，因此也不需要通过借用来获取<code>next</code>指针。而<code>StaticRc</code>并不支持在运行时临时新增一份引用，只能通过<code>split</code>的方式将其原有的半份所有权分裂开来。这种方式不仅涉及<code>next</code>字段的修改（需要用<code>Option::take</code>将整个<code>Half</code>指针按值的方式取出来，才能调用<code>split</code>），且在所有权一分为二后，又存在合井困难的问题（因为<code>next</code>指针的值仍然借用于分裂后的指针，会阻止分裂指针合井）。</p>
<p>结论：该方案（<code>StaticRc</code> + <code>GhostCell</code>）在描述定义链表，或操作链表中的单个节点时虽能胜任安全零开销的实现。但对链表作遍历或其他更复杂的操作时，需要将链表的结构可变性与数据可变性作进一步分离，才能实现全功能的安全零开销链表。</p>
<hr />
<p>总之，我比较看好<code>GhostCell</code>的思想，将大有可能改进下一个Rust Edition中的借用检查的体验（就像2015的Lexical Lifetime到Non-Lexical Lifetime的改进一样）， 进一步平衡安全、性能、易用的三角。</p>
<p><code>GhostCell</code>的不足之处：写起来比较繁琐，会需要多写不少的<code>GhostToken::new</code>、<code>GhostCell::new</code>、<code>borrow(token)</code>、<code>borrow_mut(token)</code>之类的代码。如果能集成到编译器内，通过更简洁的语法书写，使用体验会好很多。</p>
<p>拭目以待。</p>
<hr />
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf">http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://docs.rs/ghost-cell/0.2.2/ghost_cell/">https://docs.rs/ghost-cell/0.2.2/ghost_cell/</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://docs.rs/static-rc/0.4.1/static_rc/">https://docs.rs/static-rc/0.4.1/static_rc/</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://gitlab.mpi-sws.org/FP/ghostcell/-/blob/master/ghostcell/examples/dlist_arc.rs">https://gitlab.mpi-sws.org/FP/ghostcell/-/blob/master/ghostcell/examples/dlist_arc.rs</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门系列"><a class="header" href="#rust过程宏入门系列">Rust过程宏入门系列</a></h1>
<p>写于2022年1月15日。</p>
<hr />
<p>本系列文章写于2021年1月，最早于知乎发表。当时正初学Rust，选取了看起来比较有意思的过程宏入手。与之前学过的C++宏的预处理文本替换机制不同，Rust的过程宏提供了在AST（抽象语法树）层次上操作源代码的方式，自由度较高。但局限是也仅限于AST层次，无法获得类型信息。因此过程宏也仅仅只是一种生成代码的方式，但不能成为元编程的手段。</p>
<p>由于过程宏在后来的编程实践中很少用到，因此本系列很可能再也不会更新了。但无论如何，本文用到的<a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>仓库都可以作为很好的过程宏入门资料。</p>
<p>附知乎原文链接：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/342408254">Rust过程宏入门（一）——过程宏简介</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/342664529">Rust过程宏入门（二）——初探派生宏</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/343170504">Rust过程宏入门（三）——实现简易派生宏</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/344701514">Rust过程宏入门（四）——遍历结构体字段</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门一过程宏简介"><a class="header" href="#rust过程宏入门一过程宏简介">Rust过程宏入门（一）——过程宏简介</a></h1>
<p>写于2021年1月6日。最早发表于<a href="https://zhuanlan.zhihu.com/p/342408254">知乎</a>。</p>
<h2 id="什么是宏"><a class="header" href="#什么是宏">什么是宏？</a></h2>
<p>熟悉C/C++的朋友应该很熟悉 <strong>宏（Macro）</strong> 的概念，而Rust初学者也必定会接触到Rust中的宏，其Hello world程序中就会用到<code>println!</code>宏。</p>
<p>可以简单地理解为： <strong>宏即编译时将执行的一系列指令</strong>。其重点在于「编译时」，尽管宏与函数（或方法）形似，函数是在运行时发生调用的，而宏是在编译时执行的。</p>
<p>不同于C/C++中的宏，Rust的宏并非简单的文本替换，而是在词法层面甚至语法树层面作替换，其功能更加强大，也更加安全。</p>
<p>如下所示的一个C++的宏SQR的定义</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#define SQR(x) (x * x)
int main() {
    std::cout &lt;&lt; SQR(1 + 1) &lt;&lt; std::endl;
    return 0;
} 
</code></pre>
<p>我们希望它输出<code>4</code>，但很遗憾它将输出<code>3</code>，因为<code>SQR(1 + 1)</code>在预编译阶段通过文本替换展开将得到<code>(1 + 1 * 1 + 1)</code>，并非我们所期望的语义。</p>
<p>而在Rust中，按如下方式定义的宏：</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! sqr {
    ($x:expr) =&gt; {$x * $x}
}

fn main() {
    println!(&quot;{}&quot;, sqr!(1 + 1));
}
</code></pre></pre>
<p>将得到正确的答案<code>4</code>。这是因为Rust的宏展开发生在语法分析阶段，此时编译器知道<code>sqr!</code>宏中的<code>$x</code>变量是一个表达式（用<code>$x:expr</code>标记），所以在展开后它知道如何正确处理，会将其展开为<code>((1 + 1) * (1 + 1))</code>。</p>
<p>由于本文介绍的重点是过程宏，因此涉及普通宏的内容便不多赘述，有兴趣者可参考<a href="https://doc.rust-lang.org/rust-by-example/macros.html">官方文档</a>上的介绍。</p>
<h2 id="什么是过程宏"><a class="header" href="#什么是过程宏">什么是过程宏？</a></h2>
<p><strong>过程宏（Procedure Macro）</strong> 是Rust中的一种特殊形式的宏，它将提供比普通宏更强大的功能。方便起见，本文将Rust中由<code>macro_rules!</code>定义的宏称为 <strong>声明宏</strong> 以示区分。</p>
<p>过程宏分为三种：</p>
<ul>
<li>派生宏（Derive macro）：用于结构体（struct）、枚举（enum）、联合（union）类型，可为其实现函数或特征（Trait）。</li>
<li>属性宏（Attribute macro）：用在结构体、字段、函数等地方，为其指定属性等功能。如标准库中的<code>#[inline]</code>、<code>#[derive(...)]</code>等都是属性宏。</li>
<li>函数式宏（Function-like macro）：用法与普通的声明宏类似，但功能更加强大，可实现任意语法树层面的转换功能。</li>
</ul>
<h2 id="过程宏的定义与使用方法"><a class="header" href="#过程宏的定义与使用方法">过程宏的定义与使用方法</a></h2>
<h3 id="派生宏"><a class="header" href="#派生宏">派生宏</a></h3>
<p>派生宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>其使用方法如下：</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Command {
    // ...
}
</code></pre>
<h3 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h3>
<p>属性宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
fn sorted(args: TokenStream, input: TokenStream) -&gt; TokenStream {
    let _ = args;
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>使用方法如下：</p>
<pre><code class="language-rust ignore">#[sorted]
enum Letter {
    A,
    B,
    C,
    // ...
}
</code></pre>
<h3 id="函数式宏"><a class="header" href="#函数式宏">函数式宏</a></h3>
<p>函数式宏的定义方法如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn seq(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>使用方法如下：</p>
<pre><code class="language-rust ignore">seq! { n in 0..10 {
    /* ... */
}}
</code></pre>
<h2 id="过程宏的原理"><a class="header" href="#过程宏的原理">过程宏的原理</a></h2>
<p>以上三种过程宏的定义方法已全部介绍。可以发现，它的定义方式与普通函数无异，只不过其函数调用发生在编译阶段而已。下面以较为常见的派生宏为例，介绍过程宏的原理。</p>
<p>回顾刚才的定义：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>首先，<code>#[proc_macro_derive(Builder)]</code>表明<code>derive_builder</code>是一个派生宏，<code>Builder</code>表示它将作用的地方。比如定义如下结构体</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
struct Command {
    // ...
}
</code></pre>
<p>就会触发以上派生宏执行。至于其中的<code>Builder</code>具体代表什么含义，本期暂不展开，后面再详细介绍。</p>
<p><code>fn derive_builder(input: TokenStream) -&gt; TokenStream</code>函数头部表明该函数将接受一个<code>TokenStream</code>对象作为输入，并返回一个<code>TokenStream</code>对象。</p>
<p>要理解<code>TokenStream</code>，需要一些简单的编译原理知识。编译器在编译一段程序时，会首先将输入的文本转换成一系列的Token（标识符、关键字、符号、字面量等），同时忽略注释（文档注释除外）与空白字符等。</p>
<p>例如<code>println!(&quot;Hello world&quot;);</code>这句代码将被转换成标识符<code>println</code> 、叹号<code>!</code> 、圆括号<code>(</code> 、字面量<code>&quot;Hello world&quot;</code> 、圆括号<code>)</code> 、分号<code>;</code>几个Token。</p>
<p><code>TokenStream</code>顾名思义，是Rust中对一系列连续的Token的抽象。在宏展开的过程中，遇到派生宏时，会将整个结构体（或<code>enum</code>、<code>union</code>）展开成<code>TokenStream</code>作为派生宏函数的输入，然后将其输出的<code>TokenStream</code>附加到结构体后面，再继续作语法分析。</p>
<hr />
<p>本期的介绍到此结束，主要介绍了过程宏的基本概念、定义及使用方法、实现原理。接下来将通过几个具体实例详细介绍Rust过程宏的编程方法。</p>
<p>实例来源自GitHub上的仓库： <a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门二初探派生宏"><a class="header" href="#rust过程宏入门二初探派生宏">Rust过程宏入门（二）——初探派生宏</a></h1>
<p>写于2021年1月7日。最早发表于<a href="https://zhuanlan.zhihu.com/p/342664529">知乎</a>。</p>
<h2 id="认识派生宏手动实现生成代码"><a class="header" href="#认识派生宏手动实现生成代码">认识派生宏，手动实现生成代码</a></h2>
<p>我们将从一个<a href="https://link.zhihu.com/?target=https%3A//github.com/whjpji/proc-macro-workshop%23derive-macro-derivebuilder">简单的案例</a>开始，设计一个Builder模式的派生宏。</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    #[builder(each = &quot;arg&quot;)]
    args: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .arg(&quot;build&quot;.to_owned())
        .arg(&quot;--release&quot;.to_owned())
        .build()
        .unwrap();

    assert_eq!(command.executable, &quot;cargo&quot;);
}
</code></pre>
<p>上述代码展示了我们希望呈现给用户的使用方式，即用户只需定义一个结构体（若结构体实现了成员函数或trait，下文中也称之为「类」），则派生宏将为其自动生成Builder类。</p>
<h2 id="command类实现"><a class="header" href="#command类实现">Command类实现</a></h2>
<p>首先从Builder类的使用方式入手，若欲手动实现Builder类，那么它大概会像这样：</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder {
            executable: None,
            args: Vec::new(),
            current_dir: None
        }
    }
}

pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Vec&lt;String&gt;,
    current_dir: Option&lt;String&gt;,
}
</code></pre>
<p>其中，<code>impl Command</code>为<code>Command</code>结构体添加了<code>builder</code>成员函数，将返回一个<code>CommandBuilder</code>结构体， 并设置其成员变量的初始量。注意这里的<code>builder</code>不带任何参数（在C++、Java等语言中又称为静态函数或静态方法）。 </p>
<p>而<code>CommandBuilder</code>结构体中的成员变量与<code>Command</code>基本一致，只是<code>executable</code>字段的类型由<code>String</code>变成了<code>Option&lt;String&gt;</code>，这是因为在刚创建<code>CommandBuilder</code>类时，<code>executable</code>的值未知，所以只好利用Rust自带的可选类型<code>Option&lt;T&gt;</code>，其定义很简单：</p>
<pre><code class="language-rust ignore">pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>虽然在不少语言中（如C/C++、Java等）都有枚举类型的概念，但对不熟悉Rust的朋友或Rust初学者而言，这里有必要指出：Rust的枚举类型与其他语言稍有不同，除了包含枚举标签以外，它还可以额外附带任意值。例如<code>Option&lt;T&gt;</code>类型中，有「有值（<code>Some</code>）」与「无值（<code>None</code>）」两种状态，而处于「有值」的状态时，还附带一个T类型（即泛型参数）的值，这便很好地表示了可选类型。</p>
<h2 id="commandbuilder类及实现"><a class="header" href="#commandbuilder类及实现">CommandBuilder类及实现</a></h2>
<p>接下来，为<code>CommandBuilder</code>结构体实现相应的函数： </p>
<pre><code class="language-rust ignore">impl CommandBuilder {
    pub fn executable(mut self, executable: String) -&gt; Self {
        self.executable = Some(executable);
        self
    }
    pub fn arg(mut self, arg: String) -&gt; Self {
        self.args.push(arg);
        self
    }
    pub fn current_dir(mut self, current_dir: String) -&gt; Self {
        self.current_dir = Some(current_dir);
        self
    }
    pub fn build(self) -&gt; Result&lt;Command, String&gt; {
        let executable = self.executable.ok_or(
            &quot;executable required, but not set&quot;.to_owned())?;
        let args = self.args;
        let current_dir = self.current_dir;
        Ok(Command { executable, args, current_dir })
    }
}
</code></pre>
<p>其中，<code>executable</code>、<code>arg</code>、<code>current_dir</code>函数分别对应三个字段的设置函数。其第一个参数<code>mut self</code>代表结构体自身（由于rust中的变量默认是不可变的，所以要修改<code>self</code>，需要加上<code>mut</code>。第二个参数是相应字段的值，最后返回结构体自身（这里用到了自身类型别名<code>Self</code>，须注意它与自身变量别名<code>self</code>是不同的）。</p>
<p>最后的<code>build</code>函数则是返回所希望构建的<code>Command</code>类。由于最终构建<code>Command</code>类时，可能有必填字段未设置（如<code>executable</code>是必须设置的），此时不能构造一个有效的<code>Command</code>类，且需将此错误信息告知调用者。</p>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>说到这里，不得不提及Rust独特的错误处理机制。C语言中常通过返回非零值代表错误；C++、Java、Python语言中通常会中断当前函数执行并抛出异常信息交予调用者处理。而Rust得益于其特有的枚举类型，将错误信息直接返回调用者，且通常调用者无法直接忽略错误。Rust标准库中定义了<code>Result&lt;T, E&gt;</code>类型如下：</p>
<pre><code class="language-rust ignore">pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>该类型有「正常（<code>Ok</code>）」与「错误（<code>Err</code>）」两种状态，因此调用者要么立即处理错误信息，要么将其向上传播。 不过<code>Result&lt;T, E&gt;</code>类中也提供了一个<code>unwarp</code>方法，可以直接取其正常状态的值。但若返回的是错误状态，调用<code>unwarp</code>会触发<code>panic!</code>并打印该错误信息。</p>
<p>若忘记设置<code>executable</code>的值，运行时将输出如下错误信息。 </p>
<pre><code class="language-plaintext">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;executable required, but not set&quot;' 
</code></pre>
<hr />
<p>本期的介绍到此结束，主要以较为常见的Builder模式为例，介绍了如何手动实现其主要功能，接下将逐步介绍如何通过Rust过程宏自动实现上述代码。</p>
<p>实例来源自GitHub上的仓库： <a href="https://github.com/dtolnay/proc-macro-workshop/%E2%80%8B">dtolnay/proc-macro-workshop</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门三实现简易派生宏"><a class="header" href="#rust过程宏入门三实现简易派生宏">Rust过程宏入门（三）——实现简易派生宏</a></h1>
<p>写于2021年1月10日。最早发表于<a href="https://zhuanlan.zhihu.com/p/343170504">知乎</a>。</p>
<h2 id="再谈派生宏的原理"><a class="header" href="#再谈派生宏的原理">再谈派生宏的原理</a></h2>
<p>简单起见，我们先假定<code>Command</code>结构体中只有必填单选项，无选填或多选项，简化后的<code>Command</code>类如下：</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
</code></pre>
<p>首先实现<code>Command</code>类中的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}

pub struct CommandBuilder;
</code></pre>
<p>为此派生宏创建一个crate，注意需要在<code>Cargo.toml</code>中加上</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>以表示该crate将编译为一个过程宏库。
回顾一下派生宏的定义方式，我们需要根据输入的<code>TokenStream</code>生成目标<code>TokenStream</code>。 </p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>编译器会将派生宏作用的结构体（或<code>enum</code>、<code>union</code>）展开成<code>TokenStream</code>作为函数参数传入。不出意料的话，展开后的<code>TokenStream</code>会由如下几项构成：</p>
<blockquote>
<p>关键字<code>pub</code> 关键字<code>struct</code> 标识符<code>Command</code> 花括号<code>{</code></p>
<p>标识符<code>executable</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>标识符<code>args</code> 冒号<code>:</code> 标识符<code>Vec</code> 小于号<code>&lt;</code> 标识符<code>String</code> 大于号<code>&gt;</code> 逗号<code>,</code> </p>
<p>标识符<code>current_dir</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>花括号<code>}</code></p>
</blockquote>
<p>我们需要用到的Token有：结构体名标识符<code>Command</code>，每个字段的名字标识符与类型的Token串。其他信息只起结构标记的作用，无需用到。</p>
<p>应当如何提取这些信息呢？</p>
<p>一种方法是利用<code>TokenStream</code>类的<code>to_string</code>函数，将这些Token转换为字符串，然后再用字符串处理的手段提取其中的信息。但这就有一个问题：编译器好不容易将源代码文件中的文本信息（也即字符串），转换成了语法树，在此处展开成<code>TokenStream</code>以调用过程宏处理，但我们反而再次将<code>TokenStream</code>转换为原始的字符串，岂不多此一举？</p>
<p>另一种方法是使用<a href="https://docs.rs/syn/1.0.58/syn/index.html">syn库</a>。syn库提供了表示语法解析结果（一般为语法树上的某一节点）的一系列类。</p>
<p>若要使用syn库，需要在项目的<code>Cargo.toml</code>文件中指定：</p>
<pre><code class="language-toml">[dependencies]
syn = &quot;1.0&quot; 
</code></pre>
<h2 id="认识deriveinput"><a class="header" href="#认识deriveinput">认识DeriveInput</a></h2>
<p>由于派生宏的使用场景相对固定（目前只能作用于<code>struct</code>、<code>enum</code>、<code>union</code>），syn库中已提供了派生宏输入项的封装——<code>DeriveInput</code>。其结构如下：</p>
<pre><code class="language-rust ignore">pub struct DeriveInput {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
} 
</code></pre>
<p>其中<code>ident</code>字段正是我们所需的结构体名的标识符。结合<code>parse_macro_input!</code>宏，容易将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    unimplemented!()
}
</code></pre>
<p>若以<code>#ident</code>指代结构体名<code>Command</code>，那么我们已经可以实现一个简易版的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl #ident {
    pub fn builder() -&gt; #identBuilder {
<span class="boring">        identBuilder
</span>    }
}

pub struct #identBuilder;
</code></pre>
<p>当然上述代码中的<code>#identBuilder</code>是有问题的，这里暂时跳过。</p>
<h2 id="用quote宏生成tokenstream"><a class="header" href="#用quote宏生成tokenstream">用<code>quote!</code>宏生成<code>TokenStream</code></a></h2>
<p>如何生成这段代码呢？不难想到，可以直接用字符串拼接的方法再转换成<code>TokenStream</code>输出，但这会让编译器再多一层词法分析的步骤，且不易阅读与扩展。（字符串格式化的占位符是<code>{}</code>，当输入代码篇幅较大时，占位符与实际传入参数相隔很远，且不便于一一对应。）</p>
<p>另一种方法是用<a href="https://docs.rs/quote/1.0.8/quote/index.html">quote库</a>，同样需在<code>Cargo.toml</code>后面加上<code>quote = &quot;1.0&quot;</code>的依赖。</p>
<p>quote库中的<code>quote!</code>宏提供了将Rust语法项展开为<code>TokenStream</code>的功能， 包含在<code>quote!</code>宏中的任何Rust代码都将展开为<code>TokenStream</code>，而以<code>#</code>开头的标识符将引用前文中已定义的标识符，而非像字符串格式化那样使用<code>{}</code>并在末尾传入参数的方式。这便是笔者在上文中用<code>#ident</code>指代<code>Command</code>类名的原因。</p>
<p>需要注意的是，与syn库搭配的<code>TokenStream</code>来自<a href="https://docs.rs/proc-macro2/1.0.24/proc_macro2/struct.TokenStream.html">proc_macro2库</a>， 其别名为<code>TokenStream2</code>，需要用<code>.into()</code>方法转换为<code>TokenStream</code>才能作为过程宏函数的返回值。</p>
<p>用<code>quote!</code>宏包含<code>Command::builder</code>函数的实现部分，得：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = /* 暂时跳过 */;
    quote!(
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder::default()
</span>            }
        }
        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<h2 id="拼接标识符"><a class="header" href="#拼接标识符">拼接标识符</a></h2>
<p>最后回到<code>CommandBuilder</code>标识符的问题。刚才提到，<code>Command</code>标识符可由<code>DeriveInput</code>直接获取，但<code>CommandBuilder</code>的标识符却需要手动拼接生成。</p>
<p>笔者联想到C++中的宏定义中有<code>##</code>运算符可用于拼接标识符，譬如<code>#define CONCAT(a, b) a##b</code>，<code>CONCAT(foo, bar)</code>就会得到一个<code>foobar</code>的标识符，想必Rust应当也有类似的宏，于是搜索Rust标准库发现果然有一个名为<code>concat_idents!</code>的宏，然后这样写：</p>
<pre><code class="language-rust ignore">pub struct concat_idents!(#ident, Builder);
</code></pre>
<p>但尝试未果，总是会报出类似<code>error: expected `where`, `{`, `(`, or `;` after struct name, found `!` </code>的错误。后来才发现Rust中并不支持在标识符位置的宏调用（详见<a href="https://github.com/rust-lang/rust/issues/4365">rust-lang/rust#4365 · Macros don't get expanded when used in item name token position</a>）。编译器会将<code>concat_idents</code>当作<code>struct</code>的名字标识符 ，然后并不知道如何处理这个叹号<code>!</code>Token， 故而只能报编译错误。</p>
<p>几经周折，最终还是选择了手动拼接构造标识符，因为标识符位置不可用宏，所以一切基于宏的办法都失效了，总不至于退回到原始的字符串拼接的方式吧？</p>
<p>所幸syn库中的<code>Ident</code>类有由字符串新建实例的构造函数<code>new</code>，但观察其构造函数</p>
<pre><code class="language-rust ignore">pub fn new(string: &amp;str, span: Span) -&gt; Ident
</code></pre>
<p>发现，除了传入一个字符串以外，还需要一个<code>Span</code>对象。<code>Ident</code>类中的<a href="https://docs.rs/syn/1.0.58/syn/struct.Ident.html">文档示例代码</a>是传入了一个<code>Span::call_cite()</code>，如：</p>
<pre><code class="language-rust ignore">let ident = Ident::new(&quot;demo&quot;, Span::call_site());
let temp_ident = Ident::new(&amp;format!(&quot;new_{}&quot;, ident), Span::call_site());     
</code></pre>
<p>文档中对Span::call_cite()的解释是：</p>
<blockquote>
<p>identifiers created with this span will be resolved as if they were written directly at the location of the macro call, and other code at the macro call site will be able to refer to them as well. </p>
</blockquote>
<p>大致意思是，标识符的<code>span</code>会解析为宏调用的地方。如何理解「<code>span</code>」的含义呢？在<code>Span</code>的文档中有定义：</p>
<blockquote>
<p>A region of source code, along with macro expansion information.</p>
</blockquote>
<p>即<code>Span</code>代表了源代码的某一区间，并携带了宏展开的信息。也就是说，<code>Ident::new()</code>中传入的<code>Span</code>是用来定位标识符的位置的。而<code>CommandBuilder</code>标识符是与<code>Command</code>相关联的，不妨将其<code>span</code>设置为<code>Command</code>标识符的区间就好。 因此有：</p>
<pre><code class="language-rust ignore">let ident = input.ident;
let ident_builder = Ident::new(&amp;format!(&quot;{}Buidler&quot;, ident), ident.span());
</code></pre>
<h2 id="利用cargo-expand命令检验代码生成结果"><a class="header" href="#利用cargo-expand命令检验代码生成结果">利用<code>cargo expand</code>命令检验代码生成结果</a></h2>
<p>将前面的代码全部综合到一起，得：</p>
<pre><code class="language-rust ignore">use proc_macro::TokenStream;

use quote::quote;
use syn::{parse_macro_input, DeriveInput, Ident};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = Ident::new(&amp;format!(&quot;{}Builder&quot;, ident), ident.span());
    quote! (
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder
</span>            }
        }

        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<p>最后我们用<code>cargo expand</code>命令来检验生成的代码。这里要指出的是，使用过程宏须与定义过程中处在不同的crate中。</p>
<pre><code class="language-rust ignore">use derive_builder::Builder;

#[allow(dead_code)] // 忽略警告
#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}

fn main() {}
</code></pre>
<p>展开后将得到：</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use derive_builder::Builder;
#[allow(dead_code)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}
pub struct CommandBuilder;
fn main() {}
</code></pre>
<p>正是所期望的结果。</p>
<hr />
<p>本期的介绍到此为止，主要介绍了如何将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>，提取其中的名字信息，使用<code>Ident</code>类提供的构造函数拼接成新的标识符，最后用<code>quote!</code>宏生成目标代码的<code>TokenStream</code>。 接下来将继续介绍用派生宏实现<code>CommandBuilder</code>类的字段生成、函数实现等功能。 </p>
<p>本文中的代码实现详见 <a href="https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder">https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder</a>。</p>
<p>其中，测试用的<code>main.rs</code>代码见<a href="https://github.com/frank-king/proc-macro-workshop/blob/example/builder/01-parse.rs/main.rs"><code>example/builder/01-parse.rs</code>中的<code>main.rs</code>文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust过程宏入门四遍历结构体字段"><a class="header" href="#rust过程宏入门四遍历结构体字段">Rust过程宏入门（四）——遍历结构体字段</a></h1>
<p>写于2021年1月16日。最早发表于<a href="https://zhuanlan.zhihu.com/p/344701514">知乎</a>。</p>
<h2 id="简单回顾"><a class="header" href="#简单回顾">简单回顾</a></h2>
<p>在上一章中的简单案例中，</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
</code></pre>
<p>我们已经为<code>Command</code>结构体生成了如下代码</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}

pub struct CommandBuilder; 
</code></pre>
<p>接下来，自然是补齐<code>CommandBuilder</code>结构体的字段和成员函数，使其成为一个真正可用的类。</p>
<p>首先是<code>CommandBuilder</code>类的字段，相对比较简单，只需要引用原结构体的字段名，并在其字段类型外面套上<code>Option&lt;&gt;</code>即可。</p>
<h2 id="获取结构体中的字段信息"><a class="header" href="#获取结构体中的字段信息">获取结构体中的字段信息</a></h2>
<p>如何获取原结构体的字段信息呢？这就需要用到上一章介绍的<code>DeriveInput</code>了：</p>
<pre><code class="language-rust ignore">pub struct DeriveInput {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
} 
</code></pre>
<p>其中的<code>data: Data</code>就是具体的结构体（或<code>enum</code>、<code>union</code>）信息。我们看<a href="https://docs.rs/syn/1.0.58/syn/enum.Data.html"><code>Data</code>的定义</a>，它也是一个<code>enum</code>：</p>
<pre><code class="language-rust ignore">pub enum Data {
    Struct(DataStruct),
    Enum(DataEnum),
    Union(DataUnion),
}
</code></pre>
<p>可见，这里的Data确实是支持<code>struct</code>、<code>enum</code>、<code>union</code>三种结构的，但我们的<code>Builder</code>宏只支持<code>struct</code>，所以先忽略另外两个。 我们看<a href="https://docs.rs/syn/1.0.58/syn/struct.DataStruct.html"><code>DataStruct</code>的定义</a>： </p>
<pre><code class="language-rust ignore">pub struct DataStruct {
    pub struct_token: Struct,
    pub fields: Fields,
    pub semi_token: Option&lt;Semi&gt;,
}
</code></pre>
<p>它包含了一个<code>struct</code>的Token，一些字段<code>Fields</code>，以及一个可选的分号<code>;</code>Token。继续看<a href="https://docs.rs/syn/1.0.58/syn/enum.Fields.html"><code>Fields</code>的定义</a>：</p>
<pre><code class="language-rust ignore">pub enum Fields {
    Named(FieldsNamed),
    Unnamed(FieldsUnnamed),
    Unit,
}
</code></pre>
<p>也是一个<code>enum</code>。这是由于结构体中的字段有具名和匿名（类似元组Tuple）两种写法，还有一种不含任何字段的空结构体<code>Fields::Unit</code>。<code>Fields</code>类有一个<code>iter</code>函数</p>
<pre><code class="language-rust ignore">impl Fields {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, Field&gt; { /*...*/ }
}
</code></pre>
<p>可以生成其字段的迭代器，我们再看Field的定义：</p>
<pre><code class="language-rust ignore">pub struct Field {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Option&lt;Ident&gt;,
    pub colon_token: Option&lt;Colon&gt;,
    pub ty: Type,
} 
</code></pre>
<p>终于找到了我们所需要的信息！其中的<code>ident: Option&lt;Ident&gt;</code>即是可选的字段名（但由于我们的<code>Builder</code>类只支持具名结构体，所以字段名是必须的），<code>ty: Type</code>即为类型信息。</p>
<h2 id="遍历结构体字段"><a class="header" href="#遍历结构体字段">遍历结构体字段</a></h2>
<p>要遍历结构体的字段，首先需要将字段提取出来。前面已经介绍了<code>DeriveInput</code>相关的结构，那么我们需要做的就是用<code>match</code>或<code>if let</code>的方式过滤出需要的信息。</p>
<p>设计只考虑具名的<code>struct</code>类型，因此用<code>if let</code>匹配单个分支即可：</p>
<pre><code class="language-rust ignore">if let Data::Struct(r#struct) = input.data {
    let fields = r#struct.fields;
    if matches!(&amp;fields, Fields::Named(_)) {
        todo!()
    }
} 
</code></pre>
<p>在<code>todo!()</code>处则已经拿到了<code>fields: Fields</code>，且它是具名的。至于不用<code>if let</code>取出<code>Fields::Named(_)</code>实体的原因是：即使用<code>Named(FieldsNamed)</code>提取出的<code>Field</code>结构体中的<code>ident: Option&lt;Ident&gt;</code>也需要<code>.unwrap()</code>之后才能取出<code>Ident</code>，所以此处用原来的<code>fields: Fields</code>即可。</p>
<p>现在用我们将<code>Fields</code>映射为<code>TokenStream2</code>，以便嵌入最终生成的代码中。 </p>
<pre><code class="language-rust ignore">let builder_fields = TokenStream2::from_iter(
    fields
        .iter() // 1
        .map(|field: &amp;Field| (field.ident.as_ref().unwrap(), &amp;field.ty)) // 2
        .map(|(ident: &amp;Ident, ty: &amp;Type)| quote!(#ident: Option&lt;#ty&gt;, )), // 3
);
</code></pre>
<ul>
<li><code>// 1</code>处的<code>fields.iter()</code>产生了<code>&amp;Field</code>的迭代器，由于<code>fields</code>可能被多次使用，所以用只读迭代器，而非按值传递将其消耗；</li>
<li><code>// 2</code>处的<code>.map(...)</code>提取出<code>Field</code>中的标识符<code>&amp;Ident</code>与类型<code>&amp;Type</code>（由于前面保证了结构体字段是具名的，此处直接调用<code>Option::unwrap</code>即可）；</li>
<li><code>// 3</code>处的<code>.map(...)</code>根据提取出的<code>ident</code>和<code>ty</code>生成<code>#ident: Option&lt;#ty&gt;,</code>的<code>TokenStream</code>，注意不要漏掉末尾的Token。</li>
</ul>
<p>最后，<code>TokenStream2::from_iter</code>函数将以上的多个<code>TokenStream2</code>串联在一起。对<code>Command</code>类而言，将生成</p>
<pre><code class="language-rust ignore">executable: Option&lt;String&gt;,
args: Option&lt;Vec&lt;String&gt;,
current_dir: Option&lt;String&gt;, 
</code></pre>
<p>只需要将上述生成的字段嵌入<code>CommandBuilder</code>结构体中，一个带字段的<code>CommandBuilder</code>结构体便生成好了：</p>
<pre><code class="language-rust ignore">quote! {
    pub struct CommandBuilder {
<span class="boring">        builder_fields
</span>    }
}
</code></pre>
<p>在为<code>CommandBuilder</code>类添加字段后，<code>Command::builder</code>函数中生成<code>CommandBuilder</code>的默认实例还未添加字段初始值，这里简单起见，我们用<code>#[derive(Default)]</code>派生宏自动为<code>CommandBuilder</code>类实现<code>Default</code> Trait，从而可以调用该Trait的<code>default()</code>函数生成其默认实例。</p>
<pre><code class="language-rust ignore">quote! {
    impl Command {
        pub fn builder() -&gt; CommandBuilder {
            CommandBuilder::default()
        }
    }

    #[derive(Default)]
    pub struct CommandBuilder {
<span class="boring">        builder_fields
</span>    }
}
</code></pre>
<h2 id="成员函数的生成"><a class="header" href="#成员函数的生成">成员函数的生成</a></h2>
<p>接下来，将为<code>CommandBuilder</code>添加字段的设置函数。以<code>executable</code>参数为例，期望通过以下函数设置其值：</p>
<pre><code class="language-rust ignore">impl CommandBuilder {
    pub fn executable(mut self, value: String) -&gt; Self {
        self.executable = Some(executable);
        self
    }
}  
</code></pre>
<p>这里的<code>self</code>选择传值是因为希望<code>CommandBuilder</code>类用完即毁，将其中所存的值直接转移到最终创建的<code>Command</code>实例中，避免复制开销。返回一个<code>Self</code>对象是为了实现链式调用。
显然，生成成员函数时也涉及原结构体字段的遍历，因此我们重用<code>builder_fields</code>的生成函数，将其写成一个通用函数：</p>
<pre><code class="language-rust ignore">fn map_fields&lt;F&gt;(fields: &amp;Fields, mapper: F) -&gt; TokenStream2
where
    F: FnMut((&amp;Ident, &amp;Type)) -&gt; TokenStream2,
{
    TokenStream2::from_iter(
        fields
            .iter()
            .map(|field| (field.ident.as_ref().unwrap(), &amp;field.ty))
            .map(mapper),
    )
}
</code></pre>
<p>因此即可用不同的映射函数或闭包以生成不同的<code>TokenStream</code>了。</p>
<p>首先是设置字段的成员函数，相对较简单：</p>
<pre><code class="language-rust ignore">let builder_set_fields = map_fields(&amp;fields, |(ident: &amp;Field, ty: &amp;Type)| {
    quote!(pub fn #ident(mut self, value: #ty) -&gt; Self {
        self.#ident = Some(value);
        self
    })
});
</code></pre>
<p>基本上就是将前面手写的<code>executable</code>函数中的字段名和类型替换成统一的<code>#ident</code>和<code>#ty</code>即可，非常方便。</p>
<p>最后是<code>CommandBuilder::build</code>函数，它将消耗自身，并生成一个Result&lt;Command, String&gt;实例。当所有字段都已设置时，返回正常的<code>Command</code>对象，否则返回错误信息（这里简单起见，暂时用<code>String</code>）。</p>
<p><code>build</code>函数可以分为两部分：第一部分是依次取出由<code>Option&lt;&gt;</code>包装过的<code>CommandBuilder</code>类中的各个字段的值，第二部分是生成目标<code>Command</code>实例。</p>
<p>先看第一部分，直接遍历原结构体中的字段即可：</p>
<pre><code class="language-rust ignore">let build_lets = map_fields(&amp;fields, |(ident, _)| { // 忽略用不到的ty
    quote!(
        let #ident = self.#ident.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(#ident),
        ))?;
    )
});
</code></pre>
<p>这里用到了<code>Option::ok_or</code>方法，当其为<code>None</code>时，返回一个错误值，然后用?运算符取出其中正确的值（若出现错误值，则直接将错误值返回上层）。</p>
<p>取出了构造结构体所需要的各字段值后，第二部分就变得相对简单了，直接返回一个<code>Ok(Command{ executable, args, current_dir, })</code>即可。外层的字段名再用一次结构体字段遍历可得：</p>
<pre><code class="language-rust ignore">let build_values = map_fields(&amp;fields, |(ident, _)| quote!(#ident,));      
</code></pre>
<p>注意不要漏掉逗号<code>,</code>。</p>
<p>最后将代码全部合到一起：</p>
<pre><code class="language-rust ignore">fn map_fields&lt;F&gt;(fields: &amp;Fields, mapper: F) -&gt; TokenStream2
where
    F: FnMut((&amp;Ident, &amp;Type)) -&gt; TokenStream2,
{
    TokenStream2::from_iter(
        fields
            .iter()
            .map(|field| (field.ident.as_ref().unwrap(), &amp;field.ty))
            .map(mapper),
    )
}

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = Ident::new(&amp;format!(&quot;{}Builder&quot;, ident), ident.span());
    if let Data::Struct(r#struct) = input.data {
        let fields = r#struct.fields;
        if matches!(&amp;fields, Fields::Named(_)) {
            let builder_fields = map_fields(&amp;fields, |(ident, ty)| quote!(#ident: Option&lt;#ty&gt;, ));
            let builder_set_fields = map_fields(&amp;fields, |(ident, ty)| {
                quote!(pub fn #ident(mut self, value: #ty) -&gt; Self {
                    self.#ident = Some(value);
                    self
                })
            });
            let build_lets = map_fields(&amp;fields, |(ident, _)| {
                quote!(
                    let #ident = self.#ident.ok_or(format!(
                        &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
                        stringify!(#ident),
                    ))?;
                )
            });
            let build_values = map_fields(&amp;fields, |(ident, _)| quote!(#ident,));
            quote!(
                impl #ident {
                    pub fn builder() -&gt; #ident_builder {
<span class="boring">                        ident_builder::default()
</span>                    }
                }

                #[derive(Default)]
                pub struct #ident_builder {
<span class="boring">                    builder_fields
</span>                }

                impl #ident_builder {
<span class="boring">                    builder_set_fields
</span>
                    pub fn build(self) -&gt; Result&lt;#ident, String&gt; {
<span class="boring">                        build_lets
</span>                        Ok(#ident { #build_values })
                    }
                }
            )
            .into()
        }
    }
    quote!().into()
}
</code></pre>
<h2 id="输出tokenstream2以检验生成结果"><a class="header" href="#输出tokenstream2以检验生成结果">输出<code>TokenStream2</code>以检验生成结果</a></h2>
<p>上一章中讲到可以用<code>cargo expand</code>命令来检验代码生成结果。但由于本文中用到了<code>#[defive(Default)</code>派生宏以及<code>format!</code>规则宏等，若用<code>cargo expand</code>命令展开，会有一些不相干的信息，代码会很繁琐。但实际上除了<code>cargo expand</code>之后，还可以直接输出<code>TokenStream2</code>来检验生成结果。</p>
<p>方法很简单，直接将<code>quote!</code>宏生成出的<code>TokenStream2</code>用<code>eprintln!</code>宏输出即可（<code>eprintln!</code>的用法与<code>println!</code>相似，只不过是输出到标准错误<code>stderr</code>中）：</p>
<pre><code class="language-rust ignore">let tokens = quote!( /* ... */ );
eprintln!(&quot;{}&quot;, tokens); 
</code></pre>
<p>输出后的代码未经格式化，我们可以手动复制到一个空白文件然后使用<code>rustfmt</code>程序格式化，得</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder::default()
    }
}
#[derive(Default)]
pub struct CommandBuilder {
    executable: Option&lt;String&gt;,
    args: Option&lt;Vec&lt;String&gt;&gt;,
    current_dir: Option&lt;String&gt;,
}
impl CommandBuilder {
    pub fn executable(mut self, value: String) -&gt; Self {
        self.executable = Some(value);
        self
    }
    pub fn args(mut self, value: Vec&lt;String&gt;) -&gt; Self {
        self.args = Some(value);
        self
    }
    pub fn current_dir(mut self, value: String) -&gt; Self {
        self.current_dir = Some(value);
        self
    }
    pub fn build(self) -&gt; Result&lt;Command, String&gt; {
        let executable = self.executable.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(executable),
        ))?;
        let args = self.args.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(args),
        ))?;
        let current_dir = self.current_dir.ok_or(format!(
            &quot;field \&quot;{}\&quot; required, but not set yet.&quot;,
            stringify!(current_dir),
        ))?;
        Ok(Command {
            executable,
            args,
            current_dir,
        })
    }
}
</code></pre>
<p>这种方法在调用派生宏中出现编译错误时尤其有用，不仅可以用来检验整体代码片段，也可以随时查看某一小片段，便于调试。</p>
<h2 id="功能验证"><a class="header" href="#功能验证">功能验证</a></h2>
<p>最后，为了验证派生宏的功能正确，将编译运行以下程序：</p>
<pre><code class="language-rust ignore">use derive_builder::Builder;

#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}

fn main() {
    let command = Command::builder()
        .executable(&quot;cargo&quot;.to_owned())
        .args(vec![&quot;build&quot;.to_owned(), &quot;--release&quot;.to_owned()])
        .current_dir(&quot;..&quot;.to_owned())
        .build()
        .unwrap();

    assert_eq!(command.executable, &quot;cargo&quot;);
    assert_eq!(command.args, &amp;[&quot;build&quot;, &quot;--release&quot;]);
    assert_eq!(command.current_dir, &quot;..&quot;);
}
</code></pre>
<p>程序将正常执行结束，无任何输出。</p>
<hr />
<p>本期的介绍到此为止，主要介绍了如何遍历<code>Command</code>结构体中的字段信息，并生成<code>CommandBuilder</code>类的字段与成员函数，实现了一个最简单可用的<code>Builder</code>类。接下来将继续如何处理原结构体中的可选、多选字段等功能。 </p>
<p>本文中的代码实现详见 <a href="https://github.com/frank-king/proc-macro-workshop/tree/example/builder/05-method-chaining.rs/builder%E2%80%8B">https://github.com/frank-king/proc-macro-workshop/tree/example/builder/05-method-chaining.rs/builder​</a>。</p>
<p>其中，测试用的<code>main.rs</code>代码见<a href="https://github.com/frank-king/proc-macro-workshop/blob/example/builder/05-method-chaining.rs/main.rs"><code>example/builder/05-method-chaining.rs</code>中的<code>main.rs</code>文件</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        <script src="https://utteranc.es/client.js"
                repo="frank-king/rustblog-zh"
                issue-term="title"
                theme="github-dark"
                crossorigin="anonymous"
                async>
        </script>

    </body>
</html>
