<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>（三）实现简易派生宏 - Rust中文博客</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html">序言</a></li><li class="chapter-item expanded affix "><li class="part-title">2022-01</li><li class="chapter-item expanded "><a href="../2022-01-polonius/00.html">Polonius学习笔记</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2022-01-polonius/01-21-借用检查（零）-原子式与输入.html">（零）原子式与输入</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/01-21-借用检查（一）-初始化分析.html">（一）初始化分析</a></li><li class="chapter-item expanded "><a href="../2022-01-polonius/01-23-借用检查（二）-存活性分析.html">（二）存活性分析</a></li><li class="chapter-item expanded "><div>（三）借用检查分析</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">2021-09</li><li class="chapter-item expanded "><a href="../2021-09-ghost-cell/09-03-ghost-cell.html">Ghost Cell试用体验</a></li><li class="chapter-item expanded affix "><li class="part-title">2021-01</li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/00.html">Rust过程宏入门系列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-06-过程宏（一）-过程宏简介.html">（一）过程宏简介</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html">（二）初探派生宏</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-10-过程宏（三）-实现简易派生宏.html" class="active">（三）实现简易派生宏</a></li><li class="chapter-item expanded "><a href="../2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html">（四）遍历结构体字段</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust中文博客</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/frank-king/rustblog-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust过程宏入门三实现简易派生宏"><a class="header" href="#rust过程宏入门三实现简易派生宏">Rust过程宏入门（三）——实现简易派生宏</a></h1>
<p>写于2021年1月10日。最早发表于<a href="https://zhuanlan.zhihu.com/p/343170504">知乎</a>。</p>
<h2 id="再谈派生宏的原理"><a class="header" href="#再谈派生宏的原理">再谈派生宏的原理</a></h2>
<p>简单起见，我们先假定<code>Command</code>结构体中只有必填单选项，无选填或多选项，简化后的<code>Command</code>类如下：</p>
<pre><code class="language-rust ignore">#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
</code></pre>
<p>首先实现<code>Command</code>类中的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}

pub struct CommandBuilder;
</code></pre>
<p>为此派生宏创建一个crate，注意需要在<code>Cargo.toml</code>中加上</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>以表示该crate将编译为一个过程宏库。
回顾一下派生宏的定义方式，我们需要根据输入的<code>TokenStream</code>生成目标<code>TokenStream</code>。 </p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let _ = input;

    unimplemented!()
}
</code></pre>
<p>编译器会将派生宏作用的结构体（或<code>enum</code>、<code>union</code>）展开成<code>TokenStream</code>作为函数参数传入。不出意料的话，展开后的<code>TokenStream</code>会由如下几项构成：</p>
<blockquote>
<p>关键字<code>pub</code> 关键字<code>struct</code> 标识符<code>Command</code> 花括号<code>{</code></p>
<p>标识符<code>executable</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>标识符<code>args</code> 冒号<code>:</code> 标识符<code>Vec</code> 小于号<code>&lt;</code> 标识符<code>String</code> 大于号<code>&gt;</code> 逗号<code>,</code> </p>
<p>标识符<code>current_dir</code> 冒号<code>:</code> 标识符<code>String</code>逗号<code>,</code></p>
<p>花括号<code>}</code></p>
</blockquote>
<p>我们需要用到的Token有：结构体名标识符<code>Command</code>，每个字段的名字标识符与类型的Token串。其他信息只起结构标记的作用，无需用到。</p>
<p>应当如何提取这些信息呢？</p>
<p>一种方法是利用<code>TokenStream</code>类的<code>to_string</code>函数，将这些Token转换为字符串，然后再用字符串处理的手段提取其中的信息。但这就有一个问题：编译器好不容易将源代码文件中的文本信息（也即字符串），转换成了语法树，在此处展开成<code>TokenStream</code>以调用过程宏处理，但我们反而再次将<code>TokenStream</code>转换为原始的字符串，岂不多此一举？</p>
<p>另一种方法是使用<a href="https://docs.rs/syn/1.0.58/syn/index.html">syn库</a>。syn库提供了表示语法解析结果（一般为语法树上的某一节点）的一系列类。</p>
<p>若要使用syn库，需要在项目的<code>Cargo.toml</code>文件中指定：</p>
<pre><code class="language-toml">[dependencies]
syn = &quot;1.0&quot; 
</code></pre>
<h2 id="认识deriveinput"><a class="header" href="#认识deriveinput">认识DeriveInput</a></h2>
<p>由于派生宏的使用场景相对固定（目前只能作用于<code>struct</code>、<code>enum</code>、<code>union</code>），syn库中已提供了派生宏输入项的封装——<code>DeriveInput</code>。其结构如下：</p>
<pre><code class="language-rust ignore">pub struct DeriveInput {
    pub attrs: Vec&lt;Attribute&gt;,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
} 
</code></pre>
<p>其中<code>ident</code>字段正是我们所需的结构体名的标识符。结合<code>parse_macro_input!</code>宏，容易将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    unimplemented!()
}
</code></pre>
<p>若以<code>#ident</code>指代结构体名<code>Command</code>，那么我们已经可以实现一个简易版的<code>builder</code>函数：</p>
<pre><code class="language-rust ignore">impl #ident {
    pub fn builder() -&gt; #identBuilder {
<span class="boring">        identBuilder
</span>    }
}

pub struct #identBuilder;
</code></pre>
<p>当然上述代码中的<code>#identBuilder</code>是有问题的，这里暂时跳过。</p>
<h2 id="用quote宏生成tokenstream"><a class="header" href="#用quote宏生成tokenstream">用<code>quote!</code>宏生成<code>TokenStream</code></a></h2>
<p>如何生成这段代码呢？不难想到，可以直接用字符串拼接的方法再转换成<code>TokenStream</code>输出，但这会让编译器再多一层词法分析的步骤，且不易阅读与扩展。（字符串格式化的占位符是<code>{}</code>，当输入代码篇幅较大时，占位符与实际传入参数相隔很远，且不便于一一对应。）</p>
<p>另一种方法是用<a href="https://docs.rs/quote/1.0.8/quote/index.html">quote库</a>，同样需在<code>Cargo.toml</code>后面加上<code>quote = &quot;1.0&quot;</code>的依赖。</p>
<p>quote库中的<code>quote!</code>宏提供了将Rust语法项展开为<code>TokenStream</code>的功能， 包含在<code>quote!</code>宏中的任何Rust代码都将展开为<code>TokenStream</code>，而以<code>#</code>开头的标识符将引用前文中已定义的标识符，而非像字符串格式化那样使用<code>{}</code>并在末尾传入参数的方式。这便是笔者在上文中用<code>#ident</code>指代<code>Command</code>类名的原因。</p>
<p>需要注意的是，与syn库搭配的<code>TokenStream</code>来自<a href="https://docs.rs/proc-macro2/1.0.24/proc_macro2/struct.TokenStream.html">proc_macro2库</a>， 其别名为<code>TokenStream2</code>，需要用<code>.into()</code>方法转换为<code>TokenStream</code>才能作为过程宏函数的返回值。</p>
<p>用<code>quote!</code>宏包含<code>Command::builder</code>函数的实现部分，得：</p>
<pre><code class="language-rust ignore">#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = /* 暂时跳过 */;
    quote!(
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder::default()
</span>            }
        }
        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<h2 id="拼接标识符"><a class="header" href="#拼接标识符">拼接标识符</a></h2>
<p>最后回到<code>CommandBuilder</code>标识符的问题。刚才提到，<code>Command</code>标识符可由<code>DeriveInput</code>直接获取，但<code>CommandBuilder</code>的标识符却需要手动拼接生成。</p>
<p>笔者联想到C++中的宏定义中有<code>##</code>运算符可用于拼接标识符，譬如<code>#define CONCAT(a, b) a##b</code>，<code>CONCAT(foo, bar)</code>就会得到一个<code>foobar</code>的标识符，想必Rust应当也有类似的宏，于是搜索Rust标准库发现果然有一个名为<code>concat_idents!</code>的宏，然后这样写：</p>
<pre><code class="language-rust ignore">pub struct concat_idents!(#ident, Builder);
</code></pre>
<p>但尝试未果，总是会报出类似<code>error: expected `where`, `{`, `(`, or `;` after struct name, found `!` </code>的错误。后来才发现Rust中并不支持在标识符位置的宏调用（详见<a href="https://github.com/rust-lang/rust/issues/4365">rust-lang/rust#4365 · Macros don't get expanded when used in item name token position</a>）。编译器会将<code>concat_idents</code>当作<code>struct</code>的名字标识符 ，然后并不知道如何处理这个叹号<code>!</code>Token， 故而只能报编译错误。</p>
<p>几经周折，最终还是选择了手动拼接构造标识符，因为标识符位置不可用宏，所以一切基于宏的办法都失效了，总不至于退回到原始的字符串拼接的方式吧？</p>
<p>所幸syn库中的<code>Ident</code>类有由字符串新建实例的构造函数<code>new</code>，但观察其构造函数</p>
<pre><code class="language-rust ignore">pub fn new(string: &amp;str, span: Span) -&gt; Ident
</code></pre>
<p>发现，除了传入一个字符串以外，还需要一个<code>Span</code>对象。<code>Ident</code>类中的<a href="https://docs.rs/syn/1.0.58/syn/struct.Ident.html">文档示例代码</a>是传入了一个<code>Span::call_cite()</code>，如：</p>
<pre><code class="language-rust ignore">let ident = Ident::new(&quot;demo&quot;, Span::call_site());
let temp_ident = Ident::new(&amp;format!(&quot;new_{}&quot;, ident), Span::call_site());     
</code></pre>
<p>文档中对Span::call_cite()的解释是：</p>
<blockquote>
<p>identifiers created with this span will be resolved as if they were written directly at the location of the macro call, and other code at the macro call site will be able to refer to them as well. </p>
</blockquote>
<p>大致意思是，标识符的<code>span</code>会解析为宏调用的地方。如何理解「<code>span</code>」的含义呢？在<code>Span</code>的文档中有定义：</p>
<blockquote>
<p>A region of source code, along with macro expansion information.</p>
</blockquote>
<p>即<code>Span</code>代表了源代码的某一区间，并携带了宏展开的信息。也就是说，<code>Ident::new()</code>中传入的<code>Span</code>是用来定位标识符的位置的。而<code>CommandBuilder</code>标识符是与<code>Command</code>相关联的，不妨将其<code>span</code>设置为<code>Command</code>标识符的区间就好。 因此有：</p>
<pre><code class="language-rust ignore">let ident = input.ident;
let ident_builder = Ident::new(&amp;format!(&quot;{}Buidler&quot;, ident), ident.span());
</code></pre>
<h2 id="利用cargo-expand命令检验代码生成结果"><a class="header" href="#利用cargo-expand命令检验代码生成结果">利用<code>cargo expand</code>命令检验代码生成结果</a></h2>
<p>将前面的代码全部综合到一起，得：</p>
<pre><code class="language-rust ignore">use proc_macro::TokenStream;

use quote::quote;
use syn::{parse_macro_input, DeriveInput, Ident};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let ident = input.ident;
    let ident_builder = Ident::new(&amp;format!(&quot;{}Builder&quot;, ident), ident.span());
    quote! (
        impl #ident {
            pub fn builder() -&gt; #ident_builder {
<span class="boring">                ident_builder
</span>            }
        }

        pub struct #ident_builder;
    )
    .into()
}
</code></pre>
<p>最后我们用<code>cargo expand</code>命令来检验生成的代码。这里要指出的是，使用过程宏须与定义过程中处在不同的crate中。</p>
<pre><code class="language-rust ignore">use derive_builder::Builder;

#[allow(dead_code)] // 忽略警告
#[derive(Builder)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}

fn main() {}
</code></pre>
<p>展开后将得到：</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
use derive_builder::Builder;
#[allow(dead_code)]
pub struct Command {
    executable: String,
    args: Vec&lt;String&gt;,
    current_dir: String,
}
impl Command {
    pub fn builder() -&gt; CommandBuilder {
        CommandBuilder
    }
}
pub struct CommandBuilder;
fn main() {}
</code></pre>
<p>正是所期望的结果。</p>
<hr />
<p>本期的介绍到此为止，主要介绍了如何将输入的<code>TokenStream</code>解析为<code>DeriveInput</code>，提取其中的名字信息，使用<code>Ident</code>类提供的构造函数拼接成新的标识符，最后用<code>quote!</code>宏生成目标代码的<code>TokenStream</code>。 接下来将继续介绍用派生宏实现<code>CommandBuilder</code>类的字段生成、函数实现等功能。 </p>
<p>本文中的代码实现详见 <a href="https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder">https://github.com/frank-king/proc-macro-workshop/tree/example/builder/01-parse.rs/builder</a>。</p>
<p>其中，测试用的<code>main.rs</code>代码见<a href="https://github.com/frank-king/proc-macro-workshop/blob/example/builder/01-parse.rs/main.rs"><code>example/builder/01-parse.rs</code>中的<code>main.rs</code>文件</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2021-01-proc-macro/01-07-过程宏（二）-初探派生宏.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../2021-01-proc-macro/01-16-过程宏（四）-遍历结构体字段.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script src="https://utteranc.es/client.js"
                repo="frank-king/rustblog-zh"
                issue-term="title"
                theme="github-dark"
                crossorigin="anonymous"
                async>
        </script>

    </body>
</html>
